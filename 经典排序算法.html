<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="经典排序算法"><meta name="keywords" content><meta name="author" content="HB"><meta name="copyright" content="HB"><title>经典排序算法 | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法概述"><span class="toc-number">1.</span> <span class="toc-text"> 排序算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法分类"><span class="toc-number">1.1.</span> <span class="toc-text"> 算法分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法时间复杂度"><span class="toc-number">1.2.</span> <span class="toc-text"> 算法时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关概念"><span class="toc-number">1.3.</span> <span class="toc-text"> 相关概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法实现"><span class="toc-number">2.</span> <span class="toc-text"> 排序算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#公共代码实现"><span class="toc-number">2.1.</span> <span class="toc-text"> 公共代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序bubble-sort"><span class="toc-number">2.2.</span> <span class="toc-text"> 冒泡排序（Bubble Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序quick-sort"><span class="toc-number">2.3.</span> <span class="toc-text"> 快速排序（Quick Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二路快速排序quick-sort-2-ways"><span class="toc-number">2.4.</span> <span class="toc-text"> 二路快速排序（Quick Sort 2 Ways）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三路快速排序quick-sort-3-ways"><span class="toc-number">2.5.</span> <span class="toc-text"> 三路快速排序（Quick Sort 3 Ways）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序insertion-sort"><span class="toc-number">2.6.</span> <span class="toc-text"> 插入排序（Insertion Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序shell-sort"><span class="toc-number">2.7.</span> <span class="toc-text"> 希尔排序（Shell Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序shell-sort"><span class="toc-number">2.8.</span> <span class="toc-text"> 选择排序（Shell Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序heap-sort"><span class="toc-number">2.9.</span> <span class="toc-text"> 堆排序（Heap Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序merge-sort"><span class="toc-number">2.10.</span> <span class="toc-text"> 归并排序（Merge Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路归并排序merge-sort"><span class="toc-number">2.11.</span> <span class="toc-text"> 多路归并排序（Merge Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计数排序counting-sort"><span class="toc-number">2.12.</span> <span class="toc-text"> 计数排序（Counting Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序bucket-sort"><span class="toc-number">2.13.</span> <span class="toc-text"> 桶排序（Bucket Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序radix-sort"><span class="toc-number">2.14.</span> <span class="toc-text"> 基数排序（Radix Sort）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">3.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">经典排序算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.8k</span><span class="post-meta__separator">|</span><span>Reading time: 28 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="排序算法概述"><a class="markdownIt-Anchor" href="#排序算法概述"></a> 排序算法概述</h2>
<h3 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h3>
<ol>
<li>
<p>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；</p>
</li>
<li>
<p>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>
</li>
</ol>
<p>以下是常用的十一种排序算法：</p>
<img src="/经典排序算法/totalSort.png" title="totalSort">
<h3 id="算法时间复杂度"><a class="markdownIt-Anchor" href="#算法时间复杂度"></a> 算法时间复杂度</h3>
<img src="/经典排序算法/time.png" title="time">
<h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3>
<ol>
<li>稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ol>
<h2 id="排序算法实现"><a class="markdownIt-Anchor" href="#排序算法实现"></a> 排序算法实现</h2>
<h3 id="公共代码实现"><a class="markdownIt-Anchor" href="#公共代码实现"></a> 公共代码实现</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 交换两个元素值</span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 得到最大值</span><br><span class="line">private int getMaxValue (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (maxValue &lt; nums[i]) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最小值</span><br><span class="line">private int getMinValue (int[] nums) &#123;</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (minValue &gt; nums[i]) &#123;</span><br><span class="line">           minValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#冒泡排序bubble-sort"></a> 冒泡排序（Bubble Sort）</h3>
<ol>
<li>
<p>概述<br>
它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;数列的顶端。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；</li>
<li>针对所有的元素重复以上的步骤，最后已排序好的元素不需要再次比较；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
 <img src="/经典排序算法/bubbleSort.gif" title="bubbleSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bubbleSort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 当最外层循环遍历完毕, 则代表着数组有序</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 从头开始依次两两比较, 比较结束条件为len - i - 1</span><br><span class="line">        for(int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">            // 比较相邻的两个元素, 若前者大于后者, 则进行交换</span><br><span class="line">            if (nums[j] &gt; nums[j + 1])&#123;</span><br><span class="line">                swap(nums, j + 1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="快速排序quick-sort"><a class="markdownIt-Anchor" href="#快速排序quick-sort"></a> 快速排序（Quick Sort）</h3>
<ol>
<li>
<p>概述<br>
快速排序的基本思想是：通过一趟排序以基准元素为基础将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序（分别进行划分），整个排序过程可以递归进行，使整个数据变成有序序列。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，该位置称为 K ；</li>
<li>根据第2步得到的基准元素位置 K，递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列进行1~2步的分区操作。</li>
</ol>
 <img src="/经典排序算法/QuickSort.gif" title="QuickSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    quickSort(nums, 0, len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 - left &gt;= right时</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 2. 递进操作</span><br><span class="line">        // 递归排序分区, 返回基准元素所在位置</span><br><span class="line">        int partitionIndex = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, partitionIndex - 1);</span><br><span class="line">        quickSort(nums, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 选择最左边的数为基准元素</span><br><span class="line">    int pivot = left;</span><br><span class="line">    // 以基准元素为比较元素开始分区操作</span><br><span class="line">    int index = pivot + 1;</span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行 </span><br><span class="line">    index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, pivot, index - 1);</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>排序优化<br>
快速排序的运行时间与划分是否对称有关。最坏情况下，每次划分过程产生两个区域分别包含n-1个元素和1个元素，其时间复杂度会达到O(n^2)。在最好的情况下，每次划分所取的基准都恰好是中值，即每次划分都产生两个大小为n/2的区域。此时，快排的时间复杂度为O(nlogn)。所以基准的选择对快排而言至关重要。<br>
如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。<br>
为了解决上述问题，可以采用随机基准的方式来应对上述特殊情况。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">     </span><br><span class="line">    // 将随机选择一个元素作为基准元素</span><br><span class="line">    // Math.Random()函数能够返回带正号的double值, 该值大于等于0.0且小于1.0</span><br><span class="line">    int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 将随机索引处的元素与left处进行交换</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量index，其[pivot + 1,index)范围内的元素小于基准元素</span><br><span class="line">    int index = left + 1;</span><br><span class="line"></span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行</span><br><span class="line">    // index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    // 2. 定义变量i，其[index, i - 1]范围内的元素大于基准元素</span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        // 3. 触发index变量转移条件，保证循环不变量定义正确</span><br><span class="line">        if (nums[i] &lt; nums[left]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, left, index - 1);</span><br><span class="line">    // 4. 返回结果</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二路快速排序quick-sort-2-ways"><a class="markdownIt-Anchor" href="#二路快速排序quick-sort-2-ways"></a> 二路快速排序（Quick Sort 2 Ways）</h3>
<ol>
<li>
<p>概述<br>
二路快速排序的时间和空间复杂度同随机化快速排序。 但是对于有大量重复元素的数组，如果使用随机化快速排序效率是非常低的，导致 partition 后大于基点或者小于基点数据的子数组长度会极度不平衡，甚至会退化成 O(n^2)时间复杂度的算法，对这种情况可以使用双路快速排序算法。</p>
</li>
<li>
<p>算法思路<br>
双路快速排序算法是随机化快速排序的改进版本，partition 过程使用两个索引值（i、j）用来遍历数组，将  &lt;= V 的元素放在索引i所指向位置的左边，而将 &gt;= V的元素放在索引 j 所指向位置的右边，V 代表标定值，平衡左右两边子数组。</p>
 <img src="/经典排序算法/quickSort2.png" title="quickSort3">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void quickSort2ways (int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件</span><br><span class="line">    if (left &gt; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int index = partition2(nums, left, right);</span><br><span class="line">    quickSort3Ways(nums, left, index - 1);</span><br><span class="line">    quickSort3Ways(nums, index + 1, right);</span><br><span class="line"></span><br><span class="line">    // 3. 递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partition2(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 随机选择一个基准</span><br><span class="line">    int randomIndex = (int) (Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 交换left和randomIndex的位置</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line">    int v = nums[left];</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量i, 其在[left + 1, i)范围中的元素 &lt;= v</span><br><span class="line">    //    定义变量j, 其在(j, right] 范围中的元素 &gt;= v</span><br><span class="line">    int i = left + 1, j = right;</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量i改变条件</span><br><span class="line">        while (i &lt;= right &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量j改变条件</span><br><span class="line">        while (j &gt;= left + 1 &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 循坏退出条件</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // 交换 i, j索引处元素</span><br><span class="line">        // 此时若 nums[i] == nums[j] == v, 也会进行交换</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放置到正确位置上</span><br><span class="line">    swap(nums, left, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三路快速排序quick-sort-3-ways"><a class="markdownIt-Anchor" href="#三路快速排序quick-sort-3-ways"></a> 三路快速排序（Quick Sort 3 Ways）</h3>
<ol>
<li>
<p>概述<br>
三路快速排序时间和空间复杂度同随机化快速排序。三路快速排序算法是使用三路划分策略对数组进行划分，对处理大量重复元素的数组非常有效提高快速排序的过程。它增加了处理等于基准元素值的逻辑，将所有等于基准元素的值集中在一起。</p>
</li>
<li>
<p>算法思路<br>
三路快速排序是双路快速排序的进一步改进版本，三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，等于 v 的数据在下次递归中不再需要排序，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优。</p>
 <img src="/经典排序算法/quickSort3.png" title="quickSort3">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort3Ways(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 left &gt;= right</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 随机选择一个基准</span><br><span class="line">        int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        int curr = nums[left];</span><br><span class="line"></span><br><span class="line">        // 1. 定义lt为[left + 1, lt]中的元素小于curr</span><br><span class="line">        int lt = left;</span><br><span class="line">        // 1. 定义gt为[gt, r]中的元素大于curr</span><br><span class="line">        int gt = right + 1;</span><br><span class="line">        // 1. 定义[lt + 1, i) 中的元素等于curr</span><br><span class="line">        int i = left + 1;</span><br><span class="line"></span><br><span class="line">        // 2. 递归结束条件, i碰到了gt边界</span><br><span class="line">        while (i &lt; gt) &#123;</span><br><span class="line">            if (nums[i] &lt; curr) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                // 3. 触发变量</span><br><span class="line">                swap(nums, lt, i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (nums[i] &gt; curr) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums, i, gt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将基准元素放置在正确位置上</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line"></span><br><span class="line">        // 对[left, lt - 1] 进行处理</span><br><span class="line">        quickSort3Ways(nums, left, lt - 1);</span><br><span class="line">        // 对[gt, right] 进行处理</span><br><span class="line">        quickSort3Ways(nums, gt, right);</span><br><span class="line"></span><br><span class="line">        // 4. 返回结果 - 暂无</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="插入排序insertion-sort"><a class="markdownIt-Anchor" href="#插入排序insertion-sort"></a> 插入排序（Insertion Sort）</h3>
<ol>
<li>
<p>概述<br>
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出有序序列的下一个元素，作为待插入的新元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果有序序列中的元素大于新元素，则从后向前继续比较有序序列中的元素；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
 <img src="/经典排序算法/InsertionSort.gif" title="InsertionSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void insertSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 从下标为1的元素开始选择合适的位置插入, 因为下标0默认是有序的</span><br><span class="line">    for(int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        // 需要插入的新元素</span><br><span class="line">        int curr = nums[i];</span><br><span class="line">        // 从已经排序的序列的最右-&gt;左开始比较</span><br><span class="line">        int j = i;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; curr) &#123;</span><br><span class="line">            // 进行数组的移动</span><br><span class="line">            nums[j] = nums[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到了插入位置</span><br><span class="line">    if(j != i)</span><br><span class="line">        nums[j] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="希尔排序shell-sort"><a class="markdownIt-Anchor" href="#希尔排序shell-sort"></a> 希尔排序（Shell Sort）</h3>
<ol>
<li>
<p>概述<br>
希尔排序是简单插入排序的改进版，是基于插入排序的以下两点性质而提出的一种排序方法：</p>
<ol>
<li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  —&gt; 希尔排序会优先比较距离较远的元素，从而达到更远的移动距离；</li>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 —&gt; 希尔排序在整个序列&quot;基本有序&quot;的时候，直接采用插入排序来进行一次比较。<br>
希尔排序又叫缩小增量排序。</li>
</ol>
</li>
<li>
<p>算法思路</p>
<ol>
<li>选择一个增量序列t1，t2，…，ti，tj，….tk，其中ti&gt;tj，tk=1，增量序列在排序的过程中不断递减；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各个子序列进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
 <img src="/经典排序算法/ShellSort.gif" title="ShellSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    int gap = 1;</span><br><span class="line">    </span><br><span class="line">    // 选择合适的初始值, 如果直接用len/3的话, 后面可能无法递减为1</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;  // 1, 4, 13, 40, 121....  // Tk, Tk-1,.....,T1</span><br><span class="line">    </span><br><span class="line">    // 对序列进行k趟排序</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        // 从下标为gap的元素(从后往前)开始选择合适的位置插入, 因为子序列的第一个元素默认是有序的</span><br><span class="line">        for(int i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            int j = i - gap;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; nums[j] &gt; cur) &#123;</span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将新元素放置到正确位置, j + gap是因为while循环中最后进行了一次j = j - gap</span><br><span class="line">            nums[j + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        // 缩小增量</span><br><span class="line">        gap = gap / 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="选择排序shell-sort"><a class="markdownIt-Anchor" href="#选择排序shell-sort"></a> 选择排序（Shell Sort）</h3>
<ol>
<li>
<p>概述<br>
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>初始未排序区域为nums[0…nums.length - 1]</li>
<li>从未排序区域找到元素值最小的元素，将它和数组中第一个元素交换位置；未排序区域更新为nums[1…nums.length - 1]，从该区域找到第二个元素值最小的元素，将它和数组中第二个元素交换位置，如此反复，直到整个数组排序完成。</li>
</ol>
 <img src="/经典排序算法/SelectionSort.gif" title="SelectionSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void selectionSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 将nums[i] 与 nums[i+1..len - 1]中最小的元素交换</span><br><span class="line">        int min = i;</span><br><span class="line">        // 从无序区域找到一个最小的元素</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="堆排序heap-sort"><a class="markdownIt-Anchor" href="#堆排序heap-sort"></a> 堆排序（Heap Sort）</h3>
<ol>
<li>
<p>概述<br>
堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>初始化堆：堆将待排序序列构造成一个大顶堆/小顶堆（升序 - 大顶堆，降序 - 小顶堆），此时，整个序列的最大值就是堆顶的根节点；</li>
<li>将根节点与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n 个元素的次大值；</li>
<li>如此反复执行，便能得到一个有序序列。</li>
</ol>
 <img src="/经典排序算法/HeapSort.gif" title="HeapSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 堆排序算法</span><br><span class="line">public void heapSort(int[]arr)&#123;</span><br><span class="line">     //1.初始化堆,从最后一个非叶子节点从右向左,从下向上依次进行&quot;堆化&quot;</span><br><span class="line">    for(int i=(arr.length/2)-1; i&gt;=0; i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.依次交换栈顶元素和末尾元素和重新调整堆</span><br><span class="line">    for(int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);</span><br><span class="line">        adjustHeap(arr,0,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整堆</span><br><span class="line">public void adjustHeap(int[]arr,int i,int len)&#123;</span><br><span class="line">    //取出当前元素</span><br><span class="line">    int curr = arr[i];</span><br><span class="line">    //从当前节点的左节点开始比较</span><br><span class="line">    for(intk=i*2+1;k&lt;len;k=k*2+1)&#123;</span><br><span class="line">        //若右节点存在且大于左节点,则切换到左节点进行操作</span><br><span class="line">        if(k+1&lt;len&amp;&amp;arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">            k=k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子节点的值大于父节点</span><br><span class="line">        if(arr[k]&gt;curr)&#123;</span><br><span class="line">            //交换元素值</span><br><span class="line">            arr[i]=arr[k];</span><br><span class="line">            //以孩子节点作为父节点继续进行调整</span><br><span class="line">            i=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i]=curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3>
<ol>
<li>
<p>概述<br>
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>
作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归；</li>
<li>自下而上的迭代。</li>
</ol>
</li>
<li>
<p>算法思路</p>
<ol>
<li>
<p>递归法<br>
在每一层递归上分为三个步骤：<br>
a. 分解（Divide）：将n个元素分为 n / 2 个元素的子序列，然后一直递归分解，直到只剩一个元素；<br>
b. 解决（Conquer）：用合并排序法对两个子序列进行排序；<br>
c. 合并（Combine）：合并两个已排序的子序列得到当前递归层的排序结果。</p>
</li>
<li>
<p>迭代法<br>
先归并那些微型的数组，然后再成对归并得到的子数组，如此这般，直到将整个数组归并完成。<br>
a. 先进行两两归并（归并子数组长度为1），得到一个&quot;部分有序&quot;（两两相邻有序）的数组；<br>
b. 然后对第一步得到的数组进行四四归并（将两个大小为2的数组归并为一个有四个元素的子数组），又得到一个相比于第一步更加有序的数组；<br>
c. 然后是八八归并，一直归并下去，直到整个数组有序；<br>
d. 注意对最后一个子数组的处理，其长度可能小于归并的默认长度。</p>
</li>
</ol>
 <img src="/经典排序算法/MergeSort.gif" title="MergeSort">
</li>
<li>
<p>代码实现</p>
<ol>
<li>
<p>公共代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将nums数组进行归并, 将nums[start..end]和data[mid+1, end]归并成一个更大的有序数组, 其中nums[start..mid],</span><br><span class="line">// nums[mid+1,end]已有序</span><br><span class="line">private void mergeResult(int[] nums, int start, int mid, int end) &#123;</span><br><span class="line">    int i = start, j = mid + 1, len = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 归并所需要的辅助数组</span><br><span class="line">    int[] temp = new int[len];</span><br><span class="line"></span><br><span class="line">    // 辅助数组</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        temp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在temp数组上进行大小比较, 然后temp中的值放回到nums中,返回过程中进行排序</span><br><span class="line">    // 比较方法 - nums[start..mid]和data[mid+1, end]依次开始比较</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        // nums[start..mid]的数据排序完成</span><br><span class="line">        if (i &gt; mid) &#123;</span><br><span class="line">            nums[k] = temp[j++];</span><br><span class="line">        // nums[mid + 1..end]的数据排序完成</span><br><span class="line">        &#125; else if (j &gt; end) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else if (temp[i] &lt; temp[j]) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            nums[k]= temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>递归法代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    merge(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge (int[] nums, int start, int end) &#123;</span><br><span class="line">    // 1. 递归结束条件 -只有一个元素</span><br><span class="line">    if (start == end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int mid = (start + end) / 2;</span><br><span class="line">    // 对左边进行排序</span><br><span class="line">    merge(nums, start, mid);</span><br><span class="line">    // 对右边进行排序</span><br><span class="line">    merge(nums, mid + 1, end);</span><br><span class="line">    // 对上述排序结果进行合并</span><br><span class="line">    mergeResult(nums, start, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代法代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // sz表示子数组的长度</span><br><span class="line">    for (int sz = 1; sz &lt; len; sz = sz + sz) &#123;</span><br><span class="line">        // 以sz为基准, 把nums分为若干个长度为2sz的子数组, 对其进行归并排序                                  </span><br><span class="line">        //  若下一个子数组的起始位置大于等于len-sz则表示剩余的元素小于sz个，则不需要再进行合并排序了（上一个归并已经处理了）</span><br><span class="line">        for (int lo = 0; lo &lt; len - sz; lo += sz + sz) &#123;</span><br><span class="line">            // 后面的Math.min(lo + sz + sz - 1, len - 1) 是为了保证对未能组成两个归并数组的处理</span><br><span class="line">            mergeResult(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, len - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="多路归并排序merge-sort"><a class="markdownIt-Anchor" href="#多路归并排序merge-sort"></a> 多路归并排序（Merge Sort）</h3>
<p>插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要外部排序算法来解决。<br>
外部排序算法由两个阶段构成：</p>
<ol>
<li>按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为&quot;归并段&quot;或者&quot;顺段&quot;），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li>
<li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li>
</ol>
<p>对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。<br>
想要达到减少访问外存的次数（归并次数）从而提高算法效率的目的，可以从两个角度实现：</p>
<ol>
<li>增加 k-路平衡归并中的 k 值 — 多路归并算法；</li>
<li>尽量减少初始归并段的数量 m，即增加每个归并段的容量 — 置换-选择排序算法；</li>
</ol>
<h3 id="计数排序counting-sort"><a class="markdownIt-Anchor" href="#计数排序counting-sort"></a> 计数排序（Counting Sort）</h3>
<ol>
<li>
<p>概述<br>
在于将输入的数据值转化为键（数组索引）存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>
当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。<br>
额外开辟的数组空间的长度为输入数组的最大值+1，这也意味着计数排序对于数据范围很大的输入数据，它需要很大的空间来用来进行计数，所以计数排序是一种典型的空间换时间的算法。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>找出待排序数组的最大值，开辟一个额外数组，其长度为最大值+1；</li>
<li>遍历待排序数组，计算数组中每个元素的出现次数，并且将元素值作为索引，出现的次数作为值存入到额外数组中；</li>
<li>遍历额外数组，若其元素值（出现次数）大于0，则将其索引作为元素值回写到待排序数组中，并且出现次数-1，直到完成排序；</li>
</ol>
 <img src="/经典排序算法/CountSort.gif" title="countSort">
<p>如果按照上述的算法（朴素的计数排序）思路来进行排序的话，还存在着如下两个问题：</p>
<ol>
<li>
<p>额外数组在某些情况下利用率低。例如待排序数组范围 90 ~ 99，那么额外数组的长度为99+1，这造成前0~89个数组空间的浪费。<br>
要解决这个问题，可以使用（maxValue - minValue）+ 1作为额外数组的长度，以minValue作为偏移量，nums[i] - minValue来定位nums[i] 在额外数组中的位置；</p>
</li>
<li>
<p>朴素的计数排序不是稳定的排序，它只是简单遍历的额外数组，然后对于值不为0的元素输出其下标，若待排序数组有nums[i] == nums[j]（i &lt; j），排序之后，nums[i] == nums[j]（i &gt; j）。若是单纯的进行整数排序，排序之后交换了位置也没关系，但是如果面临现实业务（比如考试分数的排序）中，就行不通了。<br>
要解决这个问题，需要对额外数组进一步操作，依次将当前位置的值和前一个位置的值相加（代码描述为：countNums[i] += countNums[i - 1]），这样额外数组中存储的值代表了元素的最终排序位置。</p>
 <img src="/经典排序算法/countSort.png" title="countSort">
<p>输入待排序数组为[4,0,9,5,5]，经过计数之后得到上述图片的上半部分，进行处理后得到下半部分，那么下标为9的的值为5，则代表中元素9最终排序的位置为5。</p>
</li>
</ol>
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[maxValue + 1];</span><br><span class="line"></span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历额外数组countNums, 将其索引回写到nums数组中</span><br><span class="line">    int sortIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        while (countNums[i] &gt; 0) &#123;</span><br><span class="line">            nums[sortIndex++] = i;</span><br><span class="line">            countNums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化之后的代码如下:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 得到最小值</span><br><span class="line">    int minValue = getMinValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[(maxValue - minValue) + 1];</span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值 - 偏移量(minValue)作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value - minValue]++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // countNums[nums[i] - minValue]为 nums[i]的最终位置</span><br><span class="line">        sortArray[countNums[nums[i] - minValue] - 1] = nums[i];</span><br><span class="line">        countNums[nums[i] - minValue]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums = sortArray.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3>
<ol>
<li>
<p>概述<br>
桶排序是计数排序的升级版，降低了额外空间的大小和提高了额外空间的利用率。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定，对于桶的内部，选择何种内部排序算法也对性能有着重要的影响。为了使桶排序更加高效，需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量；</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li>
</ol>
</li>
<li>
<p>算法思路</p>
<ol>
<li>根据待排序数组中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数<br>
，设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>选择一种排序算法，对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
 <img src="/经典排序算法/bucketSort.png" title="bucketSort">
 <img src="/经典排序算法/bucketSort2.png" title="bucketSort2">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bucketSort (int[] nums) &#123;</span><br><span class="line">    bucketSort(nums, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void bucketSort(int[] nums, int bucketSize) &#123;</span><br><span class="line">    // 根据最大值和最小值计算需要的桶的个数 - 映射规则(可以选择不同的映射规则)</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125; else if (value &lt; minValue) &#123;</span><br><span class="line">            minValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到所需桶个数</span><br><span class="line">    int bucketCount = (int) (Math.floor((maxValue - minValue) / bucketSize) + 1);</span><br><span class="line">    // 创建桶</span><br><span class="line">    int[][] buckets = new int[bucketCount][0];</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到桶中</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int index = (int) Math.floor((nums[i] - minValue) / bucketSize);</span><br><span class="line">        buckets[index] = numsAppend(buckets[index], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int[] bucket : buckets) &#123;</span><br><span class="line">        if (bucket.length &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对每个桶中元素进行排序 - 采用插入排序, 可使用其他排序算法</span><br><span class="line">        bucket = insertSort(bucket);</span><br><span class="line">        // 将已经排序完的元素回写到数组中</span><br><span class="line">        for (int value : bucket) &#123;</span><br><span class="line">            nums[index++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将数据添加到桶中</span><br><span class="line">private int[] numsAppend (int[] bucketNums, int value) &#123;</span><br><span class="line">    bucketNums = Arrays.copyOf(bucketNums, bucketNums.length + 1);</span><br><span class="line">    bucketNums[bucketNums.length - 1] = value;</span><br><span class="line">    return bucketNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort）</h3>
<ol>
<li>
<p>概述<br>
基数排序是一种非比较型整数排序算法，其原理是将整数按位数（通常是低位-&gt;高位进行分割）切割成不同的数字，然后将分割之后的数字分配到不同桶中，对桶中元素进行排序，然后依次输出桶中元素，接着按照下一个位数进行分割，反复进行上述操作，直到整个数组有序。<br>
若待排序数组分割之后的位数的数值范围较小，可以不利用桶来收集分割之后的元素，可以直接采用计数排序。比如对于整数的基数排序，只需要分配固定十个桶（位数范围0~9），则直接可以基于计数排序进行。<br>
基数排序既可以从高位优先进行排序（Most Significant Digit first，简称MSD），也可以从低位优先进行排序（Least Significant Digit first，简称LSD）。</p>
</li>
<li>
<p>算法思路</p>
<ol>
<li>得到待排序数据中的最大值，并得到最大值的位数digit；</li>
<li>从低位到高位依次待排序数组进行计数排序，计数排序的次数为digit；</li>
<li>重复第二步，直到整个数组有序。</li>
</ol>
 <img src="/经典排序算法/RadixSort.gif" title="RadixSort">
</li>
<li>
<p>代码实现</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void radixSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值的长度(位数), 通过这个就知道需要进行几次基数排序</span><br><span class="line">    int maxDigit = getMaxDigit(nums);</span><br><span class="line">    sort(nums, maxDigit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sort (int[] nums, int maxDigit) &#123;</span><br><span class="line">    int exp = 1;</span><br><span class="line">    // 最大值的位数为maxDigit, 则代表要进行maxDigit次计数排序</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, exp *= 10) &#123;</span><br><span class="line">        countingSort(nums, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对基数排序的每位进行计数排序</span><br><span class="line">private static void countingSort (int[] nums, int exp) &#123;</span><br><span class="line">    // 开辟额外数组存在每个数字出现次数</span><br><span class="line">    int[] countNums = new int[10];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[(value / exp) % 10]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        sortArray[countNums[(nums[i] / exp) % 10] - 1] = nums[i];</span><br><span class="line">        countNums[(nums[i] / exp) % 10]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为需要基于nums再进行若干次计数排序, 所以将sortArray 赋值给nums</span><br><span class="line">    for (int i = 0; i &lt; sortArray.length; i++) &#123;</span><br><span class="line">        nums[i] = sortArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最大值的位数</span><br><span class="line">private static int getMaxDigit (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (maxValue &lt; value)</span><br><span class="line">        maxValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    // 得到最大值的位数</span><br><span class="line">    int length = 0;</span><br><span class="line">    while (maxValue != 0) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        maxValue = maxValue / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect</a><br>
[2] <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/onepixel/articles/7674659.html</a><br>
[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/经典排序算法.html">http://www.huangbin.fun/经典排序算法.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/对象的共享.html"><i class="fa fa-chevron-left">  </i><span>对象的共享</span></a></div><div class="next-post pull-right"><a href="/重新认识时间复杂度.html"><span>重新认识时间复杂度</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>