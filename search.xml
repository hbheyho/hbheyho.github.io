<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>J.U.C之并发容器(CopyOnWriteArrayList, ConcurrentHashMap)</title>
      <link href="/J-U-C%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-CopyOnWriteArrayList-ConcurrentHashMap.html"/>
      <url>/J-U-C%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-CopyOnWriteArrayList-ConcurrentHashMap.html</url>
      
        <content type="html"><![CDATA[<h2 id="并发容器和同步容器"><a class="markdownIt-Anchor" href="#并发容器和同步容器"></a> 并发容器和同步容器</h2><h3 id="同步容器"><a class="markdownIt-Anchor" href="#同步容器"></a> 同步容器</h3><p>同步容器常见的有Vector，HashTable等，这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步（使用synchronized关键字来修饰）使得每次只有一个线程能访问容器的状态。<br>在多线程场景下，能安全的使用同步容器所附带的方法，但是在某些情况下可能需要额外的客户端加锁来保护复合操作。常见的复合操作：迭代，跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算。<br>所以同步容器不光削弱了并发性，降低了吞吐量，在某些符合复合操作的场景下任然会有着线程安全问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object getLast (Vector list) &#123;</span><br><span class="line">    int lastIndex = list.size - 1;</span><br><span class="line">    return list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast (Vector list) &#123;</span><br><span class="line">    int lastIndex = list.size - 1;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有多个线程交替执行上述两个方法，则可能会面临着线程安全问题，如下图所示：</p><img src="/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap/线程安全.jpg" title="线程安全"><p>要解决上述问题就需要客户端加锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object getLast (Vector list) &#123;</span><br><span class="line">    synchronized(list)&#123;</span><br><span class="line">        int lastIndex = list.size - 1;</span><br><span class="line">        return list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast (Vector list) &#123;</span><br><span class="line">    synchronized(list)&#123;</span><br><span class="line">        int lastIndex = list.size - 1;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于同步容器的迭代操作也会面临线程不安全情况，如果在迭代过程中，有其他的线程删除了一个元素，并且迭代过程和删除过程交替执行，那么将会抛出ArrayIndexOutOfBoundsException异常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是可以通过客户端加锁来解决。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(vector)&#123;</span><br><span class="line">    for(int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">        doSomething(vector.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发容器"><a class="markdownIt-Anchor" href="#并发容器"></a> 并发容器</h3><p>JAVA 5.0 提供了多种并发容器类来改进同步容器的性能，通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。主要是因为同步容器将所有对容器状态的访问都串行化，实现它们的线程安全性，但是这种的代价严重降低了并发性，当多个线程竞争容器的锁时，吞吐量严重降低。<br>并发容器是针对多个线程并发访问设计的，也提供了一些在使用同步容器时需要客户端加锁的复合操作，在Java 5.0 增加了ConcurrentHashMap用来替代同步且基于散列的Map，以及CopyOnWriteArrayList用于在遍历操作为主要操作的情况下替代同步的List，Java 6 也引入了ConcurrentSkipListMap 和 ConcurrentSkipListSet，分别作为同步的SortedMap（TreeMap） 和 SortedSet（TreeSet）的并发替代品。</p><h2 id="常见并发容器"><a class="markdownIt-Anchor" href="#常见并发容器"></a> 常见并发容器</h2><h3 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> CopyOnWriteArrayList</h3><h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteArraySet。<br>copyOnWriteArrayList 用于替代同步List（除此之外，还有copyOnWriteArraySet来替代同步的Set），在某些情况下提供了更好的并发性能，在迭代期间（读取）不需要对容器进行加锁或复制。<br>“写入时复制(Copy-On-Write)” 容器的线程安全性在于，只要正确发布一个事实不可变对象，那么在访问该对象时就不需要进一步的同步。<br>在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性，修改操作都在新的容器副本上进行，那么旧的容器可以看作为一个事实不可变对象，并且在修改时使用ReentrantLock锁来保证同步。<br>在对容器进行迭代的时候，&quot;写入时复制&quot;容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的初始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>&quot;写入时复制&quot;容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素和迭代器创建时的元素完全一致，而不必考虑修改所带来的影响。、<br>CopyOnWriteAarryList并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><ol><li><p>add()方法<br>add方法向CopyOnWirteArrayList中添加元素，在添加过程中会使用一个ReentrantLock来保证添加操作的线程安全性。<br>由于每当修改容器时都会复制底层数组，需要花费一定的开销，尤其是当容器规模较大时，只有迭代操作远远大于修改操作时才会使用&quot;写入时复制&quot;容器。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 使用一个可重入锁来保证同步</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 得到旧数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        // 记录旧数组长度</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        // 创建一个新数组, 并将旧数组上的元素复制到新数组</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        // 添加元素到新数组中</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        // 新数组的引用重新只需旧数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()方法<br>get方法通过getArray方法获得旧数组，然后根据index索引来得到元素。因为在读取期间，可能有线程根据旧的数组copy了一个新的数组，在新的数组上进行添加操作，但是get方法操作的还是旧数组，那么get方法可能得到是&quot;脏&quot;数组。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    // 通过getArray方法得到旧数组</span><br><span class="line">    // 通过index索引来得到元素</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>iterator()方法<br>在对容器进行迭代的时候，&quot;写入时复制&quot;容器的迭代器保留一个指向底层基础数组（旧数组）的引用，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>&quot;写入时复制&quot;容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素和迭代器创建时的元素完全一致，而不必考虑修改所带来的影响。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 然后迭代器对象的时候, 会把当前数组传递给迭代器进行备份</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">// CopyOnWriteArrayList 迭代器</span><br><span class="line">private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="应用缺点"><a class="markdownIt-Anchor" href="#应用缺点"></a> 应用缺点</h4><ol><li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（写的时候会创建新容器来保持数据，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，，那么这个时候很有可能造成频繁的Yong GC和Full GC。</li><li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ol><h4 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h4><p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3938914.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3938914.html</a></p><h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3><h4 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h4><p>在线程不安全的HashMap以及（多线程操作下可能会形成环形链表）效率低下的HashTable（HashTable虽说是线程安全的，但是它是通过全表锁来实现的，即简单粗暴的使用synchronized关键字对put方法加锁，导致了在多线程访问下所有操作的串行话）的背景下，急需一个满足多线程安全并且高效率的Hash表并发容器。<br>ConcurrentHashMap 在HashTable的基础上进行了优化，他使用了分段锁技术来达到线程安全要求，其将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<br>并且ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p><h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h4><ol><li><p>JDK1.7 源码<br>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment继承了可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。<br>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，可以将一个Segment可以看作是一个类似于HashMap结构。当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p> <img src="/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap/ConcurrentHashMap.png" title="ConcurrentHashMap"><p>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment。<br>扩容操作只使用了HashEntry数组，Segment数组初始化之hou就不可变。</p><ol><li><p>Segment/HashEntry<br>Segment定义如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; </span><br><span class="line">// Segment中元素的数量</span><br><span class="line">transient volatile int count;</span><br><span class="line">// 对HashEntry数组的操作次数(put/remove, 修改不算)</span><br><span class="line">transient int modCount;</span><br><span class="line">// 阈值, Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</span><br><span class="line">transient int threshold; </span><br><span class="line">// HashEntry数组, 数组中的每一个元素代表了一个链表的头部</span><br><span class="line">transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">// 负载因子, 用于确定threshold</span><br><span class="line">final float loadFactor;     </span><br><span class="line">                          …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashEntry定义如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123; </span><br><span class="line">final K key; </span><br><span class="line">// 根据key的hashCode计算得到的hash值</span><br><span class="line">// 用来定位HashEntry在HashEntry数组中的位置</span><br><span class="line">final int hash;</span><br><span class="line">volatile V value;</span><br><span class="line">// next为final类型, 这代表着next指针不可修改</span><br><span class="line">// 所以put操作都将新的HashEntry节点放置在链表头部</span><br><span class="line"> final HashEntry&lt;K,V&gt; next; </span><br><span class="line">                         ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不指定则为默认参数：</span><br><span class="line">//    initialCapacity：16</span><br><span class="line">//    loadFactor：0.75</span><br><span class="line">//    concurrencyLevel：16    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; </span><br><span class="line">    // 参数检验</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException(); </span><br><span class="line">    // 当concurrencyLevel大于Segment最大数量, 进行重置</span><br><span class="line">    // MAX_SEGMENTS 为1 &lt;&lt; 16 = 65536, 也就是最大并发数为65536</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line">    int sshift = 0; </span><br><span class="line">    int ssize = 1; </span><br><span class="line">    // 根据concurrencyLevel得到合适的segment数组长度ssize</span><br><span class="line">    // 为了更好根据hash值计算索引, segment长度需要为2的n次方</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">        ++sshift; </span><br><span class="line">        ssize &lt;&lt;= 1; </span><br><span class="line">    &#125; </span><br><span class="line">    // segmentShift：段偏移量 segmentMask：段掩码, 这两个变量在定位segment时用来计算segment索引</span><br><span class="line">    this.segmentShift = 32 - sshift; </span><br><span class="line">    this.segmentMask = ssize - 1; </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">    // 计算cap的大小, 即Segment中HashEntry的数组长度, cap也一定为2的n次方</span><br><span class="line">    int c = initialCapacity / ssize; </span><br><span class="line">    if (c * ssize &lt; initialCapacity) </span><br><span class="line">        ++c; </span><br><span class="line">    int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    while (cap &lt; c) </span><br><span class="line">        cap &lt;&lt;= 1; </span><br><span class="line">    //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化</span><br><span class="line">    Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">    (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    // 创建Segment数组</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); </span><br><span class="line">    this.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以知道，Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。这种设计其实主要是便于通过按位与的散列算法来定位Segment的index，即用hash &amp; (n - 1) 代替 hash % n。<br>构造函数执行流程如下：</p><ol><li>必要参数校验；</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值；</li><li>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小；</li><li>记录 segmentShift 偏移量，这个值为 容量 = 2 的N次方 中的 N，在后面 Put 时计算位置时会用到，默认是 32 - sshift = 28；</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15；</li><li>计算HashEntry数组的长度；</li><li>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 2 * 0.75=1.5，插入第二个值时才会进行扩容。</li></ol></li><li><p>put方法</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //concurrentHashMap不允许key/value为空</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 根据key的hashCode得到hash值</span><br><span class="line">    //hash函数对key的hashCode重新散列,避免差劲的不合理的hashcode,保证散列均匀</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    / 返回的hash值无符号右移segmentShift位与段掩码进行位运算,定位segment</span><br><span class="line">    // 默认segmentShift为28, segmentMask为15</span><br><span class="line">    // 即 hash &gt;&gt;&gt; 28 &amp; 15, 即高四位相与于1111</span><br><span class="line">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">    (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) </span><br><span class="line">        // 如果查找到的 Segment 为空, 初始化</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述put方法主要是根据key值计算segment的位置，并且如果segment为空，调用ensureSegment方法进行初始化。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    // 判断 u 位置的 Segment 是否为null</span><br><span class="line">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</span><br><span class="line">        // 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br><span class="line">        int cap = proto.table.length;</span><br><span class="line">        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br><span class="line">        float lf = proto.loadFactor;</span><br><span class="line">        // 计算扩容阀值</span><br><span class="line">        int threshold = (int)(cap * lf);</span><br><span class="line">        // 创建一个 cap 容量的 HashEntry 数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // recheck</span><br><span class="line">            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br><span class="line">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            // 自旋检查 u 位置的 Segment 是否为null</span><br><span class="line">             while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">                // 使用CAS 赋值，只会成功一次</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取的segment为空，调用ensureSegment方法进行初始化。初始化流程如下：</p><ol><li>检查计算得到的位置的 Segment 是否为null；</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组；</li><li>再次检查计算得到的指定位置的 Segment 是否为null；</li><li>使用创建的 HashEntry 数组初始化这个 Segment；</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment；</li></ol> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找到了指定的segment之后, 将数据存放到其HashEntry数组对应位置</span><br><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    // 获取 ReentrantLock 独占锁，获取不到, scanAndLockForPut 获取, 该方法会不断自旋tryLock获取锁, 当自旋次数大于指定次数时lock()阻塞获取锁, 并且返回表头node节点</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        // 计算要put的数据在HashEntry的哪个位置</span><br><span class="line">        int index = (tab.length - 1) &amp; hash;</span><br><span class="line">        // CAS 获取 index 坐标的值</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        // 遍历当前位置HashEntry链表, 找到合适的插入位置</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br><span class="line">                K k;</span><br><span class="line">                // 已经存在了相同的key, 直接用新值覆盖</span><br><span class="line">                if ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 发生了地址冲突, 采用链表头插法进行插入</span><br><span class="line">                if (node != null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    // 当前HashEntry链表还是为空</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c = count + 1;</span><br><span class="line">                // 容量大于扩容阀值，小于最大容量，进行扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    // index 位置赋值 node, node 可能是一个元素, 也可能是一个链表的表头</span><br><span class="line">                setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述put方法完成真正的数据存放操作，即将数组存入到HashEntry中。具体执行流程如下：</p><ol><li>tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。scanAndLockForPut 该方法会不断自旋tryLock()获取锁，当自旋次数大于指定次数时lock()阻塞获取锁, 获取锁成功后返回返回要存放的node节点（根据传入的Key，Value构造）；</li><li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</li><li>遍历HashEntry链表以便得到合适位置来存放新元素，分为以下两种情况：<ol><li>如果这个位置上的 HashEntry 存在：<ul><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，一致则替换值；</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表遍历完毕没有相同的。</li></ul></li><li>如果这个位置上的 HashEntry 不存在：<ul><li>如果当前容量大于扩容阀值，小于最大容量，进行扩容；</li><li>直接头插法插入。</li></ul></li></ol></li></ol></li><li><p>rehash方法</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// rehash扩容只针对HashEntry的扩容, 不会对Segment机械能扩容</span><br><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">     // 老容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // 新容量, 扩大两倍</span><br><span class="line">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">    // 新的扩容阀值 </span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    // 创建新的数组</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    // 新的掩码, 默认2扩容后是4, 4 - 1 = 3, 二进制就是11</span><br><span class="line">    int sizeMask = newCapacity - 1;</span><br><span class="line">    for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        // 遍历老数组</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 计算新的位置,新的位置只可能是不变或者是老的位置+老的容量</span><br><span class="line">            int idx = e.hash &amp; sizeMask;</span><br><span class="line">            if (next == null)</span><br><span class="line">                // 如果当前位置还不是链表,只是一个元素，直接赋值</span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            else &#123; </span><br><span class="line">                // 如果是链表了</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                int lastIdx = idx;</span><br><span class="line">                // 新的位置只可能是不变或者是老的位置+老的容量</span><br><span class="line">                // 遍历结束后，lastRun 后面的元素位置都是相同的</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123;</span><br><span class="line">                    int k = last.hash &amp; sizeMask;</span><br><span class="line">                                              </span><br><span class="line">                    if (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // lastRun 后面的元素位置都是相同的, 直接作为链表赋值到新位置</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                // 遍历剩余元素，头插法到指定 k 位置</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    int h = p.hash;</span><br><span class="line">                    int k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    // 头插法插入新的节点</span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask;</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。<br>源码种的第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的，然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。</p></li><li><p>get方法</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; </span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h = hash(key);</span><br><span class="line">    // 得到segment索引</span><br><span class="line">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">    (tab = s.table) != null) &#123;</span><br><span class="line">        // 得到在HashEntry数组中的索引</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">        e != null; e = e.next) &#123;</span><br><span class="line">            // 如果是链表, 遍历查找到相同 key 的 value</span><br><span class="line">            K k;</span><br><span class="line">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法的具体流程如下：</p><ol><li>计算得到 key 的存放位置；</li><li>遍历指定位置查找相同 key 的 value 值。<br>get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。</li></ol></li></ol></li><li><p>JDK1.8 源码<br>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<br>源码分析！挖坑~ 现在太累了/(ㄒoㄒ)/~~ 都晚上12点了都！</p></li></ol><h2 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h2><p>[1] <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap源码+底层数据结构分析.md</a><br>[2] <a href="https://www.cnblogs.com/chengxiao/p/6842045.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chengxiao/p/6842045.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转] Fork/Join框架</title>
      <link href="/%E8%BD%AC-Fork-Join%E6%A1%86%E6%9E%B6.html"/>
      <url>/%E8%BD%AC-Fork-Join%E6%A1%86%E6%9E%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>Fork/Join 框架是 Java 7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>通过 Fork 和 Join 这两个单词来理解下 Fork/Join 框架，Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。<br>比如计算 1+2+…＋10000，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。<br>运行流程图如下：</p><img src="/转-Fork-Join框架/流程图.png" title="流程图"><p>通过上面的流程图可以知道，Fork/Join框架主要实现了两个功能，即任务分割、任务执行与结果合并：</p><ol><li>分割任务。首先我们需要有一个 fork 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。<br>Fork/Join使用ForkJoinTask类来完成分割任务操作，所以当要使用ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork() 和 join() 操作的机制，通常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，Fork/Join 框架提供了以下两个子类：<ol><li>RecursiveAction：用于没有返回结果的任务；</li><li>RecursiveTask ：用于有返回结果的任务。</li></ol></li><li>执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。<br>ForkJoinTask 需要通过 ForkJoinPool 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务（下面讲到的工作窃取算法）。<br>使用Fork/Join框架也要按照上面的框架来进行使用。</li></ol><h2 id="工作窃取算法"><a class="markdownIt-Anchor" href="#工作窃取算法"></a> 工作窃取算法</h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><img src="/转-Fork-Join框架/qiequ.png" title="qiequ"><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如 A 线程负责处理 A 队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h2><p>源码分析参考：<br>[1] <a href="https://www.infoq.cn/article/fork-join-introduction" rel="external nofollow noopener noreferrer" target="_blank">https://www.infoq.cn/article/fork-join-introduction</a><br>[2] <a href="https://www.cnblogs.com/jinggod/p/8490573.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/jinggod/p/8490573.html</a></p><h2 id="应用实例"><a class="markdownIt-Anchor" href="#应用实例"></a> 应用实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final int threshold = 2;</span><br><span class="line">    private Integer start;</span><br><span class="line">    private Integer end;</span><br><span class="line"></span><br><span class="line">    ForkJoinExample(Integer start, Integer end) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">         // 如果任务足够小就直接计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        if (canCompute) &#123;</span><br><span class="line">            for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对任务进行拆分</span><br><span class="line">        else &#123;</span><br><span class="line">            int middle = (start + end) / 2;</span><br><span class="line">            // 拆分子任务</span><br><span class="line">            ForkJoinExample leftTask = new ForkJoinExample(start, middle);</span><br><span class="line">            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, end);</span><br><span class="line"></span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            // 等待两个任务执行并合并结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        // 新建一个ForkJoin任务, 计算 1...100</span><br><span class="line">        ForkJoinExample forkJoinExample = new ForkJoinExample(1, 100);</span><br><span class="line"></span><br><span class="line">        // 执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(forkJoinExample);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Result:&quot; + result.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinTask 与一般的任务的主要区别在于它需要实现 compute 方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用 fork 方法时，又会进入 compute 方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用 join 方法会等待子任务执行完并得到其结果。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.infoq.cn/article/fork-join-introduction" rel="external nofollow noopener noreferrer" target="_blank">https://www.infoq.cn/article/fork-join-introduction</a><br>[2] <a href="https://www.cnblogs.com/jinggod/p/8490573.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/jinggod/p/8490573.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转] J.U.C之线程池</title>
      <link href="/J-U-C%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E8%BD%AC.html"/>
      <url>/J-U-C%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E8%BD%AC.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>线程池化主要因为普通方式创建线程的弊端以及线程池的优势：</p><h3 id="普通方式创建线程弊端"><a class="markdownIt-Anchor" href="#普通方式创建线程弊端"></a> 普通方式创建线程弊端</h3><ol><li>每次new Thread新建对象，性能差；</li><li>线程缺乏统一的管理，可能无限制创建线程，相互竞争，有可能占用过多的系统资源导致OOM；</li><li>缺乏更多的功能，例如定期执行，线程中断。</li></ol><h3 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势"></a> 线程池的优势</h3><ol><li>资源可控性：使用线程池可以避免创建大量线程而导致内存的消耗，还可以有效控制最大并发线程数，提高系统利用率；</li><li>提高响应速度：线程池的创建实际上是很消耗时间和性能的，但是线程池创建好之后有任务就运行，提升响应速度；</li><li>便于管理：池化技术最突出的一个特点就是可以帮助我们对线程池里的资源进行管理，由线程池统一分配和管理；</li><li>功能丰富：提供了定时执行，定期执行，单线程和并发数控制等功能。</li></ol><h2 id="线程池概述"><a class="markdownIt-Anchor" href="#线程池概述"></a> 线程池概述</h2><h3 id="线程池创建参数"><a class="markdownIt-Anchor" href="#线程池创建参数"></a> 线程池创建参数</h3><p>Executors的工厂方法就给我们提供了创建多种不同线程池的方法。因为这个类只是一个创建对象的工厂，并没有涉及到很多的具体实现，具体的实现由 ThreadPoolExecutor实现。<br>就拿newFixedThreadPool来说明线程池创建所需要的参数。newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li>corePoolSize（核心线程池大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，当任务数大于核心线程数的时候就不会再创建。在这里要注意一点，线程池刚创建的时候，其中并没有创建任何线程，而是等任务来才去创建线程，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法 ，这样才会预先创建好corePoolSize个线程或者一个线程；</li><li>maximumPoolSize（线程池最大线程数）：线程池允许创建的最大线程数，如果阻塞队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界队列，此参数就没有意义了。</li><li>poolSize（线程池中已有线程数量），corePoolSize，maximumPoolSize三者关系<ul><li>poolSize &lt; corePoolSize，新增一个线程处理任务；</li><li>poolSize = corePoolSize，将任务放到阻塞队列中等待执行；</li><li>阻塞队列已满，且poolSize &lt; maximumPoolSize，新增一个线程处理任务；</li><li>阻塞队列已满，且poolSize = maximumPoolSize，线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务。</li></ul></li><li>handler（饱和策略）：当线程池和队列都满了，说明线程池已经处于饱和状态了，那么必须采取一种策略来处理还在提交过来的新任务。这个饱和策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。共有四种饱和策略提供，我们也可以选择自己实现饱和策略。<ul><li>AbortPolicy：直接丢弃并且抛出RejectedExecutionException异常；</li><li>CallerRunsPolicy：调用当前线程池的所在的线程去执行被拒绝的任务；</li><li>DiscardOldestPolicy：当任务被拒绝时，会抛弃任务队列中最旧的任务，也就是最先加入队列的，再把这个新任务添加进去；</li><li>DiscardPolicy：被线程池拒绝的任务直接丢弃，并且不抛出异常。<br>参考链接：<a href="https://www.jianshu.com/p/9fec2424de54" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/9fec2424de54</a></li></ul></li><li>keepAliveTime（线程活动保持时间）：此参数默认在线程数大于corePoolSize的情况下才会起作用， 当线程的空闲时间达到keepAliveTime的时候就会终止，直至线程数目小于corePoolSize。不过如果调用了allowCoreThreadTimeOut方法，则当线程数目小于corePoolSize的时候也会起作用。</li><li>unit(keelAliveTime的时间单位)：keelAliveTime的时间单位，一共有7种。</li><li>workQueue（阻塞队列）：阻塞队列，用来存储等待执行的任务，主要以下几个阻塞队列。<ul><li>ArrayBlockingQueue：这是一个基于数组结构的有界阻塞队列，此队列按照FIFO的原则对元素进行排序；</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按照FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()就是使用了这个队列；</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()就使用了这个队列；</li><li>PriorityBlockingQueue：一个具有优先级的阻塞队列。</li></ul></li></ol><h3 id="线程池执行流程"><a class="markdownIt-Anchor" href="#线程池执行流程"></a> 线程池执行流程</h3><p>线程池的执行大致执行流程如下：</p><img src="/J-U-C之线程池-转/线程池执行流程.jpg" title="线程池执行流程"><h2 id="线程池源码分析"><a class="markdownIt-Anchor" href="#线程池源码分析"></a> 线程池源码分析</h2><p>线程池的关键方法实现都是ThreadPoolExecutor来完成的，所以具体的源码分析集中对ThreadPoolExecutor类的分析。</p><h2 id="主要变量"><a class="markdownIt-Anchor" href="#主要变量"></a> 主要变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ctl使用32位来表示一组复合变量：</span><br><span class="line">// 前3位：线程池的运行状态</span><br><span class="line">// 后29位：线程池中有效的线程个数</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">// 表示线程池数量的位数,Iteger.SIZE - 3 = 29</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">//线程池最大数量，2^29 - 1</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">/// 线程池状态由ctl的高三位进行存储, 共有5中状态</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// 计算线程池状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// 计算线程池线程数量</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// 根据线程池状态和线程个数计算ctl</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">//用于存放线程任务的阻塞队列</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">//重入锁 - 保证向线程池中添加线程是线程同步的</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 线程池当中的线程集合,只有当拥有mainLock锁的时候，才可以进行访问</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">// 支持对线程进行条件性的阻塞和唤醒</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">//创建新线程的线程工厂</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">// 饱和拒绝策略</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure><p>上面的很多计算都涉及位运算，下面对一些运算进行说明：</p><ol><li><p>CAPACITY计算</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// 1 &lt;&lt; COUNT_BITS</span><br><span class="line"></span><br><span class="line">// 1的32位2进制是</span><br><span class="line">// 00000000 00000000 00000000 00000001</span><br><span class="line"></span><br><span class="line">// 左移29位的话就是</span><br><span class="line">// 00100000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">// 再进行减一的操作</span><br><span class="line">// 000 11111 11111111 11111111 11111111</span><br><span class="line"></span><br><span class="line">// 也就是说线程池最大数目就是</span><br><span class="line">// 000 11111 11111111 11111111 11111111</span><br></pre></td></tr></table></figure></li><li><p>RunState计算<br>在计算机底层使用补码来进行表示符号数。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以接受新任务并且处理已经在阻塞队列的任务 - 高三位全是1</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 不接受新任务，但是处理已经在阻塞队列的任务 - 高三位全是0</span><br><span class="line">private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 不接受新任务，也不处理阻塞队列里的任务，并且会中断正在处理的任务 - 高三位001</span><br><span class="line">private static final int STOP = 1 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 所有任务都被中止，workerCount为0，线程状态转化为TIDYING并且调用terminated()钩子方法 - 高3位是010</span><br><span class="line">private static final int TIDYING    = 2 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 线程已经终止, terminated()钩子方法已经完成 - 高三位011</span><br><span class="line">private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// 以RUNNING为例进行计算</span><br><span class="line">// -1 &lt;&lt; COUNT_BITS</span><br><span class="line">     ​</span><br><span class="line">// -1的原码</span><br><span class="line">                  ​</span><br><span class="line">// -1的反码,负数的反码是将原码除符号位以外全部取反</span><br><span class="line">// 11111111 11111111 11111111 11111110</span><br><span class="line">                  ​</span><br><span class="line">// -1的补码,负数的补码就是将反码+1</span><br><span class="line">// 11111111 11111111 11111111 11111111</span><br><span class="line">                 ​</span><br><span class="line">// 往左移29位,所以高3位全是1就是RUNNING状态</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure></li><li><p>runStateOf方法<br>获取当前线程池的运行状态。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// c &amp; ~CAPACITY</span><br><span class="line">// ~是按位取反的意思</span><br><span class="line">//&amp;是按位与的意思</span><br><span class="line">                    ​</span><br><span class="line">// 而CAPACITY是，高位3个0，低29位都是1，所以是</span><br><span class="line">000 11111 11111111 11111111 11111111</span><br><span class="line">                   ​</span><br><span class="line">// 取反的话就是</span><br><span class="line">111 00000 00000000 00000000 00000000</span><br><span class="line">                  ​</span><br><span class="line">// 传进来的c参数与取反的CAPACITY进行按位与操作</span><br><span class="line">// 1、低位29个0进行按位与，还是29个0</span><br><span class="line">// 2、高位3个1，既保持c参数的高3位</span><br><span class="line">// 既高位保持原样，低29位都是0，这也就获得了线程池的运行状态runState</span><br></pre></td></tr></table></figure></li><li><p>workerCountOf方法<br>获取线程池的当前有效线程数目。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// CAPACITY的32位2进制是</span><br><span class="line">000 11111 11111111 11111111 11111111</span><br><span class="line">                   ​</span><br><span class="line">// 用入参c跟CAPACITY进行按位与操作</span><br><span class="line">// 1、低29位都是1，所以保留c的低29位，也就是有效线程数</span><br><span class="line">// 2、高3位都是0，所以c的高3位也是0</span><br><span class="line">// 这样获取出来的便是workerCount的值</span><br></pre></td></tr></table></figure></li><li><p>ctlOf方法<br>初始化ctl变量。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">                 ​</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">// RUNNING是</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br><span class="line">                    ​</span><br><span class="line">// ctlOf是将rs和wc进行按位或的操作</span><br><span class="line">                  ​</span><br><span class="line">// 初始化的时候是将RUNNING和0进行按位或</span><br><span class="line">// 0的32位2进制是</span><br><span class="line">// 00000000 00000000 00000000 00000000</span><br><span class="line">                   ​</span><br><span class="line">// 所以初始化的ctl是</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure></li></ol><h3 id="execute方法"><a class="markdownIt-Anchor" href="#execute方法"></a> execute方法</h3><p>execute方法提交了一个任务给线程池进行执行，可能是根据任务创建一个worker对象执行，或者将任务加入到阻塞队列中等待执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    //需要执行的任务command为空,抛出空指针异常</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    // 执行的流程实际上分为三步</span><br><span class="line">    // 1. 如果运行的线程小于corePoolSize，以用户给定的Runable对象新开一个线程去执行</span><br><span class="line">    // 并且执行addWorker方法会以原子性操作去检查runState和workerCount，以防止出现线程安全性问题</span><br><span class="line">    // 2. 如果任务能够成功添加到队列当中，我们仍需要对添加的线程进行双重检查，有可能添加的线程在 前一次检查时已经死亡，又或者在进入该方法的时候线程池关闭了</span><br><span class="line">    // 所以我们需要复查状态，并有必要的话需要在停止时回滚入列操作，或者在没有线程的时候新开一个线程</span><br><span class="line">    //3.  如果任务无法入列，那我们需要尝试新增一个线程，如果新建线程失败了，我们就知道线程可能关闭了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //获取线程池的运行状态</span><br><span class="line">    int c = ctl.get(); </span><br><span class="line"></span><br><span class="line">    //通过workCountOf方法算workerCount值, 若小于corePoolSize,</span><br><span class="line">    // 则新建一个线程来执行当前任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        //添加任务到worker集合当中</span><br><span class="line">        if (addWorker(command, true)) </span><br><span class="line">            //成功返回</span><br><span class="line">            return;</span><br><span class="line">        //失败的话再次获取线程池的运行状态</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 判断线程池是否正处于RUNNING状态, 是的话添加Runnable对象到workQueue队列当中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">         //再次获取线程池的状态</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        //再次检查状态</span><br><span class="line">        //线程池不处于RUNNING状态, 将任务从workQueue队列中移除, 进行回滚</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            //拒绝任务</span><br><span class="line">            reject(command);</span><br><span class="line">            //workerCount等于0, 创建线程来执行阻塞队列中的任务</span><br><span class="line">        else if (workerCountOf(recheck) == 0)  </span><br><span class="line">            //添加worker</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    //加入阻塞队列失败, 则尝试以线程池最大线程数新开线程去执行该任务</span><br><span class="line">    else if (!addWorker(command, false)</span><br><span class="line">        //拒绝任务</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行流程如下：</p><ol><li>首先判断任务是否为空，空则抛出空指针异常；</li><li>不为空则获取线程池控制状态，判断是否小于corePoolSize，若小于，则添加到worker集合当中执行，如成功，则返回，如果失败的话再接着获取线程池控制状态，因为只有状态变了才会失败（失败的原因可能是WorkerCount改变，使得其大于corePoolSize），所以重新获取线程池状态；</li><li>判断线程池是否处于运行状态，是的话则添加任务到阻塞队列，加入时也会再次获取状态并且检测状态是否处于运行状态，不处于的话则将任务从阻塞队列移除，并且拒绝任务；</li><li>如果线程池里没有了线程，则创建新的线程去阻塞队列中获取任务执行；</li><li>如果以上都没执行成功，则需要开启最大线程池里的线程来执行任务，失败的话就丢弃。</li></ol><img src="/J-U-C之线程池-转/线程池执行流程2.jpg" title="线程池执行流程2"><h3 id="worker内部类"><a class="markdownIt-Anchor" href="#worker内部类"></a> Worker内部类</h3><p>Worker内部类是对执行任务线程和执行任务的封装。它继承AQS同步器并且实现了Runnable接口，所以Worker很明显就是一个可执行任务并且又可以控制中断和锁效果的类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer</span><br><span class="line">implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">       </span><br><span class="line">    private static final long serialVersionUID = 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    // 工作线程</span><br><span class="line">    final Thread thread;</span><br><span class="line">    // 初始化任务，可能为空</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    // 已完成任务数量</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 创建并初始化第一个任务, 使用线程工厂来创建线程</span><br><span class="line">    // 初始化有3步</span><br><span class="line">    // 1. 设置AQS的同步状态为-1, 表示该对象需要被唤醒</span><br><span class="line">    // 2. 初始化第一个任务</span><br><span class="line">    // 3.调用ThreadFactory来使自身创建一个线程, 并赋值给worker的成员变量thread</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-1); </span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">        this.thread = getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">    // 重写Runnable的run方法</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //调用ThreadPoolExecutor的runWorker方法来执行任务</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //代表是否独占锁，0-非独占  1-独占</span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写AQS的tryAcquire方法尝试获取锁</span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        //尝试将AQS的同步状态从0改为1</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            //如果改变成，则将当前独占模式的线程设置为当前线程并返回true</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写AQS的tryRelease尝试释放锁</span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        //设置当前独占模式的线程为null</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        //设置AQS同步状态为0</span><br><span class="line">        setState(0);</span><br><span class="line">        //返回true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取锁</span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    //尝试获取锁</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    //释放锁</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    //是否被独占</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addworker方法"><a class="markdownIt-Anchor" href="#addworker方法"></a> addWorker方法</h3><p>addWorker方法主要用来生成worker对象，该对象包括了要执行了任务和执行任务的线程，并向workers集合中添加worker对象，并且启动线程，开始任务的执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    //外部循环标记</span><br><span class="line">    retry:</span><br><span class="line">    // 最外层自旋</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //获取线程运行状态</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 1. 如果线程池runState至少已经是SHUTDOWN</span><br><span class="line">        // 2. 有一个是false则addWorker失败</span><br><span class="line">        // - runState == SHUTDOWN, 即状态已经大于SHUTDOWN了</span><br><span class="line">        // - firstTask == null, 即传进来的任务为空, 结合上面就是runState是SHUTDOWN, 但是</span><br><span class="line">        // firstTask不为空, 代表线程池已经关闭了还在传任务进来</span><br><span class="line">        // - 队列为空, 既然任务已经为空, 队列为空, 就不需要往线程池添加任务了</span><br><span class="line"></span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;  </span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;  </span><br><span class="line">        firstTask == null &amp;&amp;  </span><br><span class="line">        ! workQueue.isEmpty()))  </span><br><span class="line">            return false;</span><br><span class="line">        ​</span><br><span class="line">        //内层自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取线程池的workerCount数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            //如果workerCount超出最大值或者大于corePoolSize/maximumPoolSize</span><br><span class="line">            //返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">            wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            //通过CAS操作，使workerCount数量+1，成功则跳出循环，回到retry标记</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line"></span><br><span class="line">            //CAS操作失败，再次获取线程池的控制状态</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            //如果当前runState不等于刚开始获取的runState，则跳出内层循环，继续外层循环</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            //CAS由于更改workerCount而失败，继续内层循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    //通过以上循环，能执行到这是workerCount成功+1了</span><br><span class="line">    //worker开始标记</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    //worker添加标记</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    //初始化worker为null</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //初始化一个当前Runnable对象的worker对象</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        //获取该worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        //如果线程不为null</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            //初始线程池的锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            //获取锁，保证添加worker的同步线程安全</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取锁后再次检查，获取线程池runState</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                ​</span><br><span class="line">                //当runState小于SHUTDOWN或者runState等于SHUTDOWN并且firstTask为null</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line"></span><br><span class="line">                    //线程已存活</span><br><span class="line">                    if (t.isAlive()) </span><br><span class="line">                        //线程未启动就存活，抛出IllegalThreadStateException异常</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                    //将worker对象添加到workers集合当中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    //获取workers集合的大小</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //如果大小超过largestPoolSize</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        //重新设置largestPoolSize</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    //标记worker已经被添加</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            //如果worker添加成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                //启动线程，开始执行任务</span><br><span class="line">                t.start();</span><br><span class="line">                //标记worker已经启动</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    //如果worker没有启动成功</span><br><span class="line">    if (! workerStarted)</span><br><span class="line">        //workerCount-1的操作</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回worker是否启动的标记</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行流程如下：</p><ol><li>获取线程池的控制状态，进行判断，不符合则返回false，符合则下一步；</li><li>进行一个内层的自旋操作，判断workerCount是否大于上限，或者大于corePoolSize/maximumPoolSize，若不符合要求则返回false，否则对workerCount+1操作；</li><li>若workerCount + 1操作失败，再次获取线程池的控制状态，获取runState与刚开始获取的runState相比，不一致则跳出内层循环继续外层循环，否则继续内层循环；</li><li>workerCount + 1操作成功后，使用重入锁ReentrantLock来保证往workers当中添加worker实例的线程安全性，添加成功就启动该实例。</li></ol><img src="/J-U-C之线程池-转/线程池执行流程3.jpg" title="线程池执行流程"><h3 id="addworkerfailed方法"><a class="markdownIt-Anchor" href="#addworkerfailed方法"></a> addWorkerFailed方法</h3><p>addWorker方法添加worker失败，并且没有成功启动任务的时候，就会调用此方法，将任务从workers中移除，并且workerCount - 1操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    //重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //如果worker不为null</span><br><span class="line">        if (w != null)</span><br><span class="line">            //workers移除worker</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        //通过CAS操作，workerCount-1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        // 执行tryTerminate尝试终止线程池</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="tryterminate方法"><a class="markdownIt-Anchor" href="#tryterminate方法"></a> tryTerminate方法</h3><p>当对线程池执行了非正常成功逻辑的操作时，都会需要执行tryTerminate尝试终止线程池。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finavoid tryTerminate() &#123;</span><br><span class="line">     //自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line"></span><br><span class="line">        // 线程池处于RUNNING状态</span><br><span class="line">        // 线程池状态最小大于TIDYING, 已经终止</span><br><span class="line">        // 线程池==SHUTDOWN并且workQUeue不为空</span><br><span class="line">        // 直接return, 不能终止</span><br><span class="line">         </span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">        runStateAtLeast(c, TIDYING) ||</span><br><span class="line">        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        //如果workerCount不为0,且runState为STOP, 中断正在处理的任务</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; </span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取线程池的锁, 开始终止线程池</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        //获取锁</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过CAS操作，设置线程池状态为TIDYING</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //设置线程池的状态为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    //发送释放信号给在termination条件上等待的线程</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runworker方法"><a class="markdownIt-Anchor" href="#runworker方法"></a> runWorker方法</h3><p>runWorker由worker对象的run方法调用，达到真正执行任务的作用。执行的任务可能来自worker对象本身，或者来自阻塞队列。该方法使用一个while循环不断从阻塞队列中获取任务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    //获取当前线程</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    //获取worker里的任务</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    //将worker实例的任务赋值为null</span><br><span class="line">    w.firstTask = null;</span><br><span class="line"></span><br><span class="line">    // unlock方法会调用AQS的release方法</span><br><span class="line">    // release方法会调用具体实现类也就是Worker的tryRelease方法</span><br><span class="line">    // 也就是将AQS状态置为0, 允许中断</span><br><span class="line">    w.unlock(); </span><br><span class="line">    //是否突然完成</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // worker实例的task不为空, 或者通过getTask获取的不为空</span><br><span class="line">        // getTask方法会从阻塞队列获取任务进行执行</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            //获取锁</span><br><span class="line">            w.lock();</span><br><span class="line">                       </span><br><span class="line">            // 满足下面两个条件将中断该线程</span><br><span class="line">            // 1. 获取线程池的控制状态，至少要大于STOP状态</span><br><span class="line">            // 2. 检查当前线程是否中断并清除中断状态，并且再次检查线程池状态是否大于STOP</span><br><span class="line">            // 如果上述满足，检查该对象是否处于中断状态，不清除中断标记</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">            (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">            !wt.isInterrupted())</span><br><span class="line">                //中断该线程</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                //执行任务之前调用的方法, 由子类具体实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //执行任务</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //执行任务之后调用的方法, 也是由子类具体实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ////执行完后, 设置task为null</span><br><span class="line">                task = null;</span><br><span class="line">                //已完成任务数+1</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                //释放锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //处理并退出当前worker</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行流程如下：</p><ol><li>首先执行了w.unlock()，这是为了将AQS的状态改为0，因为只有getState() &gt;= 0的时候，线程才可以被中断；</li><li>判断firstTask是否为空，为空则通过getTask()取阻塞对象中获取任务，不为空接着往下执行；</li><li>判断是否符合中断状态，符合的话设置中断标记；</li><li>执行beforeExecute()，task.run()，afterExecute()方法；</li><li>任何一个出异常都会导致任务执行的终止，进入processWorkerExit来退出任务；</li><li>正常执行的话会接着回到步骤2，继续向下执行任务。</li></ol><img src="/J-U-C之线程池-转/线程池执行流程4.jpg" title="线程池执行流程4"><h3 id="gettask方法"><a class="markdownIt-Anchor" href="#gettask方法"></a> getTask方法</h3><p>当firstTask为空的时候，会通过该方法去阻塞队列来接着获取任务去执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    //标志是否获取任务超时</span><br><span class="line">    boolean timedOut = false; </span><br><span class="line">    //自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池的控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //获取线程池的runState</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 判断线程池的状态，出现以下两种情况</span><br><span class="line">        // 1. runState大于等于SHUTDOWN状态</span><br><span class="line">        // 2. runState大于等于STOP或者阻塞队列为空</span><br><span class="line">        // 将会通过CAS操作，进行workerCount - 1并返回null</span><br><span class="line"></span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取线程池的workerCount</span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // allowCoreThreadTimeOut：是否允许core Thread超时, 默认false</span><br><span class="line">        // workerCount是否大于核心核心线程池, 除了core thread外, 其他线程会有超时操作</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        // 1. wc大于maximumPoolSize或者已超时</span><br><span class="line">        // 2. 队列不为空时保证至少有一个任务</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">        &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">             </span><br><span class="line">            // 通过CAS操作，workerCount - 1</span><br><span class="line">            //能进行-1操作，证明wc大于maximumPoolSize或者已经超时</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                //workCount - 1操作成功，返回null</span><br><span class="line">                return null;</span><br><span class="line">            // workCount - 1操作失败，继续循环</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            // 是否允许超时将会调用不同的方法来获取任务</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">            workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            //判断任务不为空返回任务</span><br><span class="line">            if (r != null)</span><br><span class="line">            return r;</span><br><span class="line">            //获取一段时间没有获取到，获取超时</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行流程如下：</p><ol><li>获取线程池控制状态和runState，判断线程池是否已经关闭或者正在关闭，是的话则workerCount - 1操作并返回null；</li><li>获取workerCount判断是否大于核心线程池，并且根据allowCoreThreadTimeOut和 wc &gt; corePoolSize判断是否允许超时操作；</li><li>判断workerCount是否大于最大线程池数目或者已经超时，是的话进行workerCount - 1操作，操作成功则返回null，不成功则回到步骤1重新继续；</li><li>根据timed采用何种方法来获取任务，timed 位true 则用poll方法从队列获取任务，否则用take方法从队列获取任务；</li><li>判断任务是否为空，不为空则返回获取的任务，否则回到步骤1重新继续。</li></ol><img src="/J-U-C之线程池-转/线程池执行流程5.jpg" title="线程池执行流程5"><h3 id="processworkerexit方法"><a class="markdownIt-Anchor" href="#processworkerexit方法"></a> processWorkerExit方法</h3><p>任务执行完成或出现异常中断执行的时候，调用processWorkerExit方法进行相对应的操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // completedAbruptly:在runWorker出现, 代表是否突然完成的意思</span><br><span class="line">    // 也就是在执行任务过程当中出现异常，就会突然完成，设置为true</span><br><span class="line">      </span><br><span class="line">    // 如果是突然完成，需要通过CAS操作, workerCount - 1</span><br><span class="line">    // 不是突然完成，则不需要 - 1, 因为getTask方法当中已经-1</span><br><span class="line">    if (completedAbruptly) </span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    //生成重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //线程池统计的完成任务数completedTaskCount加上worker当中完成的任务数</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        //从HashSet&lt;Worker&gt;中移除</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //因为上述操作是释放任务或线程, 所以会判断线程池状态,尝试终止线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    //获取线程池的控制状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line"></span><br><span class="line">    //判断runState是否小于STOP，即是RUNNING或者SHUTDOWN</span><br><span class="line">    //如果是RUNNING或者SHUTDOWN, 代表没有成功终止线程池</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            </span><br><span class="line">        // 是否突然完成</span><br><span class="line">        // 如若不是, 代表已经没有任务可获取完成, 因为getTask当中是while循环</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line"></span><br><span class="line">            // allowCoreThreadTimeOut: 是否允许core thread超时，默认false</span><br><span class="line">            // min-默认是corePoolSize</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line"></span><br><span class="line">            //允许core thread超时并且队列不为空</span><br><span class="line">            //min为0, 即允许core thread超时, 这样就不需要维护核心核心线程池了</span><br><span class="line">            //如果workQueue不为空，则至少保持一个线程存活</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">             </span><br><span class="line">            //如果workerCount大于min, 则表示满足所需, 可以直接返回</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; </span><br><span class="line">        &#125;</span><br><span class="line">        //如果是突然完成，添加一个空任务的worker线程</span><br><span class="line">        addWorker(null, false); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行流程如下：</p><ol><li>首先判断线程是否突然终止，如果是突然终止，则workerCount - 1；</li><li>统计线程池完成任务数，并将worker从workers当中移除；</li><li>判断线程池状态，尝试终止线程池；</li><li>线程池没有成功终止，判断是否突然完成任务，不是则进行下一步<ul><li>如允许核心线程超时，队列不为空，则至少保证一个线程存活；</li><li>添加一个空任务的worker线程。</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/KingJack/p/9595621.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/KingJack/p/9595621.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C 之阻塞队列</title>
      <link href="/J-U-C-%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html"/>
      <url>/J-U-C-%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>在编程中接触的队列更多的为非阻塞队列，例如PriorityQueue，LinkedList。这些队列不会对当前线程进行阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略（例如使用Object::wait，Object::notify来实现线程阻塞）。阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p><h2 id="常用阻塞队列"><a class="markdownIt-Anchor" href="#常用阻塞队列"></a> 常用阻塞队列</h2><ol><li>ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列；</li><li>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE；</li><li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列；</li><li>DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li></ol><h2 id="阻塞队列方法"><a class="markdownIt-Anchor" href="#阻塞队列方法"></a> 阻塞队列方法</h2><h3 id="非阻塞队列方法"><a class="markdownIt-Anchor" href="#非阻塞队列方法"></a> 非阻塞队列方法</h3><ol><li>add(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</li><li>remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</li><li>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</li><li>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</li><li>peek()：获取队首元素，若成功，则返回队首元素；否则返回null。</li></ol><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。<br>上述5个方法都没有采用同步策略。</p><h3 id="阻塞队列方法-2"><a class="markdownIt-Anchor" href="#阻塞队列方法-2"></a> 阻塞队列方法</h3><p>阻塞队列中也提供了add(E e)，remove()，offer(E e)，poll()，peek()方法，不同的是，阻塞队列对上述方法都采用了同步策略。</p><ol><li>put(E e)：put方法用来向队尾存入元素，如果队列满，则等待；</li><li>take()：take方法用来从队首取元素，如果队列为空，则等待；</li><li>offer(E e,long timeout, TimeUnit unit)：offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</li><li>poll(long timeout, TimeUnit unit)：poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素。</li></ol><h2 id="阻塞队列源码分析"><a class="markdownIt-Anchor" href="#阻塞队列源码分析"></a> 阻塞队列源码分析</h2><p>以ArrayBlockingQueue为例分析具体实现原理，基于JDK 8。</p><h3 id="主要变量"><a class="markdownIt-Anchor" href="#主要变量"></a> 主要变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现了BlockingQueue接口, 继承了AbstractQueue类</span><br><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    private static final long serialVersionUID = -817911632652898426L;</span><br><span class="line"></span><br><span class="line">    // 使用一个数组来存储队列中的元素</span><br><span class="line">    private final E[] items;</span><br><span class="line">    // 队列头指针, take, poll, remove方法使用</span><br><span class="line">    private int takeIndex;</span><br><span class="line">    // 队列尾指针, put, offer, add方法使用</span><br><span class="line">    private int putIndex;</span><br><span class="line">    // 队列中元素个数</span><br><span class="line">    private int count;</span><br><span class="line">     </span><br><span class="line">    // 可重入锁来控制所有的访问</span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    // 等待获取元素的条件变量</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    // 等待放置元素的条件变量</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// capacity参数指定容量</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量以及公平性</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量, 公平性以及初始化集合</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                                                  Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a class="markdownIt-Anchor" href="#put方法"></a> put方法</h3><p>put方法用来向队尾存入元素，如果队列满，则等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    // 判断传入元素是否为空</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    // 获得可一个重入锁, 保证线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">    // 若阻塞队列已满, 则将线程加入到同步队列中</span><br><span class="line">    while (count == items.length)</span><br><span class="line">        // 阻塞当前线程,将其加入到同步队列</span><br><span class="line">        notFull.await();</span><br><span class="line">        // 进行入队操作</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enqueue方法"><a class="markdownIt-Anchor" href="#enqueue方法"></a> enqueue方法</h3><p>enqueue方法完成具体的入队操作，并且唤醒等待获取元素的线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    // 元素入队</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 入队之后队列已满</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    // 队列元素 + 1</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒等待获取元素的线程</span><br><span class="line">    // 从等待队列中移除, 移到AQS同步队列中, 等待获取锁</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take方法"><a class="markdownIt-Anchor" href="#take方法"></a> take方法</h3><p>take方法用来从队首取元素，如果队列为空，则等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    // 获取可重入锁, 支持中断</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 若阻塞队列为空, 则将线程加入到同步队列中</span><br><span class="line">        // 等待获取资源</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        // 进行出队操作</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dequeue方法"><a class="markdownIt-Anchor" href="#dequeue方法"></a> dequeue方法</h3><p>dequeue方法完成具体的出队操作，并且唤醒等待入队元素的线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 获取队列中元素</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    // 获取之后元素置为null</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 出队之后队列为空</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">    t   akeIndex = 0;</span><br><span class="line">    // 队列元素 - 1</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒等待放置元素的线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2><p>使用Object::wait和Object::notify方法实现生产者-消费者模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line">     </span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用阻塞队列实现生产者-消费者模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">// 缓存区</span><br><span class="line">private ArrayBlockingQueue&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line"></span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new ArrayBlockingQueue&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        try&#123;</span><br><span class="line">            buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        String str = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            str = buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3932906.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3932906.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C之Callable, Future, FutureTask</title>
      <link href="/J-U-C%E4%B9%8BCallable-Future-FutureTask.html"/>
      <url>/J-U-C%E4%B9%8BCallable-Future-FutureTask.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>创建线程通过有两者方式：一种是继承Thread，一种是实现Runnable接口。但是着两种方式都存在着一个不足，即执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果。<br>自从Java1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><h2 id="callable接口"><a class="markdownIt-Anchor" href="#callable接口"></a> Callable接口</h2><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，这个方法叫做call()。该接口还是一个泛型接口，返回的结果类型就为传过来的类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    // 返回计算结果或者抛出一个错误</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable需要结合ExecutorService来使用，在ExecutorService接口中声明了若干个submit方法的重载版本。从下面的方法可以知道，Runnable任务也可以进行提交执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// task表示需要执行的任务</span><br><span class="line">// &lt;T&gt; 返回结果的类型</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><h2 id="future接口"><a class="markdownIt-Anchor" href="#future接口"></a> Future接口</h2><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果或者被取消。<br>Future类位于java.util.concurrent包下，它是一个接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">// 取消任务,参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务</span><br><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">// 任务是否取消</span><br><span class="line">boolean isCancelled();</span><br><span class="line">// 任务是否完成</span><br><span class="line">boolean isDone();</span><br><span class="line">// 这个方法会产生阻塞，会一直等到任务执行完毕才返回</span><br><span class="line">V get() throws InterruptedException, ExecutionException;</span><br><span class="line">// 获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span><br><span class="line">V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ol><li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true；</li><li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true；</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。<br>也就是说Future提供了三种功能：1. 判断任务是否完成；2. 能够中断任务；3. 能够获取任务执行结果。</li></ol><h2 id="futuretask类"><a class="markdownIt-Anchor" href="#futuretask类"></a> FutureTask类</h2><img src="/J-U-C之Callable-Future-FutureTask/extend.png" title="extend"><p>上图中是FutureTack继承关系图，最上层的FuctionalInterface是一个注解，标识了拥有该注解的接口支持函数式编程。FutureTask类实现了RunnableFuture接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><p>我们看一下RunnableFuture接口的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>事实上，FutureTask是Future接口的一个唯一实现类。</p><p>下面对FutureTask的源码进行具体分析：</p><h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3><ol><li><p>属性</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 状态机：存在以下7中状态</span><br><span class="line">private volatile int state;</span><br><span class="line">// 任务新建</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">// 任务完成中</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">// 任务正常完成</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">// 任务异常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">// 任务取消</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">// 任务中断中</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">// 任务已中断</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br><span class="line"></span><br><span class="line">// 可能状态转换：</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">// NEW -&gt; CANCELLED</span><br><span class="line">// NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"></span><br><span class="line">// 支持结果返回的任务</span><br><span class="line">private Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">// 任务执行结果：包含正常和异常的结果，通过get方法获取</span><br><span class="line">private Object outcome; </span><br><span class="line"></span><br><span class="line">// 任务执行线程</span><br><span class="line">private volatile Thread runner;</span><br><span class="line"></span><br><span class="line">// 栈结构的等待队列，该节点是栈中的最顶层节点</span><br><span class="line">private volatile WaitNode waiters;</span><br></pre></td></tr></table></figure><p>上述的WaitNode 结构定义如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用一个简单的链表节点来记录等待结果的线程 </span><br><span class="line">// 链表的具体实现为 Treiber Stack</span><br><span class="line">// 注: Treiber Stack 为一个无锁并发栈, 这意味着先进来的等待线程</span><br><span class="line">// 会最后获得结果.</span><br><span class="line">// Treiber Stack 实现思路为CAS+不断重试. </span><br><span class="line">// 参考：https://www.cnblogs.com/micrari/p/7719408.html</span><br><span class="line">static final class WaitNode &#123;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    volatile WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器</p><p>FutureTask提供了2个构造器：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接传入callable任务</span><br><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    // 初始状态为NEW</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入runnable任务及结果变量</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">        // 将Runnable 任务转换为Callable任务</span><br><span class="line">        this.callable = Executors.callable(runnable, result);</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask提供了两个构造方法，支持runnable和callable两种任务，但其实最终都是转换为callable任务。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 利用适配器模式进行转换</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunnableAdapter实现了Callable接口, 以实现适配器模式</span><br><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runnable转为callable的方法,其实就是通过RunnableAdapter适配器，RunnableAdapter本身是实现了callable接口，然后在call方法中，实际执行的是runnable的run方法，另外将传入的结果参数原封不动的作为结果返回。</p></li><li><p>run方法<br>run方法是FutureTask任务实际执行体，它主要完成包装的callable的call方法执行，并将执行结果保存到outcome中，同时捕获了call方法执行出现的异常，并保存异常信息，而不是直接抛出。另外，run方法存在的另一个意义就是通过它对状态机进行了维护，比如NEW-COMPLETEING-NORMAL 或 NEW-COMPLETEING-EXCEPTIONAL，保证了任务的处理流程。run方法一开始通过CAS更新runner为当前线程，从而避免了多线程下run被执行多次的调用，若runner线程不为null，则CAS失败。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    // 状态机不为NEW表示执行完成或任务被取消了，直接返回</span><br><span class="line">    // 状态机为NEW,同时将runner设置为当前线程，保证同一时刻只有一个线程执行run方法，如果设置失败也直接返回</span><br><span class="line">    // 只有runnner 为null时才会进行设置</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">    !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        // 取出任务检测不为空 且 再次检查状态为NEW</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行任务</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                // 任务执行抛出异常时，保存异常信息，而不直接抛出</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                // 执行成功则保存结果</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 在此之前执行器必须不能null,</span><br><span class="line">        // 与上面的CAS配合以此避免多线程并发调用run()的情况</span><br><span class="line">        runner = null;</span><br><span class="line">        // 任务取消之后必须重新获取state的状态，防止错过处理中断请求</span><br><span class="line">        int s = state;</span><br><span class="line">        // 如果被置为了中断状态则进行中断的处理</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">        handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get方法<br>get方法有两种，分别是一直阻塞和超时阻塞获取；get方法本意是直接获取任务执行结果，但是任务没执行完成时，会将当前线程进行阻塞等待，直到任务执行完成时才会唤醒。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 阻塞获取</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    // 任务非最终完成状态前通过awaitDone方法进行阻塞等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 超时阻塞获取</span><br><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    if (unit == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int s = state;</span><br><span class="line">    // 阻塞获取并达到阻塞超时时间后抛出超时异常</span><br><span class="line">    if (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">    (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        throw new TimeoutException();</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>awaitDone方法<br>调用awaitDone方法将请求线程进行阻塞。请求线程阻塞时，会创建一个waiter节点，然后加入到阻塞等待的栈中。当任务执行完成时或设置了阻塞超时时间的线程超时时，会将该线程从阻塞栈中移除，移除的方法很复杂，充分考虑了多线程并发的情况。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 线程阻塞等待方法</span><br><span class="line">private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123;</span><br><span class="line">    // 若timed 为true,则计算阻塞超时时间</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    // 默认不阻塞</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 如果阻塞线程被中断则将当前线程从阻塞队列中移除</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt; COMPLETING) &#123; </span><br><span class="line">            // 任务已经完成时直接返回结果</span><br><span class="line">            if (q != null)</span><br><span class="line">                q.thread = null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s == COMPLETING) </span><br><span class="line">            //如果任务执行完成，但还差最后一步最终完成，则让出CPU给任务执行线程继续执行</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (q == null)</span><br><span class="line">            // 新进来的线程添加等待节点</span><br><span class="line">            q = new WaitNode();</span><br><span class="line">        else if (!queued)</span><br><span class="line">            // 上一步节点创建完，还没将其添加到waiters栈中,</span><br><span class="line">            // 因此在下一个循环就会执行此处进行入栈操作，并将当前线程的等待节点置于栈顶</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q);</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            // 如果设置了阻塞超时时间，则进行检查是否达到阻塞超时时间，</span><br><span class="line">            // 达到了则删除当前线程的等待节点并退出循环返回，否则继续阻塞</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            // 阻塞线程</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;else</span><br><span class="line">            // 非超时阻塞</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>report方法<br>report方法会根据任务状返回结果。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取任务结果方法：正常执行则直接返回结果，否则抛出异常</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cancel方法<br>任务取消时会先检查是否允许取消，当任务已经完成或者正在完成（正常执行并继续处理结果 或 执行异常处理异常结果）时不允许取消。<br>cancel方法有个boolean入参，若为false，则只唤醒所有等待的线程，不中断正在执行的任务线程。若为true则直接中断任务执行线程，同时修改状态机为INTERRUPTED。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    // 不允许取消的情况：状态机不是NEW 或CAS更新状态机失败</span><br><span class="line">    if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        return false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果要求中断执行中的任务，则直接中断任务执行线程，并更新状态机为最终状态INTERRUPTED</span><br><span class="line">        if (mayInterruptIfRunning) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                if (t != null)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; finally &#123; </span><br><span class="line">                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 移除和唤醒所有线程, 并调用done方法,并设置cableable为null</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他方法<br>setException方法主要用于任务执行异常对处理，主要完成异常信息保存到outcom结果、状态机从NEW到EXCEPTIONAL的变化更新，以及唤醒阻塞在waiters队列中请求get的所有线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 任务执行异常处理</span><br><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    // 将状态机由NEW更新为COMPLETING</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        // 将异常信息保存到输出结果中</span><br><span class="line">        outcome = t;</span><br><span class="line">        // 更新状态机为处理异常的最终状态-EXCEPTIONAL</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">        // 通用的完成操作，主要作用就是唤醒阻塞在waiters队列中请求get的线程</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法任务正常处理和异常处理流程基本一样，不一样的是状态的变化为NEW-COMPLETEING-NORMAL。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePossibleCancellationInterrupt()方法处理可能的取消中断，其实它的作用就是—当发起中断的线程A将状态机更新为INTERRUPTING，还没继续中断任务线程前，CPU切换到任务执行线程B了，此时线程B执行本方法让出CPU，让发起中断的线程A能继续处理中断B的操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void handlePossibleCancellationInterrupt(int s) &#123;</span><br><span class="line">if (s == INTERRUPTING)</span><br><span class="line">    while (state == INTERRUPTING)</span><br><span class="line">        Thread.yield(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeWaiter方法主要的功能就是移除等待节点，当线程被中断或超时时会调用该方法来移除等待节点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void removeWaiter(WaitNode node) &#123;</span><br><span class="line">    if (node != null) &#123;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        retry:</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                for (WaitNode pred = null, q = waiters, s; q != null; q = s) &#123;</span><br><span class="line">                    s = q.next;</span><br><span class="line">                    if (q.thread != null)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    else if (pred != null) &#123;</span><br><span class="line">                        red.next = s;</span><br><span class="line">                    if (pred.thread == null) </span><br><span class="line">                        continue retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s))</span><br><span class="line">                        continue retry;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finishCompletion方法会移除和唤醒所有等待线程，并调用done方法，并将callable设置为null。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 移除和唤醒所有等待线程, 并调用done方法, 并将callable设置为null</span><br><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    // assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    q.thread = null;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next = null; // unlink to help gc</span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">    callable = null;        // to reduce footprint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2><ol><li><p>使用Callable + Future获取执行结果</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureExample &#123;</span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        // Future 对执行结果进行操作, submit方法底层也会将task包装成一个FutureTask对象</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(task);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2. 使用Callable + FutureTask获取执行结果</p><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 方式一</span><br><span class="line">        /*ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        executorService.shutdown();*/</span><br><span class="line"></span><br><span class="line">        //  方式二</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        // 因为futureTask实现了RunnableFuture接口, 而</span><br><span class="line">        RunnableFuture接口继承了Runnable</span><br><span class="line">        Thread thread = new Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>FutureTask实现了Runnable接口，因此可以作为一个线程执行任务处理，比如在线程池中submit方法就是用FutureTask类包装了一个runnable或callable任务；</li><li>FutureTask内部有个状态机，用于记录任务的处理状态，比如有三种最终状态：正常完成、执行异常、任务取消；</li><li>通过get方法阻塞获取任务执行结果，同时内部维护了一个阻塞等待栈，用于多线程并发调用get方法时，同时将这些线程阻塞并保存它们的阻塞信息，以便在任务执行完成后进行唤醒；</li><li>支持任务的取消操作，但是前提是任务还没完全执行成功的情况下才允许取消，取消分为两种：只唤醒阻塞等待结果的线程、唤醒线程同时强制中断任务执行线程。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3949310.html</a><br>[2] <a href="https://juejin.im/post/6844904181824749582" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/6844904181824749582</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析</title>
      <link href="/J-U-C%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%90%8C%E6%AD%A5%E5%99%A8-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
      <url>/J-U-C%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%90%8C%E6%AD%A5%E5%99%A8-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用同步器"><a class="markdownIt-Anchor" href="#常用同步器"></a> 常用同步器</h2><p>J.U.C中许多常用同步器都是基于AQS实现，主要有以下：CountDownLatch，Semaphore，CyclicBarrier，ReentrantLock，Condition。<br>下面对上述同步器进行源码分析, 源码分析下基于JDK 8。</p><h2 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>ReentrantLock是在JDK 1.5 引入的一个显示锁，可以实现多线程的互斥访问，可以实现和synchronized关键字同样的功能。ReentrantLock只支持独占方式的获取操作，是对lock接口的实现。<br>ReentrantLock将同步状态用于保存锁获取操作的次数（0 - 锁可被获取；整数i - 锁已被其他线程获取，因为ReentrantLock可重入，所以状态为整数i(i &gt;= 1)），并且还维护了一个owner变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。并且在tryRelease中检查owner域，从而确保当前线程在执行unlock操作之前已经获取了锁；在tryAcquire中使用这个域来区分获取操作是重入的还是竞争的。</p><h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3><p>下面的源码分析都是基于非公平的ReentrantLock实现。</p><h4 id="获取锁操作"><a class="markdownIt-Anchor" href="#获取锁操作"></a> 获取锁操作</h4><ol><li><p>lock()<br>ReentrantLock对外提供lock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的获取操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquire(int arg)<br>lock会调用acquire方法完成获取操作。若tryAcquire方法返回true，即成功获取到锁，就直接返回，线程继续往下运行；若获取失败则调用acquireQueud方法阻塞当前线程，等待锁的释放。<br>tryAcquire方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算获取锁成功。<br>阻塞一个线程由acquireQueued来实现。关于如何阻塞一个线程和如何唤醒线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquire(int arg)<br>ReentrantLock 实现 tryAcquire方法来获取资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 得到当前资源状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 当前同步状态 == 0, 表示锁未被获取</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 获取锁, 原子性修改同步状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置为独占模式的线程, 即owner状态</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若是重复获取, 即重入获取, 则修改同步状态为c+acquires</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="释放锁操作"><a class="markdownIt-Anchor" href="#释放锁操作"></a> 释放锁操作</h4><ol><li><p>unlock()<br>ReentrantLock对外提供unlock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的释放操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>release(int arg)<br>unlock方法会调用tryRelease方法去释放锁。若释放锁成功，则代表下一个等待锁的线程可以来获取锁，此时调用用unparkSuccesor方法唤醒；若释放锁失败，则直接返回。<br>tryRelease方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算释放锁成功。<br>关于如何唤醒下一个线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // tryRelease(arg)返回true, 则表示释放锁成功, </span><br><span class="line">    // 可以去唤醒下一个等待线程了</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        // 唤醒下一个等待线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryRelease(int releases)<br>ReentrantLock 实现 tryRelease方法来释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 当前线程不是获取锁的线程, 抛出错误</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 若c == 0, 当前锁没有进行重入</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置锁状态, 因为是可重入的, 可能需要多次释放操作</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="应用实例"><a class="markdownIt-Anchor" href="#应用实例"></a> 应用实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();    </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void insert(Thread thread) &#123;</span><br><span class="line">        // 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><ol><li>公平锁与非公平锁：<br>公平锁尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁；<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</li><li>ReentrantLock 与 synchronized对比<ol><li>ReentrantLock 是对lock接口的实现，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而ReentrantLock 在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用ReentrantLock 时需要在finally块中释放锁；</li><li>ReentrantLock 可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过ReentrantLock 可以知道有没有成功获取锁，而synchronized却无法办到； ReentrantLock 可以提高多个线程进行读操作的效率；</li><li>可以通过 ReentrantLock lock = new ReentrantLock(true) 来实现公平锁。</li></ol></li></ol><h2 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h2><h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h3><p>JUC提供了Lock可以方便的进行锁操作，但是有时候我们也需要对线程进行条件性的阻塞和唤醒，以此来模拟线程间的相互协助，这时我们就需要condition条件变量，它就像是在线程上加了多个开关，可以方便的对持有锁的线程进行阻塞和唤醒。<br>官方解释如下：</p><blockquote><p>条件（也称为条件队列或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其&quot;等待&quot;）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式释放相关的锁，并挂起当前线程，就像Object.wait 做的那样</p></blockquote><p>Condition主要是为了在J.U.C框架中提供和Java传统的监视器风格的wait，notify和notifyAll方法类似的功能。wait，notify等需要和synchronized结合适用，Condition则绑定在一个锁（Lock）上，一般作Lock的内部实现。<br>两者的主要区别见下图：</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/compare.png" title="compare"><h3 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h3><h4 id="condition-interface"><a class="markdownIt-Anchor" href="#condition-interface"></a> Condition interface</h4><p>Condition接口提供了如下方法以供实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*============阻塞=============*/</span><br><span class="line">// 当前线程在接到信号或被中断之前一直处于等待状态.=</span><br><span class="line">void await() throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号之前一直处于等待状态 [注意：该方法对中断不敏感]</span><br><span class="line">void awaitUninterruptibly(); </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">// 返回值表示剩余时间, 如果在&apos;nanosTimeout&apos;之前唤醒,那么返回值 </span><br><span class="line">=&apos;nanosTimeout - 消耗时间&apos;,</span><br><span class="line">// 如果返回值&apos;&lt;= 0&apos; ,则可以认定它已经超时了</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span><br><span class="line">// 如果没有到指定时间就被通知, 则返回 true ,否则表示到了指定时间,返回返回 false</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException; </span><br><span class="line"></span><br><span class="line">/*===========唤醒==============*/</span><br><span class="line">// 唤醒一个等待线程, 将线程从条件队列移到AQS同步队列中</span><br><span class="line">// 该线程从等待方法返回前必须获得与Condition相关的锁</span><br><span class="line">void signal(); </span><br><span class="line">// 唤醒所有等待线程, 将所有等待线程从条件队列中移到AQS步队列中</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure><p>Condition接口仅有一个实现类为ConditionObject，该类定义为AQS的内部类。</p><h4 id="线程挂起操作"><a class="markdownIt-Anchor" href="#线程挂起操作"></a> 线程挂起操作</h4><ol><li><p>await()<br>线程在调用await方法后将执行挂起操作，即新建 Condition 节点加入到 Condition 的队列尾部，并阻塞当前线程在条件队列中，直到线程等待的某个条件为真时才会被唤醒。在当前线程持有锁的基础上释放锁资源，以便其他线程获取锁资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    // 线程被中断,则抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 将节点加入到条件队列(Condition Queue)中</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放当前线程的锁,因为锁可重入, 所以是完全释放</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 当前节点是否在AQS同步队列中</span><br><span class="line">    // 如果不在同步队列中, 则park当前线程, 说明该线程还未满足竞争锁资源的</span><br><span class="line">    // 条件；如果在或者被中断过, 则退出循环</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当走到这步时, 代表已经调用了signal/signalAll方法, 重新竞争锁资源</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 清理取消等待的节点</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addConditionWaiter()<br>addConditionWaiter会将新建一个状态为Condition状态的节点并加入到条件队列的末尾。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // Node的节点状态如果不为CONDITION,</span><br><span class="line">    // 则表示该节点不处于等待状态,需要清除节点</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程新建节点,状态 CONDITION</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fullyRelease()<br>fullyRelease方法负责完成释放该线程持有的锁，因为例如 ReentrantLock 是可以重入的。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 持有锁的数量 </span><br><span class="line">        int savedState = getState();</span><br><span class="line">        // 完全释放锁, 因为ReentrantLock可重入</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed = false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁失败, 将节点状态置为CANCELLED</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>isOnSyncQueue()<br>isOnSyncQueue方法判断一个节点是否在AQS的同步队列上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">    // 状态为 Condition或者前驱节点为 null, 返回 false</span><br><span class="line">    if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">        return false;</span><br><span class="line">    // 后继节点不为 null，肯定在同步队列中</span><br><span class="line">    if (node.next != null) </span><br><span class="line">        return true;</span><br><span class="line">    // 从同步队列尾部开始向前查找, 判断是否在同步队列上</span><br><span class="line">    return findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unlinkCancelledWaiters()<br>unlinkCancelledWaiters方法负责将条件队列中状态不为Condition的节点删除。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    // 记录上一个Node节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        // 节点状态不为CONDITION, 将其删除</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="线程唤醒操作"><a class="markdownIt-Anchor" href="#线程唤醒操作"></a> 线程唤醒操作</h4><ol><li><p>signal()<br>signal方法会将Condition 的头节点移动到AQS同步队列尾部，让其等待再次获取锁资源。会首先唤醒条件队列中第一个节点，即等待时间最长的节点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //检测当前线程是否拥有锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //头节点，唤醒条件队列中的第一个节点</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doSignal()<br>doSignal方法会依次移除条件队列的节点，并调用transferForSignal方法将节点移动到AQS同步队列中。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //修改头结点，完成旧头结点的移出工作</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    // 将条件队列中的节点移动到同步队列中</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">    (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>transferForSignal()<br>transferForSignal会将条件队列的节点移动到AQS同步队列中。并修改当前节点的前一个结点状态为SIGNAL。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //将该节点从状态CONDITION改变为初始状态0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //将节点加入到同步队列中去,返回的是同步队列中node节点前面的一个节点</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //如果结点p的状态为cancel 或者修改waitStatus失败,则直接唤醒</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h3><p>使用Condition实现生产者消费者模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConditionExample &#123;</span><br><span class="line">    // 缓冲区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer;</span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line">    private Lock lock;</span><br><span class="line">    // 定义两个Condition, 即两个条件队列</span><br><span class="line">    private Condition fullCondition;</span><br><span class="line">    private Condition notFullCondition;</span><br><span class="line"></span><br><span class="line">    ConditionExample(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">        lock = new ReentrantLock();</span><br><span class="line">        fullCondition = lock.newCondition();</span><br><span class="line">        notFullCondition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        //获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                //缓冲区已经满了,不能再进行添加, </span><br><span class="line">                // 调用await方法将添加的线程设置为等待状态,并且释放锁</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加数据到缓存区</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            // 告知可以从缓冲区获取数据了 ,将fullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            fullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 记得释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (buffer.size() == 0)&#123;</span><br><span class="line">                // 缓冲区为空,不能进行获取, </span><br><span class="line">                // 调用await方法将获取的线程设置为等待状态,并且释放锁</span><br><span class="line">                fullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 从缓存区取数据</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            // 告知可以添加数据到缓存区了,将notFullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object::wait，notify实现生产者消费者模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line"></span><br><span class="line">    ConditionTest(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="http://www.iocoder.cn/JUC/sike/Condition/" rel="external nofollow noopener noreferrer" target="_blank">http://www.iocoder.cn/JUC/sike/Condition/</a><br>[2] <a href="https://www.cnblogs.com/dolphin0520/p/3920385.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3920385.html</a></p><h2 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h2><h3 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h3><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源，或者说是同时执行某个特定操作的数量。<br>Semaphore将AQS同步状态用来保存当前可用许可的数量，许可的数量可以通过构造函数的参数指定。</p><ol><li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可；</li><li>访问资源后，使用release释放许可。<br>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</li></ol><h3 id="源码分析-3"><a class="markdownIt-Anchor" href="#源码分析-3"></a> 源码分析</h3><h4 id="获取许可操作"><a class="markdownIt-Anchor" href="#获取许可操作"></a> 获取许可操作</h4><ol><li><p>acquire()<br>Semaphore对外提供acquire方法，用户不需要了解其他详细的获取细节，线程通过调用该方法来获取许可，以完成对特定资源的访问。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquireSharedInterruptibly()<br>acquireSharedInterruptibly方法会调用tryAcquireShared方法来获取许可。若返回正整数（大于等于0），表示获取许可成功，线程继续向前执行；否则将调用doAcquireSharedInterruptibly方法将线程加入到同步队列，等待许可的释放。<br>tryAcquireShared方法交由Semaphore来实现，它自己来实现判断逻辑 - 怎么才算获取许可成功。<br>xxxxShared表示该获取操作是非独占操作（Shared）。<br>关于如何阻塞一个线程，将线程加入到同步队列中，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    // 线程中断</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 若返回整数, 则表示获取需求成功, 线程继续向后执行</span><br><span class="line">    // 否则, 获取失败, 将线程加入到同步队列, 等待许可的释放</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared()<br>Semaphore实现tryAcquireShared方法来完成具体的许可获取逻辑。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到可用许可</span><br><span class="line">        int available = getState();</span><br><span class="line">        // 计算剩余许可</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        // 原子更新可用许可, 并返回剩余许可数</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="释放许可操作"><a class="markdownIt-Anchor" href="#释放许可操作"></a> 释放许可操作</h4><ol><li><p>release()<br>Semaphore对外提供release方法，用户不需要了解其他详细的许可释放细节就可以完成许可释放操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>releaseShared()<br>release方法会调用releaseShared方法去释放许可。若释放许可成功，则调用doReleaseShared方法来唤醒同步队列中的等待线程来尝试重新获取需求；若释放许可失败，则直接返回。<br>tryReleaseShared方法交由Semaphore来实现，它自己来实现释放许可逻辑。<br>关于如何释放同步队列中的一个等待线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 许可释放成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 唤醒等待获取许可的线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared()<br>Semaphore通过tryReleaseShared方法来实现许可的释放逻辑。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到当前许可数量</span><br><span class="line">        int current = getState();</span><br><span class="line">        // 修改许可数量</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        // 原子更新许可数量</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="应用实例-2"><a class="markdownIt-Anchor" href="#应用实例-2"></a> 应用实例</h3><p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。<br>读取数据到数据库中，可以启动几十个线程并发读取来进行读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreTest&#123;</span><br><span class="line">    private static final int COUNT = 40;</span><br><span class="line">    private static Executor executor = Executors.newFixedThreadPool(COUNT);</span><br><span class="line">    private static Semaphore semaphore = new Semaphore(10);</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        for(inti=0;i&lt;COUNT;i++)&#123;</span><br><span class="line">            executor.execute(newThreadTest.Task());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override </span><br><span class="line">        public void run()&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">            // 获取许可, 因为许可数量只有十个, 所有最多只能有10个线程进行操作</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            //todo 存数据过程</span><br><span class="line">            semaphore.release();</span><br><span class="line">            &#125;catch(InterruptedExceptione)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><p>[1] <a href="https://www.jianshu.com/p/0090341c6b80" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0090341c6b80</a></p><h2 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h2><h3 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h3><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>CountDownLatch是通过一个计数器来实现的，通过同步状态保存当前计数值，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/countDownLatch.png" title="countDownLatch"><h3 id="源码分析-4"><a class="markdownIt-Anchor" href="#源码分析-4"></a> 源码分析</h3><h4 id="获取闭锁操作"><a class="markdownIt-Anchor" href="#获取闭锁操作"></a> 获取闭锁操作</h4><ol><li><p>await()<br>CountDownLatch对外部提供await方法，用户不需要了解闭锁获取的细节，线程通过调用该方法来获取闭锁。<br>在await() 方法中会调用与Semaphore相同的acquireShared方法来获取锁，并且获取失败之后的处理也一致，都是AQS提供了公共方法。主要不同体现在tryAcquireShared 方法的实现上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared(int acquires)<br>当同步状态等于0时，表示其他线程已经全部执行完毕，获取闭锁成功，线程继续往下执行；若失败，则将线程放入到同步队列中，并阻塞线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    // 同步状态等于0时,代表其他线程已经执行完毕, 获取闭锁成功</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="释放闭锁操作"><a class="markdownIt-Anchor" href="#释放闭锁操作"></a> 释放闭锁操作</h3><ol><li><p>countDown()<br>CountDownLatch对外部提供countDown方法，其他线程调用该方法来释放资源。<br>在countDown() 方法中会调用与Semaphore相同的releaseShared方法来释放资源，并且释放成功之后的处理也一致，都会尝试唤醒同步队列上的等待线程，都是AQS提供了公共方法。主要不同体现在tryReleaseShared 方法的实现上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 释放资源成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 尝试唤醒同步队列的等待线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared(int args)<br>tryReleaseShared方法将会减少同步状态，当同步状态等于0时，返回true，会调用doReleaseShared 方法唤醒同步队列的等待线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 减少同步状态直到为0</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="应用实例-3"><a class="markdownIt-Anchor" href="#应用实例-3"></a> 应用实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchExample &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建一个线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; catch (Exception e)&#123;</span><br><span class="line">                    log.info(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 只有当threadCount 为0时, 即200个线程执行完毕之后, 才会执行后面的语句</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        // 等待10ms, 若200个线程没有执行完毕, 则当前线程会继续执行</span><br><span class="line">        // countDownLatch.await(10, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(&quot;finish&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test (int threadNum) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数器为1的CountDownLatch，并让其他所有线程都在这个锁上等待，只需要调用一次countDown()方法就可以让其他所有等待的线程同时恢复执行。</li><li>开始执行前等待N个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统都已经启动和运行了。</li><li>死锁检测：一个非常方便的使用场景是你用N个线程去访问共享资源，在每个测试阶段线程数量不同，并尝试产生死锁。</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><p>[1] <a href="https://www.jianshu.com/p/4b6fbdf5a08f" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4b6fbdf5a08f</a></p><h3 id="countdownlatch和semaphore结合实例"><a class="markdownIt-Anchor" href="#countdownlatch和semaphore结合实例"></a> CountDownLatch和Semaphore结合实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcurrencyTest&#123;</span><br><span class="line">    //请求数</span><br><span class="line">    public static intc lientTotal=1000;</span><br><span class="line">    //并发请求数</span><br><span class="line">    public static int threadTotal=50;</span><br><span class="line">    //共享计数量</span><br><span class="line">    public static int count=0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)throws InterruptedException&#123;</span><br><span class="line">        //定义线程池</span><br><span class="line">        ExecutorService executorService=Executors.new CachedThreadPool();</span><br><span class="line">        //定义信号量,并设置运行并发数</span><br><span class="line">        final Semaphore semaphore=new Semaphore(threadTotal);</span><br><span class="line">        //定义CountDownLatch,在所有的请求完成之后输出结果</span><br><span class="line">        final CountDownLatch countDownLatch=new CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        //线程执行</span><br><span class="line">        for(inti=0;i&lt;clientTotal;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    //获取信号量-最大并发数为50</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    count();</span><br><span class="line">                    //释放信号量</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                    log.info(&quot;InterruptedException&quot;,e);</span><br><span class="line">                &#125;</span><br><span class="line">                //进行count--</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //只有countDown到0的时候,才会唤起线程继续执行,不然会挂起继续等待</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        //关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        //在所有子线程执行完之后,打印count值</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void count()&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h2><h3 id="概述-5"><a class="markdownIt-Anchor" href="#概述-5"></a> 概述</h3><p>CycliBarrier也称为循环屏障，它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，循环是指因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p><h3 id="实现原理-2"><a class="markdownIt-Anchor" href="#实现原理-2"></a> 实现原理</h3><p>CyclicBarrier将同步状态设置为到达屏障的线程数量。当某一个线程到达屏障之后，将当前线程加入到同步队列中并阻塞，并且数量减一，当数量为0时，唤醒被阻塞的所有线程，让它们继续执行。</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/cyclicBarrier.png" title="cyclicBarrier"><h3 id="源码分析-5"><a class="markdownIt-Anchor" href="#源码分析-5"></a> 源码分析</h3><ol><li><p>CyclicBarrier(int parties) / CyclicBarrier(int parties, Runnable barrierAction)<br>CyclicBarrier提供了两种构造方法，提供了参数有：需要到达屏障的线程数，到达指定屏障后优先执行的动作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    // 屏障数量</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    // 当前还有多少线程没有到达屏障</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>await()<br>CyclicBarrier对外提供await方法。用户不需要了解循环屏障的具体实现细节就可使用其提供的功能。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // dowait(timed, nanos)</span><br><span class="line">        // 当timed = true时, 表示设置等待超时时间, nanos为时才</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dowait(boolean timed, long nanos)<br>await通过调用dowait方法来实现线程的阻塞和唤醒。若还有剩余线程未到达屏障，线程通过调用该方法来完成阻塞操作，将线程阻塞在屏障前；若所有线程已到达屏障前，则唤醒所有被阻塞的线程，让它们继续向前执行。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">throws InterruptedException, BrokenBarrierException,</span><br><span class="line">TimeoutException &#123;</span><br><span class="line">    // 定义一个可重入锁, 保证多线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 构建一个&quot;代&quot;(Generation)对象</span><br><span class="line">        // 同一个Generation表示同一代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        // 如果broken=true表示当前屏障被损坏了,抛出异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        // 如果线程被中断过, 设置屏障为损坏状态    </span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 需要到达屏障的线程数减 - 1</span><br><span class="line">        int index = --count;</span><br><span class="line">        // 若数量为0, 表示所有线程都到达了屏障</span><br><span class="line">        if (index == 0) &#123;</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                // 表示到达屏障之后,如果我们有设置barrierCommand, 则优先执行</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                 //执行到这里的时候，说明所有线程都执行await()方法(到达了屏障)</span><br><span class="line">                // 且设置的barrierCommand也已经执行完了</span><br><span class="line">                //接下来要做的事情就是换代(所以CyclicBarrier是通过换代的方式</span><br><span class="line">                // 实现重新计数的)</span><br><span class="line">                //换代之后相当于进入一个新的周期,所有线程在后续中又可以通过</span><br><span class="line">                // await()阻塞一次</span><br><span class="line">                ranAction = true;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 如果ranAction = false说明当前屏障还有流程没执行完,</span><br><span class="line">                // 所以需要屏障设置会损坏状态</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 进行自旋操作直到count=0,调用breakBarrier方法(表示屏障有问题的场景),</span><br><span class="line">        // 中断或者超时</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            // 没有设置超时时间,</span><br><span class="line">            // 调用Condition的await()阻塞,相当于把线程加入</span><br><span class="line">            // 到Condition队列中阻塞, 等到调用signalAll方法唤醒</span><br><span class="line">            if (!timed)</span><br><span class="line">                trip.await();</span><br><span class="line">            // 设置阻塞超时时间</span><br><span class="line">            else if (nanos &gt; 0L)</span><br><span class="line">                nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                // 如果当前屏障没有换代,也没有损坏,</span><br><span class="line">                // 那么就设置为损坏状态之后再抛出中断异常</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 中断线程等待</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果屏障已经被损坏了</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line">                                        </span><br><span class="line">            // 如果发现已经换代了, 就不继续循环了,</span><br><span class="line">            // 直接返回剩余屏障数</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            // 表示超时时间到了</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nextGeneration()<br>若所有线程都到达了屏障，将条件队列中的线程切换到AQS同步队列中，并唤醒所有等待线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 条件队列中的等待线程切换AQS同步队列中, AQS同步队列中等待线程依次被唤醒获取锁</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // 开始一个循环屏障</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用实例-2"><a class="markdownIt-Anchor" href="#使用实例-2"></a> 使用实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line"></span><br><span class="line">    // 设置屏障数量为5</span><br><span class="line">    // private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span><br><span class="line">    // 到达指定屏障之后, 优先执行barrierAction中的动作</span><br><span class="line">    private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&gt; &#123;</span><br><span class="line">        log.info(&quot;Priority Action!!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    doSomething(threadNum);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void doSomething(int threadNum) throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am ready!&quot;, threadNum);</span><br><span class="line">        // 某个线程初始化完毕, 则阻塞等待, 若阻塞数量达到5个, 则一起执行每个线程后面的方法</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am done!&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><p>CyclicBarrier适用多线程计算数据，最后合并计算结果的场景。<br>相比于CountDownLatch，CyclicBarrier能适用于更多场景，例如，如果计算发生错误，可以重置计数 器，并让线程重新执行一次。因为CountDownLatch计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</p><h3 id="参考资料-3"><a class="markdownIt-Anchor" href="#参考资料-3"></a> 参考资料</h3><p>[1] <a href="http://blog.sikacode.com/article/40#CyclicBarrier_68" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sikacode.com/article/40#CyclicBarrier_68</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C之AQS源码学习</title>
      <link href="/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html"/>
      <url>/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="aqsabstractqueuedsynchronizer"><a class="markdownIt-Anchor" href="#aqsabstractqueuedsynchronizer"></a> AQS(AbstractQueuedSynchronizer)</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>AQS 提供了一种实现阻塞锁和一系列依赖FIFO同步队列的同步器的框架，ReentrantLock，CountDownLatch等等都是基于AQS的基础上实现的。<br>使用AQS去实现自定义的同步器时，我们只需要实现对共享资源的获取和释放即可，对于阻塞线程的维护和唤醒都有AQS进行了实现，进一步简便了自定义同步器的实现。<br>在基于AQS构建的同步器类中，最基本的操作包括各种形式的获取操作和释放操作，还有定义状态信息。</p><ol><li>获取操作是一种依赖状态的操作，并且通常会阻塞。当使用锁或信号量时，“获取&quot;操作的含义就是获取锁或者许可，并且调用者可能会一直等待直到同步器类处于可被获取的状态。例如在使用CountDownLatch时，“获取&quot;操作意味着&quot;等待并直到闭锁到达结束状态”，使用FutureTask时，则意味着&quot;等待并直到任务已经完成”。<br>根据同步器的不同，获取操作可以是独占操作（ReentrantLock），也可以是非独占操作（Semaphore，CountDownLatch）。<br>如果某个同步器支持独占的获取操作，那么需要实现一些保护方法，包括tryAcquire，tryRelease和isHeldExclusively等，而对于支持共享获取的同步器，则应该实现tryAcquireShared，tryReleaseShared等。AQS中的acquire，acquiredShared，release，releaseShared等方法都将调用这些方法在子类中带有前缀try的版本来判断某个操作是否能执行。<br>在同步器的子类中，可以根据其获取操作和释放操作的语义，使用getState，setState以及compareAndSetState来检查和更新状态，并通过返回的状态值来告知基类&quot;获取&quot;或&quot;释放&quot;同步器的操作是否成功。</li><li>&quot;释放&quot;操作并不是一个可阻塞的操作，当执行&quot;释放&quot;时，所有在请求时被阻塞的线程都会开始执行。</li><li>一个类想要成为状态依赖的类，它必须拥有一些状态。AQS负责管理同步器类中的状态，它管理了一个整数状态信息（volatile关键字修饰），可通过getState，setState和compareAndSetState等方法来操作。这个整数可以表示为任意状态。例如ReentrantLock用它来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它来表示任务的状态（尚未开始，正在运行，已完成或已取消）。<br>同步器还可以自行管理一些额外的状态变量，例如ReentrantLock保存了锁的所有者的信息，以此来区分获取操作是重入的还是竞争的。</li></ol><p>下图说明了获取操作和释放操作的伪代码：</p><img src="/J-U-C之AQS源码学习/getrelease.jpg" title="get/release"><p>对于获取操作：同步器判断当前状态是否允许获得操作，如果允许，则允许线程执行，并更新同步器的状态，否则获取操作将阻塞或失败。具体的判断实现，由同步器的语义决定。<br>对于释放操作：更新同步器的状态，并且如果新的状态允许某个被阻塞的线程获取成功，则解除等待队列中一个或多个线程的等待状态。</p><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><p>OneShotLatch是一个使用AQS来实现的二元闭锁。包含两个方法：await，signal，分别对应获取操作和释放操作。<br>AQS状态用来表示闭锁的状态 - 关闭（0） 和 打开（1）。起初，闭锁是关闭的，任何调用await方法的线程都将阻塞并直到闭锁被打开。当通过调用signal打开闭锁时，所有等待中的线程都将被释放，并且随后到达闭锁的线程也被允许执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class oneShotLatch &#123;</span><br><span class="line">    private final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    public void signal()&#123;</span><br><span class="line">        sync.releaseShared(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await()&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(0);</span><br><span class="line">    &#125;</span><br><span class="line">    private class Sync extends AbstractQueueSynchronizer&#123;</span><br><span class="line">        protected int tryAcquireShared(int ignored)&#123;</span><br><span class="line">            // 如果闭锁打开状态(1), 则获取操作成功, 否则失败</span><br><span class="line">            return (getState() == 1) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        protected boolean tryReleaseShared(int ignored)&#123;</span><br><span class="line">            // 打开闭锁</span><br><span class="line">            setState(1);</span><br><span class="line">            // 返回true, 代表其他线程可以获取该闭锁</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 的acquireSharedInterruptibly 和 releaseShared 方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行流程如下：</p><ol><li>当某个线程调用await方法时，该方法会调用AQS的acquireSharedInterruptibly方法，然后接着调用oneShotLatch的tryAcquireShared方法（在这个方法中实现同步器的获取语义），在tryAcquireShared的实现中返回一个值来表示获取操作能否执行。<br>若闭锁是关闭的（获取失败），那么AQS会调用doAcquireSharedInterruptibly方法将线程放入等待线程队列中。</li><li>当某个线程调用signal方法时，该方法会调用AQS的releaseShared方法，然后接着调用oneSlotLatch的tryReleaseShared方法（在这个方法中实现同步器的释放语义），oneShotLatch的tryReleaseShared方法实现将无条件把闭锁设置为打开，通过返回true表示该同步器处于被释放的状态。<br>若释放成功，AQS 会调用 doReleaseShared 方法会让所有等待的线程都尝试重新请求同步器，并且由于tryAcquireShared将返回成功，因此获取操作将成功。</li></ol><h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h2><p>下述的源码分析基于JDK 8。<br>前面所提到的获取操作可能会阻塞线程，释放操作可能会对唤醒线程，并且也提到了阻塞线程是记录在一个同步队列上，那么AQS是如何来完成线程的阻塞和唤醒的呢？<br>AQS通过一个FIFO队列（双向链表，该队列也被称为同步队列）来保存阻塞线程，队列中每个Node节点就是对每一个等待获取资源的线程的封装，Node 作为一个静态内部类保存了线程本身（Thread），线程的等待状态（WaitStatus），双向链表指针（pre，next）以及独占模式还是共享模式等等。<br>其中在队列中的一个线程具有以下五种状态：</p><ol><li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化；</li><li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL；</li><li>CONDITION(-2)：表示结点等待在Condition上。当调用Condition的await方法时，会将线程置为CONDITION状态，并将线程从同步队列（Sync queue）移动到条件队列中（Condition queue)，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从条件队列转移到同步队列中，将线程状态设置为0，等待获取同步锁；</li><li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点；</li><li>0：新结点入队时的默认状态。</li></ol><img src="/J-U-C之AQS源码学习/syncQueue.png" title="syncQueue"><p>其中head结点所指的标杆结点，就是当前获取到资源的那个结点或null。</p><h3 id="独占模式下资源获取"><a class="markdownIt-Anchor" href="#独占模式下资源获取"></a> 独占模式下资源获取</h3><ol><li><p>acquire(int arg)<br>acquire方法是独占模式下线程获取资源的顶层入口。如果获取到了资源（tryAcquire方法返回true，该方法实现具体由自定义同步器的语义决定），则线程直接返回；否则将当前线程加入等待队列，等待其他线程释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquire(int arg)<br>tryAcquire方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryAcquire方法交由自定义同步器来实现具体的获取资源的逻辑。</p></li><li><p>addWaiter(Node mode)<br>addWriter方法根据传递过来的mode（SHARED - 共享模式，EXCLUSIVE - 独占模式）创建一个新的node节点，队列的尾结点不为空，则将新结点插入到尾部，并返回Node结点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 将新node放置结尾</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 原子更新tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 上一步设置失败, 则通过enq入队</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>endq(final Node node)<br>当tail结点为空时，addWaiter方法插入结点失败，此时会调用enq方法来进行新结点入队。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //CAS&quot;自旋&quot;，直到成功加入队尾</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它</span><br><span class="line">        if (t == null) &#123; </span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">        // 若此时tail结点不为空, 则将node结点放入尾部</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquireQueued(final Node node，int arg)<br>当执行完addWaiter方法时，关于当前线程的Node结点已经放入同步队列，当前线程进入到等待状态，等待其他线程释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    // 标记是否成功拿到资源</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 标记等待过程是否被中断</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 自旋等待获取资源</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 拿到前驱结点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前驱结点是head, 则表示当前结点是&quot;老二&quot;, 便有资格去获取资源</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //拿到资源后，将head指向该结点</span><br><span class="line">                // 就是当前获取到资源的那个结点或null</span><br><span class="line">                setHead(node);</span><br><span class="line">                // setHead中node.prev已置为null,此处再将head.next置为null,</span><br><span class="line">                // 就是为了方便GC回收以前的head结点</span><br><span class="line">                p.next = null;</span><br><span class="line">                // 成功获取资源</span><br><span class="line">                failed = false;</span><br><span class="line">                // 返回等待过程中是否被中断过</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 利用shouldParkAfterFailedAcquire方法将线程设置了watting状态</span><br><span class="line">            // 如果等待过程中被中断过,哪怕只有那么一次,就interrupted标记为true</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 如果等待过程中没有成功获取资源</span><br><span class="line">        // 那么取消结点在队列中的等待</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>shouldParkAfterFailedAcquire (Node pre，Node node)<br>shouldParkAfterFailedAcquire  主要用来检查状态，防止前面的结点已经放弃了等待，但是没有被移除。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    // 前一个结点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    // 前序结点为SIGNAL时, 表示后继结点在等待唤醒</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        return true;</span><br><span class="line">    // 当前驱结点 &gt; 0时, 即为CANCELLED状态时, 代表前驱节点中的线程已经放弃了等待</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        // 一直往前找,直到找到最近一个正常等待的状态,并排在它的后边</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果前驱状态正常，那就把前驱的状态设置成SIGNAL, 表示后继节点在等待唤醒</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt()<br>parkAndCheckInterrupt方法就是让线程去休息，真正进入等待状态。<br>park方法会让当前线程进入waiting状态，可以有两种途径唤醒它：unpark方法/interrupt方法。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    //调用park()使线程进入waiting状态</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    //如果被唤醒，查看自己是不是被中断的</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结</p> <img src="/J-U-C之AQS源码学习/acquire.png" title="acquire"><ol><li>调用AQS提供的acquire方法来获取资源，在acquire方法中会调用自定义同步器所实现的tryAcquire方法判断是否可以成功获取资源，若获取成功，则直接返回，线程继续向前执行；</li><li>若第一步中获取资源失败，则调用addWaiter方法将当前线程封装成一个Node结点加入到同步队列的末尾；</li><li>入队成功后，调用acquireQueued方法将设置线程为waitting状态（具体是调用park方法）。需要注意是，在首次调用acquireQueued方法时就会进行一次判断，判断是否可以获取到资源，因为此时可能会其他线程进行了释放操作；</li><li>如果线程调用了unpark方法和interrupt方法，那么将唤醒当前线程，判断线程是否可以<br>获取到资源，若可以进行获取操作，则将线程的Node结点设置为head结点，并返回。</li></ol></li></ol><h3 id="独占模式下资源释放"><a class="markdownIt-Anchor" href="#独占模式下资源释放"></a> 独占模式下资源释放</h3><ol><li><p>release(int arg)<br>release方法是独占模式下线程获取资源的顶层入口。该方法会释放指定量的资源，与此同时，它会唤醒同步队列中的等待线程来获取资源。具体释放资源操作由tryAcquire方法实现，而该方法的具体实现由自定义同步器的语义决定。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        // 找到头结点</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒等待队列的下一个线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryRelease (int arg)<br>tryRelease方法尝试去释放指定量的资源。如果释放成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryRelease方法交由自定义同步器来实现具体的释放资源的逻辑。</p></li><li><p>unparkSuccessor(Node node)<br>unparkSuccessor方法用于唤醒同步队列中当前Node结点的下一个结点，唤醒其中的线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    // 获取当前结点的状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 若结点状态为 SIGNAL(-1), CONDITION(-2), PROPAGATE(-3)</span><br><span class="line">    // 将状态更新为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    // 找到下一个需要唤醒的结点</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    // 若下一个需要唤醒的结点为null 或状态为已取消(CANCELLED - 1)</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前查找, 找到一个可以被唤醒的结点</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        if (t.waitStatus &lt;= 0)</span><br><span class="line">            s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 调用unpark方法, 唤醒s结点中的线程, 那么被唤醒的线程会继续执行acquireQueued中的获取操作</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="共享模式下资源获取"><a class="markdownIt-Anchor" href="#共享模式下资源获取"></a> 共享模式下资源获取</h3><ol><li><p>acquireShared(int arg)<br>acquireShared方法是共享模式下线程获取资源的顶层入口。它会获取指定量的资源，若获取成功则直接返回，否则失败进行同步队列等待资源的释放。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared(int arg)<br>AQS作为一个框架，它提供了tryRelease方法交由自定义同步器来实现具体获取资源的逻辑。相比于tryAcquire返回一个boolean值，tryAcquiredShared方法将返回一个整数：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doAcquireShared(int arg)<br>doAcquireShared方法会调用addWaiter方法将当前线程封装为一个Node结点并插入到同步队列的末尾。之后进入到一个自旋操作，若满足条件（前序结点为head）会尝试获取一次资源，若获取失败，则调用parkAndCheckInterrupt方法中的park方法使得线程进行watting状态。<br>doAcquireShared的获取流程和acquireQueued方法的获取流程大致一致，只是将中断之后的调用方法放置在了方法内部。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 调用addWaiter方法将当前线程的结点插入到同步队列末尾</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    // 是否成功获取资源</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 等待过程中是否被中断的标记</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获得前驱结点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前驱结点是head, 则表示当前结点是&quot;老二&quot;, 便有资格去获取资源</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取资源</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 若返回整数则代表获取成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将head指向自己，还有剩余资源可以再唤醒之后的线程</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; </span><br><span class="line">                    //如果等待过程中被打断过, 此时将中断补上</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            // 判断状态，调用park方法使进入waiting状态, 等着被unpark()或interrupt()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    if (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>setHeadAndPropagate(Node node，int propagate)<br>setHeadAndPropagate方法 首先会将当前Node结点设置为head结点，若还有剩余资源，则尝唤醒下一个邻居线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // 记录旧头部以便下面的检查操作</span><br><span class="line">    // 将head指向自己</span><br><span class="line">    setHead(node);</span><br><span class="line">    // 如果还有剩余量, 继续唤醒下一个邻居线程</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">    (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared(); // 唤醒下一个邻居线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="共享模式下资源释放"><a class="markdownIt-Anchor" href="#共享模式下资源释放"></a> 共享模式下资源释放</h3><ol><li><p>releaseShared(int arg)<br>releaseShared方法是共享模式下线程获取资源的顶层入口。该方法会释放指定量的资源，与此同时，它会唤醒同步队列中的等待线程来获取资源。具体释放资源操作由tryAcquireShared方法实现，而该方法的具体实现由自定义同步器的语义决定）</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放资源</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 唤醒后继结点</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared (int arg)<br>tryReleaseShared方法尝试去释放指定量的资源。如果释放成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryReleaseShared方法交由自定义同步器来实现具体的释放资源的逻辑。</p></li><li><p>doReleaseShared ()<br>doReleaseShared方法主要用来唤醒同步队列上的线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    // 自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            // 若head结点的状态为SIGNAL</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;</span><br><span class="line">                // 唤醒后继结点</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">            !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] 《并发编程实战》<br>[2] <a href="https://www.cnblogs.com/waterystone/p/4920797.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J.U.C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的共享</title>
      <link href="/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html"/>
      <url>/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html</url>
      
        <content type="html"><![CDATA[<h2 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<br>在多线程下，面临一个问题就是，无法确保执行读操作的线程能适时地看到其他线程写入的值。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready;</span><br><span class="line">    private static int number;</span><br><span class="line"></span><br><span class="line">    private static class ReaderThread extends Thread &#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while(!ready)</span><br><span class="line">                // 让出线程执行时间, 从执行状态-&gt; 就绪状态</span><br><span class="line">                Thread.yield();</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new ReaderThread().start();</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是因为可见性问题，NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready值，还可能的是，NoVisibility可能会输出0，因为读线程看到了写入的ready值，但是却没有看到之后写入的number值，这种现象被称为&quot;重排序(Reordering)&quot;。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以很明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。</p><h3 id="失效数据"><a class="markdownIt-Anchor" href="#失效数据"></a> 失效数据</h3><p>上面NoVisibility的读线程所获得的数据称为失效数据。失效数据可能不会同时出现：一个线程获得某个变量的最新值，而获得另一个变量的失效值。失效数据会导致一些让人意想不到的错误，不精确的计算以及无限循环。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MutableInteger &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    </span><br><span class="line">    // 线程安全 public synchronized int get()</span><br><span class="line">    public int get()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 线程安全  public synchronized void set(int value)</span><br><span class="line">    public void set(int value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个线程调用了set，那么另一个正在调用get的线程可能会看到更新之后的最新值，也可能看到的是过期值（失效值）。可以加上synchronized同步使其线程安全。</p><h3 id="最低安全性"><a class="markdownIt-Anchor" href="#最低安全性"></a> 最低安全性</h3><p>当某个线程在没有同步的情况下读写一个变量，可能会得到失效值，但是这个值至少了之前某个线程设置的值，而不是一个随机值，这中安全性保证称为&quot;最低安全性（out-of-thin-air-safety）&quot;。<br>绝大部分变量都符合最低安全性，但是存在一个例外：非volatile类型的64位数值变量（double，long）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但是对于非volatile类型的64位数值变量，JVM允许将64位的读操作或写操作分解位32位的操作，那么当读写操作在不同线程执行时，可能会读取到某个值的高32位和另一个值的低32位。<br>因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型变量都是不安全的，除非使用volatile声明或加锁。</p><h3 id="加锁和可见性"><a class="markdownIt-Anchor" href="#加锁和可见性"></a> 加锁和可见性</h3><p>内置锁可以确保某个线程以一种可预测的方式来查看另一个线程的结果。</p><img src="/对象的共享/sync.jpg" title="sync"><p>当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。<br>加锁的含义步仅仅局限于互斥行为，还包括内存可见性。</p><h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3><p>Java 提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程，即保证了新值能够立即同步回主存，以及每次使用前立即从主存刷新，总是返回最新写入的值。当把变量声明为volatile类型时，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序，volatile变量也不会被缓存在寄存器或者对处理器不可见的地方。<br>volatile的特性主要是通过内存屏障和禁止重排序优化来实现。</p><ol><li>内存屏障：对volatile变量写操作时，会在写操作之后加入一条store屏障指令，将工作内存中的共享变量同步回主存中；对volatile变量读操作时，会在读操作之前加入一条load屏障指令，将主存中最新的值刷新到工作内存中;</li><li>禁止重排序优化。</li></ol><p>访问volatile变量不会执行加锁操作，因此也就不会执行线程阻塞，所以说volatile是一种比synchronized关键字更加轻量级的同步机制。<br>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。volatile正确的使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生。<br>volatile常用的一个场景作为状态标识量，可以用来作为某个操作完成，发生中断或者状态的标志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean inited=false;</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">context = loadContext();</span><br><span class="line">inited=true;</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><p>单独使用volatile并不能保证对共享变量操作的线程安全。例如volatile的语义并不能保证递增操作（Count++）的线程安全性（原子性）。<br>当且仅当满足以下条件时，才应该使用volatile变量：</p><ol><li>对变量的写入操作不依赖变量的当前值，或者保证只有单个线程更新变量的值；</li><li>该变量不会与其他状态变量一起纳入不变性条件中；</li><li>在访问变量时不需要加锁。</li></ol><h3 id="加锁和volatile"><a class="markdownIt-Anchor" href="#加锁和volatile"></a> 加锁和volatile</h3><p>加锁机制即可以确保可见性又可以保证原子性，而volatile变量只能保证可见性。</p><h3 id="其他可见性方案"><a class="markdownIt-Anchor" href="#其他可见性方案"></a> 其他可见性方案</h3><ol><li><p>synchronized<br>synchronized的可见性是由&quot;对一个变量执行unlock操作之前，必须先把此变量同步回主存中（执行store，write）&quot;这条规则得到的。可以详细解释为：</p><ol><li>线程解锁时，必须把共享变量的最新值刷新到主存；</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中得到最新的值。</li></ol></li><li><p>final<br>final关键字的可见性是指： 被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把&quot;this&quot; 的引用传递出去，那么在其他线程中就能看到final字段的值。</p></li></ol><h2 id="线程封闭"><a class="markdownIt-Anchor" href="#线程封闭"></a> 线程封闭</h2><p>当访问共享的可变数组时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，这种技术就称为线程封闭。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。<br>Java 语言中并没有强制规定某个变量必须由锁来保护，也无法强制将对象封闭在线程中。线程封闭时程序设计的一个考虑因素，必须在程序中实现。</p><h3 id="ad-hoc线程封闭"><a class="markdownIt-Anchor" href="#ad-hoc线程封闭"></a> Ad-hoc线程封闭</h3><p>Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序来承担。此种线程封闭时不可靠且脆弱的，因为没有任何一种语言特性能将对象封闭到目标线程上。</p><h3 id="栈封闭"><a class="markdownIt-Anchor" href="#栈封闭"></a> 栈封闭</h3><p>在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。<br>对于基本类型的局部变量，任何方法都无法获得对于基本类型的引用，因此确保了基本类型的局部变量始终封闭在线程内。<br>在维持对象引用的栈封闭性时，需要多做一些工作以确保被引用的对象不会逸出。<br>如果在线程内部（Within-Thread）上下文使用非线程安全的对象，那么该对象仍然是线程安全的。</p><h3 id="threadlocal线程封闭"><a class="markdownIt-Anchor" href="#threadlocal线程封闭"></a> ThreadLocal线程封闭</h3><p>ThreadLocal 类提供了get和set方法，这些方法为每个使用该变量的线程都存有一份独立的副本。ThreadLocal通常用来防止对可变的单实例变量（Singleton）或全局变量进行共享。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectioHolder</span><br><span class="line">    = new ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">    // 调取initialValue获取初始值</span><br><span class="line">    // 为每个线程都分配一个数据库连接</span><br><span class="line">    public Connection initialValue()&#123;</span><br><span class="line">        return DriverManaget.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">    return ConnectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将TheadLocal<t>视为包含了Map&lt;Thread, T&gt;对象，其中保存了特定于该线程的值，但是ThreadLocal的实现并非如此。当线程终止后，这些值会被做为垃圾回收。</t></p><h2 id="对象发布和逸出"><a class="markdownIt-Anchor" href="#对象发布和逸出"></a> 对象发布和逸出</h2><h3 id="对象发布"><a class="markdownIt-Anchor" href="#对象发布"></a> 对象发布</h3><p>发布对象：使一个对象能够被当前作用域之外的代码所使用。<br>例如：将一个指向该对象的引用保存在其他代码可以访问的地方；在某一个非私有的方法返回该对象的引用；将引用传递到其他类的方法中。</p><ol><li><p>将一个指向该对象的引用保存在其他代码可以访问的地方</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Set&lt;Person&gt; knowPerson;</span><br><span class="line"></span><br><span class="line">public void initalize () &#123;</span><br><span class="line">    knowPerson = new HashSet&lt;Person&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发布某个对象时，可能会间接发布其他对象。比如若Set集合中保存了若干Person 对象，那么发布了KnowPerson之后，里面的Person对象也会被发布出去。</p></li><li><p>在某个非私有的方法返回该对象的引用</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class publish &#123;</span><br><span class="line">    // 定义一个字符串对象数组</span><br><span class="line">    public String[] strings = &#123;&quot;HB&quot;, &quot;QQL&quot;, &quot;HY&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 通过一个公有方法发布它, 使得当前范围之外代码所使用</span><br><span class="line">    public String[] getStrings () &#123;</span><br><span class="line">        return strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Publish publish = new Publish();</span><br><span class="line">        log.info(&quot;Strings: &#123;&#125;&quot;, Arrays.toString(publish.getStrings()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将引用传递到其他类的方法中</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class publish &#123;</span><br><span class="line">    class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        OtherClass otherClass = new OtherClass();</span><br><span class="line">        otherClass.doSomething(new Person());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，发布了Person对象。通常接受被发布对象的方法称为外部方法（Alien），即定义一个类C，对于C来说，外部方法是指行为并不完全由C来规定的方法，包括其它类中定义的方法以及类C中可以被改写的方法。当把一个对象传递给一个外部方法时，就相当于发布了这个对象。<br>另外当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。总结来说，一个已经发布的对象能够通过非私有的变量引用或方法调用到达其他的对象，那么这些对象也会被间接发布。</p></li></ol><h3 id="对象逸出"><a class="markdownIt-Anchor" href="#对象逸出"></a> 对象逸出</h3><p>对象逸出：一种错误的发布，某个不应该发布的对象被发布。<br>当一个对象逸出后，其他类或线程可能会误用该对象。<br>几种常见的对象逸出可看下述代码示例：</p><ol><li><p>内部状态的逸出</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Escape &#123;</span><br><span class="line">    // 定义一个私有的字符串对象数组</span><br><span class="line">    private String[] strings = &#123;&quot;HB&quot;, &quot;QQL&quot;, &quot;HY&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 通过一个公有方法发布它, 使得当前范围之外代码所使用</span><br><span class="line">    public String[] getStrings () &#123;</span><br><span class="line">        return strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafePublish unsafePublish = new UnsafePublish();</span><br><span class="line">        log.info(&quot;Stings: &#123;&#125;&quot;, Arrays.toString(unsafePublish.getStrings()));</span><br><span class="line">        unsafePublish.getStrings()[0] = &quot;CCZ&quot;;</span><br><span class="line">        // 不安全, 其他线程会够对私有对象进行修改</span><br><span class="line">        log.info(&quot;Stings: &#123;&#125;&quot;, Arrays.toString(unsafePublish.getStrings()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串数组作为私有变量但是被发布了，逸出了它所在的作用域。在发布一个对象时，要确保对象的内部状态不被发布，可能会破坏封装性。</p></li><li><p>this引用在构造函数逸出</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThisEscape &#123;</span><br><span class="line">    public ThisEscape (EventSource source) &#123;</span><br><span class="line">        source.registerListener (</span><br><span class="line">            // 匿名内部类, 持有指向外部类对象的引用</span><br><span class="line">            new EventListener() &#123;</span><br><span class="line">                public void onEvent (Event e) &#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述发布隐式地使this引用逸出，当ThisEscape发布了EventListener时，也隐含了发布了ThisEscape本身，并且发布的ThisEscape时一个尚未构造完成的对象，会造成线程安全性问题。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。<br>通常一下几种操作会造成this应用逸出：</p><ol><li>在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论时显示创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未构造完成之前，新的线程就可以看见它。<br>在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initalize方法来启动；</li><li>在构造函数中调用一个可改写的示例方法时（既不是私有方法，也不是final方法），同样会导致this应用在构造过程中逸出。</li></ol> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThisEscape &#123;</span><br><span class="line">    private int thisCanBeEscape = 89;</span><br><span class="line"></span><br><span class="line">    public ThisEscape () throws InterruptedException &#123;</span><br><span class="line">        // a. 创建一个线程</span><br><span class="line">        Thread thread = new Thread(() -&gt;&#123;</span><br><span class="line">            log.info(&quot;Escape caused by create thread &#123;&#125;&quot;, ThisEscape.this.thisCanBeEscape);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.run();</span><br><span class="line"></span><br><span class="line">        // b. 调用一个实例方法</span><br><span class="line">        doSomething();</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        log.info(&quot;&#123;Escape caused by call method&#125;&quot;, UnsafeEscape.this.thisCanBeEscape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThisEscape thisEscape = new ThisEscape ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过使用一个私有的构造函数和一个公共的工厂方法来避免不正确的构造过程：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SafeListener &#123;</span><br><span class="line">    private final EventListener listener;</span><br><span class="line"></span><br><span class="line">    private SafeListener () &#123;</span><br><span class="line">        listener = new EventListener() &#123;</span><br><span class="line">            public void onEvent(Event e) &#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SafeListener newInstance (EventSource source) &#123;</span><br><span class="line">        SafeListener safe = new SafeListener(); // 构造函数已完成</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        return safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象分类"><a class="markdownIt-Anchor" href="#对象分类"></a> 对象分类</h2><h3 id="不可变对象"><a class="markdownIt-Anchor" href="#不可变对象"></a> 不可变对象</h3><p>如果某个对象在被创建后其状态就不能被修改，称这个对象为不可变对象。线程安全性是不可变对象的固有属性之一（不可变对象一定是线程安全的，可以安全地发布和共享），它们的不变性条件是由构造函数创建的（不可变对象只有一种状态，并且该状态由构造函数来控制），只要它们的状态不改变，那么这些不变性条件就能得以维持。<br>当满足以下条件时，对象才是不可变的：</p><ol><li>对象创建以后其状态就不能修改；</li><li>对象的所有域都是final类型；</li><li>对象是正确创建的（在对象的创建期间，this引用没有逸出）。</li></ol><p>对于不可变对象，不得不提的就为final关键字，它用来构造不可变对象，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。<br>但是要知道的是，不可变性并不等于将对象中所有的域声明为final类型就可以，就算声明为final，这个对象仍是可变的，因为final类型的域中可以保存可变对象的引用。<br>除了final，下面这些容器也可以创建不可变对象，Collections.unmodifiableXXX：Collection，List，Set，Map… 以及 Guava：ImmutableXXX：Collection，List，Set，Map…</p><h3 id="事实不可变对象"><a class="markdownIt-Anchor" href="#事实不可变对象"></a> 事实不可变对象</h3><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么称这种对象为事实不可变对象（Effectively Immutable Object）。<br>在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象，所以对于事实不可变对象，安全发布就足够了。</p><h3 id="可变对象"><a class="markdownIt-Anchor" href="#可变对象"></a> 可变对象</h3><p>对于可变对象，不仅在发布对象时需要使用同步（因为安全发布只能确保&quot;发布当时&quot;状态的可见性），而且在每次访问时同样需要使用同步来确保后续修改的操作的可见性。</p><h2 id="安全发布对象"><a class="markdownIt-Anchor" href="#安全发布对象"></a> 安全发布对象</h2><p>所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的。<br>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有同步。<br>可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程都必须使用同步。要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。<br>下面是一个不安全的发布例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不安全的发布</span><br><span class="line">public Holder holder;</span><br><span class="line"></span><br><span class="line">public void initialize() &#123;</span><br><span class="line">    holder = new Holder(43);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在可见性问题，其他线程看到的Holder对象可能处于不一致状态，这种不正确的发布导致其他线程看到尚未创建完成的对象。在未被正确发布的对象中存在两个问题：</p><ol><li>除了发布对象的线程外，其他线程可能看到的Holder域是一个失效值，可能是一个空引用或者一个之前的旧值；</li><li>线程看到Holder 引用的值是最新的，但Holder状态的值确实失效的。</li></ol><p>一个正确构造的对象可以通过以下方式来安全地发布：</p><ol><li>在静态初始化函数中初始化一个对象引用；</li><li>将对象的引用保存到volatile类型的域中或者AtomicReferance对象中；</li><li>将对象的引用保存在某个正确构造的对象的final类型域中；</li><li>将对象的引用保存到一个由锁保护的域中。</li></ol><p>其中需要对第一项进行以下解释，静态初始化器（例如静态代码块）由JVM在类的初始化阶段执行，由于在JVM的内部存在着同步机制，因此通过这种方式初始化的任何对象都是可以被安全的发布。<br>在线程安全容器内部的同步意味着，在将某个对象放入到某个容器，将满足上述最后一条请求。线程安全库中的容器类提供了以下的安全发布保证：</p><ol><li>通过将一个键或者值放入Hashtable，synchronizedMap或ConcurrentMap中，可以安全地将它发布给任何访问它的线程（无论是直接访问还是迭代器访问）；</li><li>通过将某个元素放入Vector，CopyOnWriteArrayList，CopyOnWriteSet，synchronizedList，synchronizedSet中，可以安全地将它安全地发布任何从这些容器中访问该元素的线程；</li><li>通过将某个元素放入BlockingQueue，ConcurrentLinkedQueue，可以安全地将它安全地发布任何从这些容器中访问该元素的线程。</li></ol><p>如果对象在构造后可以修改，那么安全发布只能确保&quot;发布当时&quot;状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全的共享可变对象，这些对象就必须被安全地发布，并且必须时线程安全的或者由某个锁保护起来。</p><p>综上，对象的发布需求取决于它的可变性，可以概括为：</p><ol><li>不可变对象可以通过任何机制来发布；</li><li>事实不可变对象必须通过安全方式来发布；</li><li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>在并发程序中使用和共享对象时，可以使用一下一些使用的策略：</p><ol><li>线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改，常见的线程封闭为使用本地变量；</li><li>只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象；</li><li>线程安全共享：线程安全共享对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。</li><li>保护对象：被保护的对象只能通过持有特定的锁来访问。保护的对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定的锁保护的对象。</li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>先检查再执行：if(condition(a)) {handle(a)};  即使对象a和b都是线程安全对象，但是这种先检查再执行的操作是线程不安全的，因为这种操作不属于原子性操作。</li><li>遍历（迭代器遍历，foreach遍历，因为foreach是一种实际使用迭代器实现的语法糖）Vertor，ArrayList等，不能同时进行添加和删除操作。<br>具体解析见：<a href="https://www.cnblogs.com/kobelieve/p/10626473.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/kobelieve/p/10626473.html</a></li><li>Java 非同步容器：HashMap，HashSet，ArrayList，StringBuilder等。</li><li>Java同步容器：Vector，Stack，HashTable（Key，Value不能同时为空），Collections.synchronizedXXX(List，Set，Map)。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] 《Java编程实战》</p>]]></content>
      
      
      <categories>
          
          <category> Concurrency </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法</title>
      <link href="/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
      <url>/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法概述"><a class="markdownIt-Anchor" href="#排序算法概述"></a> 排序算法概述</h2><h3 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h3><ol><li><p>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；</p></li><li><p>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p></li></ol><p>以下是常用的十一种排序算法：</p><img src="/经典排序算法/totalSort.png" title="totalSort"><h3 id="算法时间复杂度"><a class="markdownIt-Anchor" href="#算法时间复杂度"></a> 算法时间复杂度</h3><img src="/经典排序算法/time.png" title="time"><h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3><ol><li>稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ol><h2 id="排序算法实现"><a class="markdownIt-Anchor" href="#排序算法实现"></a> 排序算法实现</h2><h3 id="公共代码实现"><a class="markdownIt-Anchor" href="#公共代码实现"></a> 公共代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 交换两个元素值</span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 得到最大值</span><br><span class="line">private int getMaxValue (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (maxValue &lt; nums[i]) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最小值</span><br><span class="line">private int getMinValue (int[] nums) &#123;</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (minValue &gt; nums[i]) &#123;</span><br><span class="line">           minValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#冒泡排序bubble-sort"></a> 冒泡排序（Bubble Sort）</h3><ol><li><p>概述<br>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;数列的顶端。</p></li><li><p>算法思路</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；</li><li>针对所有的元素重复以上的步骤，最后已排序好的元素不需要再次比较；</li><li>重复步骤1~3，直到排序完成。</li></ol> <img src="/经典排序算法/bubbleSort.gif" title="bubbleSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bubbleSort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 当最外层循环遍历完毕, 则代表着数组有序</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 从头开始依次两两比较, 比较结束条件为len - i - 1</span><br><span class="line">        for(int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">            // 比较相邻的两个元素, 若前者大于后者, 则进行交换</span><br><span class="line">            if (nums[j] &gt; nums[j + 1])&#123;</span><br><span class="line">                swap(nums, j + 1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序quick-sort"><a class="markdownIt-Anchor" href="#快速排序quick-sort"></a> 快速排序（Quick Sort）</h3><ol><li><p>概述<br>快速排序的基本思想是：通过一趟排序以基准元素为基础将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序（分别进行划分），整个排序过程可以递归进行，使整个数据变成有序序列。</p></li><li><p>算法思路</p><ol><li>数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，该位置称为 K ；</li><li>根据第2步得到的基准元素位置 K，递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列进行1~2步的分区操作。</li></ol> <img src="/经典排序算法/QuickSort.gif" title="QuickSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    quickSort(nums, 0, len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 - left &gt;= right时</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 2. 递进操作</span><br><span class="line">        // 递归排序分区, 返回基准元素所在位置</span><br><span class="line">        int partitionIndex = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, partitionIndex - 1);</span><br><span class="line">        quickSort(nums, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 选择最左边的数为基准元素</span><br><span class="line">    int pivot = left;</span><br><span class="line">    // 以基准元素为比较元素开始分区操作</span><br><span class="line">    int index = pivot + 1;</span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行 </span><br><span class="line">    index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, pivot, index - 1);</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排序优化<br>快速排序的运行时间与划分是否对称有关。最坏情况下，每次划分过程产生两个区域分别包含n-1个元素和1个元素，其时间复杂度会达到O(n^2)。在最好的情况下，每次划分所取的基准都恰好是中值，即每次划分都产生两个大小为n/2的区域。此时，快排的时间复杂度为O(nlogn)。所以基准的选择对快排而言至关重要。<br>如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。<br>为了解决上述问题，可以采用随机基准的方式来应对上述特殊情况。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">     </span><br><span class="line">    // 将随机选择一个元素作为基准元素</span><br><span class="line">    // Math.Random()函数能够返回带正号的double值, 该值大于等于0.0且小于1.0</span><br><span class="line">    int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 将随机索引处的元素与left处进行交换</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量index，其[pivot + 1,index)范围内的元素小于基准元素</span><br><span class="line">    int index = left + 1;</span><br><span class="line"></span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行</span><br><span class="line">    // index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    // 2. 定义变量i，其[index, i - 1]范围内的元素大于基准元素</span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        // 3. 触发index变量转移条件，保证循环不变量定义正确</span><br><span class="line">        if (nums[i] &lt; nums[left]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, left, index - 1);</span><br><span class="line">    // 4. 返回结果</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二路快速排序quick-sort-2-ways"><a class="markdownIt-Anchor" href="#二路快速排序quick-sort-2-ways"></a> 二路快速排序（Quick Sort 2 Ways）</h3><ol><li><p>概述<br>二路快速排序的时间和空间复杂度同随机化快速排序。 但是对于有大量重复元素的数组，如果使用随机化快速排序效率是非常低的，导致 partition 后大于基点或者小于基点数据的子数组长度会极度不平衡，甚至会退化成 O(n^2)时间复杂度的算法，对这种情况可以使用双路快速排序算法。</p></li><li><p>算法思路<br>双路快速排序算法是随机化快速排序的改进版本，partition 过程使用两个索引值（i、j）用来遍历数组，将  &lt;= V 的元素放在索引i所指向位置的左边，而将 &gt;= V的元素放在索引 j 所指向位置的右边，V 代表标定值，平衡左右两边子数组。</p> <img src="/经典排序算法/quickSort2.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void quickSort2ways (int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件</span><br><span class="line">    if (left &gt; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int index = partition2(nums, left, right);</span><br><span class="line">    quickSort3Ways(nums, left, index - 1);</span><br><span class="line">    quickSort3Ways(nums, index + 1, right);</span><br><span class="line"></span><br><span class="line">    // 3. 递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partition2(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 随机选择一个基准</span><br><span class="line">    int randomIndex = (int) (Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 交换left和randomIndex的位置</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line">    int v = nums[left];</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量i, 其在[left + 1, i)范围中的元素 &lt;= v</span><br><span class="line">    //    定义变量j, 其在(j, right] 范围中的元素 &gt;= v</span><br><span class="line">    int i = left + 1, j = right;</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量i改变条件</span><br><span class="line">        while (i &lt;= right &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量j改变条件</span><br><span class="line">        while (j &gt;= left + 1 &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 循坏退出条件</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // 交换 i, j索引处元素</span><br><span class="line">        // 此时若 nums[i] == nums[j] == v, 也会进行交换</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放置到正确位置上</span><br><span class="line">    swap(nums, left, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三路快速排序quick-sort-3-ways"><a class="markdownIt-Anchor" href="#三路快速排序quick-sort-3-ways"></a> 三路快速排序（Quick Sort 3 Ways）</h3><ol><li><p>概述<br>三路快速排序时间和空间复杂度同随机化快速排序。三路快速排序算法是使用三路划分策略对数组进行划分，对处理大量重复元素的数组非常有效提高快速排序的过程。它增加了处理等于基准元素值的逻辑，将所有等于基准元素的值集中在一起。</p></li><li><p>算法思路<br>三路快速排序是双路快速排序的进一步改进版本，三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，等于 v 的数据在下次递归中不再需要排序，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优。</p> <img src="/经典排序算法/quickSort3.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort3Ways(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 left &gt;= right</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 随机选择一个基准</span><br><span class="line">        int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        int curr = nums[left];</span><br><span class="line"></span><br><span class="line">        // 1. 定义lt为[left + 1, lt]中的元素小于curr</span><br><span class="line">        int lt = left;</span><br><span class="line">        // 1. 定义gt为[gt, r]中的元素大于curr</span><br><span class="line">        int gt = right + 1;</span><br><span class="line">        // 1. 定义[lt + 1, i) 中的元素等于curr</span><br><span class="line">        int i = left + 1;</span><br><span class="line"></span><br><span class="line">        // 2. 递归结束条件, i碰到了gt边界</span><br><span class="line">        while (i &lt; gt) &#123;</span><br><span class="line">            if (nums[i] &lt; curr) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                // 3. 触发变量</span><br><span class="line">                swap(nums, lt, i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (nums[i] &gt; curr) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums, i, gt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将基准元素放置在正确位置上</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line"></span><br><span class="line">        // 对[left, lt - 1] 进行处理</span><br><span class="line">        quickSort3Ways(nums, left, lt - 1);</span><br><span class="line">        // 对[gt, right] 进行处理</span><br><span class="line">        quickSort3Ways(nums, gt, right);</span><br><span class="line"></span><br><span class="line">        // 4. 返回结果 - 暂无</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入排序insertion-sort"><a class="markdownIt-Anchor" href="#插入排序insertion-sort"></a> 插入排序（Insertion Sort）</h3><ol><li><p>概述<br>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>算法思路</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出有序序列的下一个元素，作为待插入的新元素，在已经排序的元素序列中从后向前扫描；</li><li>如果有序序列中的元素大于新元素，则从后向前继续比较有序序列中的元素；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol> <img src="/经典排序算法/InsertionSort.gif" title="InsertionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void insertSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 从下标为1的元素开始选择合适的位置插入, 因为下标0默认是有序的</span><br><span class="line">    for(int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        // 需要插入的新元素</span><br><span class="line">        int curr = nums[i];</span><br><span class="line">        // 从已经排序的序列的最右-&gt;左开始比较</span><br><span class="line">        int j = i;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; curr) &#123;</span><br><span class="line">            // 进行数组的移动</span><br><span class="line">            nums[j] = nums[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到了插入位置</span><br><span class="line">    if(j != i)</span><br><span class="line">        nums[j] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序shell-sort"><a class="markdownIt-Anchor" href="#希尔排序shell-sort"></a> 希尔排序（Shell Sort）</h3><ol><li><p>概述<br>希尔排序是简单插入排序的改进版，是基于插入排序的以下两点性质而提出的一种排序方法：</p><ol><li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  —&gt; 希尔排序会优先比较距离较远的元素，从而达到更远的移动距离；</li><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 —&gt; 希尔排序在整个序列&quot;基本有序&quot;的时候，直接采用插入排序来进行一次比较。<br>希尔排序又叫缩小增量排序。</li></ol></li><li><p>算法思路</p><ol><li>选择一个增量序列t1，t2，…，ti，tj，….tk，其中ti&gt;tj，tk=1，增量序列在排序的过程中不断递减；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各个子序列进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol> <img src="/经典排序算法/ShellSort.gif" title="ShellSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    int gap = 1;</span><br><span class="line">    </span><br><span class="line">    // 选择合适的初始值, 如果直接用len/3的话, 后面可能无法递减为1</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;  // 1, 4, 13, 40, 121....  // Tk, Tk-1,.....,T1</span><br><span class="line">    </span><br><span class="line">    // 对序列进行k趟排序</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        // 从下标为gap的元素(从后往前)开始选择合适的位置插入, 因为子序列的第一个元素默认是有序的</span><br><span class="line">        for(int i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            int j = i - gap;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; nums[j] &gt; cur) &#123;</span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将新元素放置到正确位置, j + gap是因为while循环中最后进行了一次j = j - gap</span><br><span class="line">            nums[j + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        // 缩小增量</span><br><span class="line">        gap = gap / 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="选择排序shell-sort"><a class="markdownIt-Anchor" href="#选择排序shell-sort"></a> 选择排序（Shell Sort）</h3><ol><li><p>概述<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li><li><p>算法思路</p><ol><li>初始未排序区域为nums[0…nums.length - 1]</li><li>从未排序区域找到元素值最小的元素，将它和数组中第一个元素交换位置；未排序区域更新为nums[1…nums.length - 1]，从该区域找到第二个元素值最小的元素，将它和数组中第二个元素交换位置，如此反复，直到整个数组排序完成。</li></ol> <img src="/经典排序算法/SelectionSort.gif" title="SelectionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void selectionSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 将nums[i] 与 nums[i+1..len - 1]中最小的元素交换</span><br><span class="line">        int min = i;</span><br><span class="line">        // 从无序区域找到一个最小的元素</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序heap-sort"><a class="markdownIt-Anchor" href="#堆排序heap-sort"></a> 堆排序（Heap Sort）</h3><ol><li><p>概述<br>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></li><li><p>算法思路</p><ol><li>初始化堆：堆将待排序序列构造成一个大顶堆/小顶堆（升序 - 大顶堆，降序 - 小顶堆），此时，整个序列的最大值就是堆顶的根节点；</li><li>将根节点与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n 个元素的次大值；</li><li>如此反复执行，便能得到一个有序序列。</li></ol> <img src="/经典排序算法/HeapSort.gif" title="HeapSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 堆排序算法</span><br><span class="line">public void heapSort(int[]arr)&#123;</span><br><span class="line">     //1.初始化堆,从最后一个非叶子节点从右向左,从下向上依次进行&quot;堆化&quot;</span><br><span class="line">    for(int i=(arr.length/2)-1; i&gt;=0; i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.依次交换栈顶元素和末尾元素和重新调整堆</span><br><span class="line">    for(int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);</span><br><span class="line">        adjustHeap(arr,0,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整堆</span><br><span class="line">public void adjustHeap(int[]arr,int i,int len)&#123;</span><br><span class="line">    //取出当前元素</span><br><span class="line">    int curr = arr[i];</span><br><span class="line">    //从当前节点的左节点开始比较</span><br><span class="line">    for(intk=i*2+1;k&lt;len;k=k*2+1)&#123;</span><br><span class="line">        //若右节点存在且大于左节点,则切换到左节点进行操作</span><br><span class="line">        if(k+1&lt;len&amp;&amp;arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">            k=k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子节点的值大于父节点</span><br><span class="line">        if(arr[k]&gt;curr)&#123;</span><br><span class="line">            //交换元素值</span><br><span class="line">            arr[i]=arr[k];</span><br><span class="line">            //以孩子节点作为父节点继续进行调整</span><br><span class="line">            i=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i]=curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><ol><li><p>概述<br>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li>自上而下的递归；</li><li>自下而上的迭代。</li></ol></li><li><p>算法思路</p><ol><li><p>递归法<br>在每一层递归上分为三个步骤：<br>a. 分解（Divide）：将n个元素分为 n / 2 个元素的子序列，然后一直递归分解，直到只剩一个元素；<br>b. 解决（Conquer）：用合并排序法对两个子序列进行排序；<br>c. 合并（Combine）：合并两个已排序的子序列得到当前递归层的排序结果。</p></li><li><p>迭代法<br>先归并那些微型的数组，然后再成对归并得到的子数组，如此这般，直到将整个数组归并完成。<br>a. 先进行两两归并（归并子数组长度为1），得到一个&quot;部分有序&quot;（两两相邻有序）的数组；<br>b. 然后对第一步得到的数组进行四四归并（将两个大小为2的数组归并为一个有四个元素的子数组），又得到一个相比于第一步更加有序的数组；<br>c. 然后是八八归并，一直归并下去，直到整个数组有序；<br>d. 注意对最后一个子数组的处理，其长度可能小于归并的默认长度。</p></li></ol> <img src="/经典排序算法/MergeSort.gif" title="MergeSort"></li><li><p>代码实现</p><ol><li><p>公共代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将nums数组进行归并, 将nums[start..end]和data[mid+1, end]归并成一个更大的有序数组, 其中nums[start..mid],</span><br><span class="line">// nums[mid+1,end]已有序</span><br><span class="line">private void mergeResult(int[] nums, int start, int mid, int end) &#123;</span><br><span class="line">    int i = start, j = mid + 1, len = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 归并所需要的辅助数组</span><br><span class="line">    int[] temp = new int[len];</span><br><span class="line"></span><br><span class="line">    // 辅助数组</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        temp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在temp数组上进行大小比较, 然后temp中的值放回到nums中,返回过程中进行排序</span><br><span class="line">    // 比较方法 - nums[start..mid]和data[mid+1, end]依次开始比较</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        // nums[start..mid]的数据排序完成</span><br><span class="line">        if (i &gt; mid) &#123;</span><br><span class="line">            nums[k] = temp[j++];</span><br><span class="line">        // nums[mid + 1..end]的数据排序完成</span><br><span class="line">        &#125; else if (j &gt; end) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else if (temp[i] &lt; temp[j]) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            nums[k]= temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    merge(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge (int[] nums, int start, int end) &#123;</span><br><span class="line">    // 1. 递归结束条件 -只有一个元素</span><br><span class="line">    if (start == end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int mid = (start + end) / 2;</span><br><span class="line">    // 对左边进行排序</span><br><span class="line">    merge(nums, start, mid);</span><br><span class="line">    // 对右边进行排序</span><br><span class="line">    merge(nums, mid + 1, end);</span><br><span class="line">    // 对上述排序结果进行合并</span><br><span class="line">    mergeResult(nums, start, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // sz表示子数组的长度</span><br><span class="line">    for (int sz = 1; sz &lt; len; sz = sz + sz) &#123;</span><br><span class="line">        // 以sz为基准, 把nums分为若干个长度为2sz的子数组, 对其进行归并排序                                  </span><br><span class="line">        //  若下一个子数组的起始位置大于等于len-sz则表示剩余的元素小于sz个，则不需要再进行合并排序了（上一个归并已经处理了）</span><br><span class="line">        for (int lo = 0; lo &lt; len - sz; lo += sz + sz) &#123;</span><br><span class="line">            // 后面的Math.min(lo + sz + sz - 1, len - 1) 是为了保证对未能组成两个归并数组的处理</span><br><span class="line">            mergeResult(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, len - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="多路归并排序merge-sort"><a class="markdownIt-Anchor" href="#多路归并排序merge-sort"></a> 多路归并排序（Merge Sort）</h3><p>插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要外部排序算法来解决。<br>外部排序算法由两个阶段构成：</p><ol><li>按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为&quot;归并段&quot;或者&quot;顺段&quot;），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li><li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li></ol><p>对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。<br>想要达到减少访问外存的次数（归并次数）从而提高算法效率的目的，可以从两个角度实现：</p><ol><li>增加 k-路平衡归并中的 k 值 — 多路归并算法；</li><li>尽量减少初始归并段的数量 m，即增加每个归并段的容量 — 置换-选择排序算法；</li></ol><h3 id="计数排序counting-sort"><a class="markdownIt-Anchor" href="#计数排序counting-sort"></a> 计数排序（Counting Sort）</h3><ol><li><p>概述<br>在于将输入的数据值转化为键（数组索引）存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。<br>额外开辟的数组空间的长度为输入数组的最大值+1，这也意味着计数排序对于数据范围很大的输入数据，它需要很大的空间来用来进行计数，所以计数排序是一种典型的空间换时间的算法。</p></li><li><p>算法思路</p><ol><li>找出待排序数组的最大值，开辟一个额外数组，其长度为最大值+1；</li><li>遍历待排序数组，计算数组中每个元素的出现次数，并且将元素值作为索引，出现的次数作为值存入到额外数组中；</li><li>遍历额外数组，若其元素值（出现次数）大于0，则将其索引作为元素值回写到待排序数组中，并且出现次数-1，直到完成排序；</li></ol> <img src="/经典排序算法/CountSort.gif" title="countSort"><p>如果按照上述的算法（朴素的计数排序）思路来进行排序的话，还存在着如下两个问题：</p><ol><li><p>额外数组在某些情况下利用率低。例如待排序数组范围 90 ~ 99，那么额外数组的长度为99+1，这造成前0~89个数组空间的浪费。<br>要解决这个问题，可以使用（maxValue - minValue）+ 1作为额外数组的长度，以minValue作为偏移量，nums[i] - minValue来定位nums[i] 在额外数组中的位置；</p></li><li><p>朴素的计数排序不是稳定的排序，它只是简单遍历的额外数组，然后对于值不为0的元素输出其下标，若待排序数组有nums[i] == nums[j]（i &lt; j），排序之后，nums[i] == nums[j]（i &gt; j）。若是单纯的进行整数排序，排序之后交换了位置也没关系，但是如果面临现实业务（比如考试分数的排序）中，就行不通了。<br>要解决这个问题，需要对额外数组进一步操作，依次将当前位置的值和前一个位置的值相加（代码描述为：countNums[i] += countNums[i - 1]），这样额外数组中存储的值代表了元素的最终排序位置。</p> <img src="/经典排序算法/countSort.png" title="countSort"><p>输入待排序数组为[4,0,9,5,5]，经过计数之后得到上述图片的上半部分，进行处理后得到下半部分，那么下标为9的的值为5，则代表中元素9最终排序的位置为5。</p></li></ol></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[maxValue + 1];</span><br><span class="line"></span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历额外数组countNums, 将其索引回写到nums数组中</span><br><span class="line">    int sortIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        while (countNums[i] &gt; 0) &#123;</span><br><span class="line">            nums[sortIndex++] = i;</span><br><span class="line">            countNums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码如下:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 得到最小值</span><br><span class="line">    int minValue = getMinValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[(maxValue - minValue) + 1];</span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值 - 偏移量(minValue)作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value - minValue]++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // countNums[nums[i] - minValue]为 nums[i]的最终位置</span><br><span class="line">        sortArray[countNums[nums[i] - minValue] - 1] = nums[i];</span><br><span class="line">        countNums[nums[i] - minValue]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums = sortArray.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><ol><li><p>概述<br>桶排序是计数排序的升级版，降低了额外空间的大小和提高了额外空间的利用率。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定，对于桶的内部，选择何种内部排序算法也对性能有着重要的影响。为了使桶排序更加高效，需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ol></li><li><p>算法思路</p><ol><li>根据待排序数组中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数<br>，设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>选择一种排序算法，对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol> <img src="/经典排序算法/bucketSort.png" title="bucketSort"> <img src="/经典排序算法/bucketSort2.png" title="bucketSort2"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bucketSort (int[] nums) &#123;</span><br><span class="line">    bucketSort(nums, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void bucketSort(int[] nums, int bucketSize) &#123;</span><br><span class="line">    // 根据最大值和最小值计算需要的桶的个数 - 映射规则(可以选择不同的映射规则)</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125; else if (value &lt; minValue) &#123;</span><br><span class="line">            minValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到所需桶个数</span><br><span class="line">    int bucketCount = (int) (Math.floor((maxValue - minValue) / bucketSize) + 1);</span><br><span class="line">    // 创建桶</span><br><span class="line">    int[][] buckets = new int[bucketCount][0];</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到桶中</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int index = (int) Math.floor((nums[i] - minValue) / bucketSize);</span><br><span class="line">        buckets[index] = numsAppend(buckets[index], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int[] bucket : buckets) &#123;</span><br><span class="line">        if (bucket.length &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对每个桶中元素进行排序 - 采用插入排序, 可使用其他排序算法</span><br><span class="line">        bucket = insertSort(bucket);</span><br><span class="line">        // 将已经排序完的元素回写到数组中</span><br><span class="line">        for (int value : bucket) &#123;</span><br><span class="line">            nums[index++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将数据添加到桶中</span><br><span class="line">private int[] numsAppend (int[] bucketNums, int value) &#123;</span><br><span class="line">    bucketNums = Arrays.copyOf(bucketNums, bucketNums.length + 1);</span><br><span class="line">    bucketNums[bucketNums.length - 1] = value;</span><br><span class="line">    return bucketNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort）</h3><ol><li><p>概述<br>基数排序是一种非比较型整数排序算法，其原理是将整数按位数（通常是低位-&gt;高位进行分割）切割成不同的数字，然后将分割之后的数字分配到不同桶中，对桶中元素进行排序，然后依次输出桶中元素，接着按照下一个位数进行分割，反复进行上述操作，直到整个数组有序。<br>若待排序数组分割之后的位数的数值范围较小，可以不利用桶来收集分割之后的元素，可以直接采用计数排序。比如对于整数的基数排序，只需要分配固定十个桶（位数范围0~9），则直接可以基于计数排序进行。<br>基数排序既可以从高位优先进行排序（Most Significant Digit first，简称MSD），也可以从低位优先进行排序（Least Significant Digit first，简称LSD）。</p></li><li><p>算法思路</p><ol><li>得到待排序数据中的最大值，并得到最大值的位数digit；</li><li>从低位到高位依次待排序数组进行计数排序，计数排序的次数为digit；</li><li>重复第二步，直到整个数组有序。</li></ol> <img src="/经典排序算法/RadixSort.gif" title="RadixSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void radixSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值的长度(位数), 通过这个就知道需要进行几次基数排序</span><br><span class="line">    int maxDigit = getMaxDigit(nums);</span><br><span class="line">    sort(nums, maxDigit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sort (int[] nums, int maxDigit) &#123;</span><br><span class="line">    int exp = 1;</span><br><span class="line">    // 最大值的位数为maxDigit, 则代表要进行maxDigit次计数排序</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, exp *= 10) &#123;</span><br><span class="line">        countingSort(nums, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对基数排序的每位进行计数排序</span><br><span class="line">private static void countingSort (int[] nums, int exp) &#123;</span><br><span class="line">    // 开辟额外数组存在每个数字出现次数</span><br><span class="line">    int[] countNums = new int[10];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[(value / exp) % 10]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        sortArray[countNums[(nums[i] / exp) % 10] - 1] = nums[i];</span><br><span class="line">        countNums[(nums[i] / exp) % 10]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为需要基于nums再进行若干次计数排序, 所以将sortArray 赋值给nums</span><br><span class="line">    for (int i = 0; i &lt; sortArray.length; i++) &#123;</span><br><span class="line">        nums[i] = sortArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最大值的位数</span><br><span class="line">private static int getMaxDigit (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (maxValue &lt; value)</span><br><span class="line">        maxValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    // 得到最大值的位数</span><br><span class="line">    int length = 0;</span><br><span class="line">    while (maxValue != 0) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        maxValue = maxValue / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect</a><br>[2] <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/onepixel/articles/7674659.html</a><br>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重新认识时间复杂度</title>
      <link href="/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html"/>
      <url>/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html</url>
      
        <content type="html"><![CDATA[<h2 id="大o符号表示法"><a class="markdownIt-Anchor" href="#大o符号表示法"></a> 大O符号表示法</h2><p>我们假设计算机运行一行基础代码需要执行一次运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(void)&#123;</span><br><span class="line">    printf(&quot;Hello,World!\n&quot;);  //需要执行1次</span><br><span class="line">    return 0;  //需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面这段代码执行的总运算次数为2次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;  //需要执行(n+1)次, 从0 -&gt; n</span><br><span class="line">        printf(&quot;Hello,World!\n&quot;);  //需要执行n次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行的总次数为 n + 1 + n + 1次。<br>使用 T(n) 来表示算法需要执行的总的运算次数，T(n) 为一个关于输入次数n的函数。    例如上面的两段代码中：第一段代码 T(n) = 2； 第二段代码 T(n) = 2n + 2。<br>但是仅仅有T(n) 是不够的，为了估算算法需要的运行时间和简化算法分析，再一次引入时间复杂度的概念。</p><blockquote><p>定义：存在一个常数C和f(n)，使得当n &gt;= C时，有T(n) &lt;= f(n)，表示为T(n) = O(f(n))</p></blockquote><p>就那T(n) = 2n 举例来说，存在C=2，且 n&gt;=C时，总有f(n) = 2n+1 &gt; T(n) = 2n，我们可以说说f(n)的增长速度是大于或等于T(n)的，也就是说f(n)为T(n)的上界，我们就可以用f(n)的增长速度来度量T(n)的增长速度，可以表示为 T(n) = O(f(n)) = O(2n + 1)，所以我们可以说这个算法的时间复杂度为O(f(n)) = O(2n+1)，O(f(n))表示运行算法所需要执行的指令数和f(n)成正比，n表示数据规模。<br>这个f(n) 并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间随着输入n的增大的增长变化趋势，所以常数1 和 与n相乘的常数2 对增长速度的影响不明显，所以可以省略，所以时间复杂度可以简化为 O(n)。</p><img src="/重新认识时间复杂度/Defination.jpg" title="Defination"><p>显然T(n) = O(f(n)) = O(3n+1)，T(n) = O(f(n)) = O(n^2)…… 都是成立，但是T(n) = O(f(n)) = O(2n+1)的增长速度相比其他是更加接近的，所以选择了它。<br>上面所提到的T(n) = O(f(n)) 也称为&quot;大O符号表示法&quot;。<br>下面可以用一个图来展示时间复杂度随着输入n的增大的增长变化趋势。从下图可知，常数对于时间复杂度的决定性总是微乎其微的，并且描述了一个事实，当数据规模n到达了某个零界点之后，时间复杂度低的算法的执行效率一定比时间复杂度高的执行效率更高。</p><img src="/重新认识时间复杂度/comparation.png" title="comparation"><h2 id="时间复杂度推导规律"><a class="markdownIt-Anchor" href="#时间复杂度推导规律"></a> 时间复杂度推导规律</h2><ol><li>推导T(n)<ol><li>对于一个循环，假设循环体的运算执行次数为 n ，循环次数为 m，则这个循环的总执行次数为 T(n) = n * m。</li><li>对于多个循环，假设循环体的运算执行次数为 n，各个循环的循环次数分别是a，b， c…，则这个循环的总执行次数为T(n) =  n * a * b * c…。分析的时候应该由里向外分析这些循环。</li><li>对于顺序执行的语句或者算法，总的运算执行次数等于其中最大的运算执行次数。</li><li>对于条件执行的语句或者算法，总的运算执行次数等于其中路径中最大的运算执行次数。<br>综合说：从内向外进行分析，如果遇到函数调用，进行调用函数进行分析。</li></ol></li><li>T(n) -&gt; O(f(n))<br>假设我们已经得到了T(N)，即一个算法的执行次数，那么可以通过以下几个规律来简单推导：<ol><li>常数项对于函数增长速度的影响并不明显，忽略常数项。<br>T(n) = c = O(1)，c为常数；<br>T(n) = n + 1 = 1 = O(n)；</li><li>高次项对于函数的增长速度的影响是最大的，保留最高次项，忽略低次项，若最高次项有常数相乘，忽略它；<br>T(n) = n^3 + n^2 + n = O(n^3)；<br>T(n) = 3 n^3 = O(n^3)；<br>Ps：忽略低次项只适合于规模n属于同一个的情况。若某个时间复杂度为O(logn + m)，n和m属于两个不同的数据规模，则不可忽略其他任何一部分。</li></ol></li></ol><p>综合说：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。</p><h2 id="时间复杂度实例"><a class="markdownIt-Anchor" href="#时间复杂度实例"></a> 时间复杂度实例</h2><ol><li><p>O(1)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum(int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for(int i = 0; i &lt;= n; i++) </span><br><span class="line">        result += i;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">void reverse(String s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    for(int i = 0; i &lt; n / 2; i++)</span><br><span class="line">        swap(s.charAt(i), s.charAt(n - 1 - i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n^2)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void selectionSort(int[] arr, int n) &#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">        for(int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内层if语句的执行次数为 (n - 1) +  (n - 2) +  (n - 3) …. + 0 = (0 + n - 1) * n / 2 =&gt; O(n^2)。</p></li><li><p>O(logn)时间复杂度实例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int n, int target) &#123;</span><br><span class="line">    int l = 0, r = n - 1;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (arr[mid] == target) return mid;</span><br><span class="line">        if (arr[mid] &gt; target) r = mid - 1;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>① 在n个元素中查找<br>② 在 n / 2个元素中查找<br>③ 在 n / 4 个元素中查找<br>…….<br>④ 在1个元素中查找<br>n经过几次&quot;除以2&quot;操作后，等于1？ log(2)n = O(logn)<br>也可以这样计算，设操作次数为t，则 2^t &lt;= n，t = log(2)n，得出为 O(logn)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String intToString(int num) &#123;</span><br><span class="line">    String s = &quot;&quot;;</span><br><span class="line">    while(num &gt; 0) &#123;</span><br><span class="line">        s += &quot;0&quot; + num % 10;</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    s = reverse(s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>n经过几次&quot;除以10&quot;操作后，等于1？ log(10)n = O(logn)<br>为什么log(10)n和 log(2)n 的时间复杂度都可以视为O(logn)呢？ 主要是因为对数换底公式：</p> <img src="/重新认识时间复杂度/fomula.png" title="fomula"><p>所以具体对数底是如何并不重要。</p></li><li><p>O(nlogn)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hello (int n) &#123;</span><br><span class="line">    for(int sz = 1; sz &lt; n; sz += sz)</span><br><span class="line">        for(int i = 1; i &lt; n; i++) </span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(sqrt(n))时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isPrime(int n) &#123;</span><br><span class="line">    for(int x = 2; x * x &lt;= n; x++) &#123;</span><br><span class="line">        if(n % x == 0)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>X初始化为2，每次增加1，直到遍历到sqrt(n)就退出循环。</p></li><li><p>递归调用时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int l, int r, int target) &#123;</span><br><span class="line">    if(l &gt; r)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        if (arr[mid] == target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (arr[mid] &gt; target) </span><br><span class="line">            return binarySearch(arr, l, mid - 1, target);</span><br><span class="line">        else </span><br><span class="line">            return binarySearch(arr, mid + 1, r, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，最多只进行一次递归调用，这时我们需要计算中递归调用的最大深度是多少，由实例4可知，由n-&gt;1，递归的最大深度为logn，则时间复杂度为O(logn)。<br>总结如下：如果在递归函数中，只进行一次递归调用，递归深度为depth，在每个递归函数中，时间复杂度为T，则总体的时间复杂度为O(T*depth)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    if (n == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    return f(n - 1) + f(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，会进行两次递归调用，此时应该更加关注的是计算调用的次数，通常可以通过画递归树的方式来计算调用次数。时间复杂度为O(2^n)。</p> <img src="/重新认识时间复杂度/tree.png" title="tree"><p>递归树层数为4，2^0 + 2^1+ 2^2 + 2^3 = 2^n -1 =15</p></li><li><p>均摊复杂度分析实例</p><p>例如对于Java中ArrayList数组，它是一个动态数组，此类的动态数组在每个的插入操作为O(1)的时间复杂度，但是当超过当前数组容量时会进行数组扩容操作，扩容操作的时间复杂度为O(n)，但是就算在插入操作中存在着O(n)时间复杂度的扩容操作，也不能够说插入操作的时间复杂度为O(n)，它仍然是O(1)的时间复杂度，因为O(n)时间复杂度的扩容操作均摊到了前面n次的O(1)操作之中了。</p> <img src="/重新认识时间复杂度/resize.png" title="resize"><p>每个的删除操作为O(1)的时间复杂度，那么假设当剩余元素为当前数组容量的一半时会进行数组缩小操作，那么此时也可以使用如上所说明的均摊复杂度分析。</p> <img src="/重新认识时间复杂度/resize2.png" title="resize2"><p>但是如上可能会存在复杂度震荡问题，即当在数据扩容和缩小的零界点交替进行添加和删除操作会使得时间复杂度退化为O(n)。</p> <img src="/重新认识时间复杂度/resize3.png" title="resize3"></li><li><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符数组按照字典序排序，整个操作的时间复杂为？<br>解析：<br>假设最长的字符串长度为s；整个数组中有n个字符串。<br>对每个字符串排序时间复杂度为O(slogs)，将数组中的每一个字符串按照字母序排序：O(n<em>slogs)，将整个字符串数组按照字典序排序：O(s</em>nlogn)，其中s<em>nlogn为排序所需要的比较次数。<br>综上所述，整个时间复杂度为：O(n</em>slogs) + O(s<em>nlogn) = O(n</em>slogs + s<em>nlogn) =<br>O(ns</em>(logs + logn))</p></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li><p>&quot;O&quot;是渐进上界符号（Big-oh - 欧米可荣），用它评估算法的复杂度得到的只是问题规模充分大时的一个上界，但是这个定义是严格的学术定义，按照该定义来说，归并排序算法的时间复杂度是O(nlogn)，并且是O(n^2)，这种说法是正确的，因为O(n^2)也是满足条件的一个上界。但是通常来讲，我们使用&quot;O&quot;来表示算法执行的最低上界。</p></li><li><p>下图展示了不同时间复杂度随着数据规模n的增长的所需要执行指令数的增长速度。<img src="/重新认识时间复杂度/comparation2.png" title="comparation2"></p></li><li><p>数据规模的概念<br>如果想要在1s之内解决问题：<br>O(n^2) 的算法可以处理大约10^4级别的数据；<br>O(n)的算法可以处理大约10^8级别的数据；<br>O(nlogn)的算法可以处理大约10^7级别的数据。</p></li><li><p>空间复杂度<br>多开一个辅助数据：O(n)；多开一个辅助的二维数组：O(n^2)；多开常数空间：O(1)；递归调用具有空间代价</p></li></ol><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://www.jianshu.com/p/f4cca5ce055a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f4cca5ce055a</a><br>[2] <a href="https://blog.csdn.net/so_geili/article/details/53353593" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/so_geili/article/details/53353593</a><br>[3] <a href="https://coding.imooc.com/class/chapter/82.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/chapter/82.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小小String对象大大奥秘</title>
      <link href="/%E5%B0%8F%E5%B0%8FString%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%A4%A7%E5%A5%A5%E7%A7%98.html"/>
      <url>/%E5%B0%8F%E5%B0%8FString%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%A4%A7%E5%A5%A5%E7%A7%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串？</h2><p>字符串是由引号所括起来的一系列字符序列。例如&quot;String&quot;，&quot;Hello&quot;就为一个字符串</p><h2 id="string-的不可变性"><a class="markdownIt-Anchor" href="#string-的不可变性"></a> String 的不可变性</h2><p>&quot;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何操作都会生成新的对象“。</p><ol><li>固定不变 - 从String 对象的源码中可以看出，String 类声明为 final，且它的属性和方法都被 final 所修饰</li><li>任何操作都会生成新对象 - String:: subString()，String::concat() 等方法都会生成一个新的String对象，不会在原对象上进行操作<br>从下面String源码部分中很容易得到上面的结论：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** String 类源码 */</span><br><span class="line">public final class String </span><br><span class="line">     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line">     *</span><br><span class="line">     * A String instance is written into an ObjectOutputStream according to</span><br><span class="line">     * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line">     */</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用一段代码来揭示这个过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String start = &quot;Hello&quot;;  // 1</span><br><span class="line">        String end = start.concat(&quot; World!&quot;); // 2</span><br><span class="line">          //String end = start + &quot; World!&quot;  </span><br><span class="line">        System.out.println(end); // 3</span><br><span class="line">             System.out.println(start); // 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">Hello World!</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>在这段代码中，没有改变任何对象。首先在第一个代码中，会在堆内存中创建一个新的String 对象，并把它的引用赋值给 start，接着在第二个调用String:: concat()方法对字符串进行拼接，<strong>此时会创建一个新的String 对象，该对象是&quot;Hello&quot; 和 “World” 的串联</strong>。就如String:: concat() 源码所示，第三个/四个代码的输出结果分别为：“Hello World!”, “World”。并且操作符 &quot; + &quot;完成了和String:: concat() 类似的事 - &gt; 操作符 “+” 算是一个语法糖，查看编译之后的字节码可以知道最终会调用StringBuilder:: append() 来完成字符串的拼接。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** concat() 源码 */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length();  // 拼接的字符串参数长度为0, 返回本身</span><br><span class="line">        if (otherLen == 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length;</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true); // 创建一个新String对象来存储拼接之后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可变性设计的初衷"><a class="markdownIt-Anchor" href="#不可变性设计的初衷"></a> 不可变性设计的初衷</h2><ol><li>字符串常量池的需要。String对象的不可变性为字符串常量池的实现提供了基础，使得常量池便于管理和优化。</li><li>多线程安全。同一个字符串对象可以被多个线程共享。</li><li>安全性考虑。字符串应用场景众多，设计成不可变性可以有效防止字符串被有意篡改。</li><li>由于String对象的不可变性，可以对其HashCode进行缓存，可以作为HashMap，HashTable等集合的key 值。</li></ol><h2 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h2><p>很多文章都提及到字符串常量池是String对象的集合，这种说法很接近了，但是更准确来说，它是 <strong>String 对象引用的集合</strong> （网上关于这个众说纷纭，我更加倾向于存储的是引用的集合~ 若有错误了请指出! 谢谢~ ps: 又看了一遍书，发现在JDK 6以前，永久代中的字符串常量池是存放String 对象实例的，但是JDK 7之后，字符串常量池移到了堆中，String 对象实例也是在堆中的，那字符串常量池只需要保存String 对象的引用就行啦~ 详见《深入理解Java虚拟机》 P63）。 虽说String 是不变的，但是它还是和Java中的其他对象一样，是分配在堆中的，所以说 <strong>String 对象存在于堆中，字符串常量池存放了它们的引用</strong>。因为 String 对象是不可变的，所以多个引用 “共享” 同一个String 对象是安全的，这种安全性就是 字符串常量池所带来的。</p><h3 id="字面量的形式创建字符串"><a class="markdownIt-Anchor" href="#字面量的形式创建字符串"></a> 字面量的形式创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;; // 1</span><br><span class="line">        String two = &quot;someString&quot;; // 2</span><br><span class="line"></span><br><span class="line">        System.out.println(one.equals(two));  // String 对象是否相同内容</span><br><span class="line">        System.out.println(one == two);  // String 对象是否相同的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>执行完上面的第一句代码之后，会在堆上创建一个String 对象，并把String 对象的引用存放到字符串常量池中，并把引用返回给 one，那当第二句代码执行时，字符串常量池已经有对应内容的引用了，直接返回对象引用给 two。one.equals(two) / one == two 都为true。 图形化如下所示：<img src="/小小String对象大大奥秘/stringLiterals1.jpg" title="stringLiterals1"></p><h3 id="new-创建字符串"><a class="markdownIt-Anchor" href="#new-创建字符串"></a> new 创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(one.equals(two));</span><br><span class="line">        System.out.println(one == two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>在使用 new关键字时的情况会有稍微不同，关于这两个字符串的引用任然会存放字符串常量池中，但是关键字 new使得虚拟机在运行时会创建一个新的String对象，而不是使用字符串常量池中已经存在的引用，此时 two 指向 堆中这个新创建的对象，而one 是常量池中的引用。 one.equals(two) 为 true，而 one == two 都为false。<img src="/小小String对象大大奥秘/stringLiterals2.jpg" title="stringLiterals2"></p><p>如果想要one，two都引用同一个对象，则可以使用 String:: intern()方法 - 当调用intern()方法时，如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中它的引用，如果没有，那就将它的引用保存一份到字符串常量池中，然后直接返回这个引用。这个方法是有返回值的，是返回引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String one = &quot;someString&quot;;</span><br><span class="line">String two = new String(&quot;someString&quot;); // 仍指向堆中new 出的新对象</span><br><span class="line">String three = two.intern(); </span><br><span class="line">System.out.println(one.equals(two)); // true</span><br><span class="line">System.out.println(one == two); // false </span><br><span class="line">System.out.println(one == three); // true</span><br><span class="line">System.out.println(two == three); // false</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a class="markdownIt-Anchor" href="#垃圾收集"></a> 垃圾收集</h3><p>当一个对象没有引用指向时，垃圾收集器便会对它进行收集操作。看下面的一个事例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        one = two = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 one = two = null时，只有一个对象会被回收，String 对象总是有来自字符串常量池的引用，所以不会被回收<img src="/小小String对象大大奥秘/stringLiterals3.jpg" title="stringLiterals3"></p><h2 id="string-对象的创建和字符串常量池的放入"><a class="markdownIt-Anchor" href="#string-对象的创建和字符串常量池的放入"></a> String 对象的创建和字符串常量池的放入</h2><p>上面嘀咕了那么久，那到底什么时候会创建String 对象？什么时候引用放入到字符串常量池中呢？先需要提出三个常量池的概念：</p><ol><li>静态常量池：常量池表（Constant Pool table，存放在Class文件中），也可称作为静态常量池，里面存放编译器生成的各种字面量和符号引用。其中有两个重要的常量类型为CONSTANT_String_info和CONSTANT_Utf8_info类型（具体描述可以看看《深入理解Java虚拟机》的p 219 啦~）</li><li>运行时常量池：运行时常量池属于方法区的一部分，常量池表中的内容会在类加载时存放在方法区的运行时常量池，运行时常量池相比于Class文件常量池一个重要特征是 动态性，运行期间也可以将新的常量放入到 运行时常量池中</li><li>字符串常量池：在HotSpot 虚拟机中，使用StringTable来存储 String 对象的引用，即来实现字符串常量池，StringTable 本质上是HashSet<string>，所以里面的内容是不可以重复的。一般来说，说一个字符串存储到了字符串常量池也就是说在StringTable中保存了对这个String 对象的引用</string></li></ol><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>有了上面的概念之后，便可来描述下述过程了<br>首先给出结论，<strong>“在类的解析阶段，虚拟机便会在创建String 对象，并把String对象的引用存储到字符串常量池中”。</strong></p><ol><li>当*.java 文件 编译为*.class 文件时，字符串会像其他常量一样存储到class 文件中的常量池表中，对应于CONSTANT_String_info和CONSTANT_Utf8_info类型；</li><li>类加载时，会把静态常量池中的内容存放到方法区中的运行时常量池中，其中CONSTANT_Utf8_info类型在类加载的时候就会全部被创建出来，即说明了加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，但是此时StringTable（字符串常量池）并没有相应的引用，在堆中也没有相应的对象产生；</li><li>遇到ldc字节码指令（该指令将int、float或String型常量值从常量池中推送至栈顶）之前会触发解析阶段，进入到解析阶段，若在解析的过程中发现StringTable已经有与CONSTANT_String_info一样的引用，则返回该引用，若没有，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；</li></ol><h3 id="具体示例"><a class="markdownIt-Anchor" href="#具体示例"></a> 具体示例</h3><p>下面给出几个具体实例，来说下这个过程：</p><ul><li><strong>字面量的形式创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    String name = &quot;HB&quot;;</span><br><span class="line">    String name2 = &quot;HB&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 = String  #14 </span><br><span class="line">#14 = utf8    HB</span><br><span class="line">……</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=3, args_size=1</span><br><span class="line">         0: ldc           #2  // String HB</span><br><span class="line">         2: astore_1     </span><br><span class="line">         3: ldc           #2  // String HB</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>当编译成字节码文件后，字面量&quot;HB&quot; 会存储到常量类型 CONSTANT_Utf8_info中，类加载时，其也会随之加载到方法区中的运行时常量池中，接下来可以用此来在StringTable查询是否有匹配的String 对象引用（当然只是简化的说法，具体CONSTANT_Utf8_info还指向一个Symbol对象~）；遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；astore_1指令把返回的引用存到本地变量name； 遇到二个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）已经有与CONSTANT_String_info一样的引用，则直接返回即可，并通过astore_2 指令将其返回的引用保存到本地变量 name2中</p><ul><li><strong>new 创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test2&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    String name = new String(&quot;HB&quot;);</span><br><span class="line">    String name2 = new String(&quot;HB&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: new           #2  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3 // String HB</span><br><span class="line">         6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #2 // class java/lang/String</span><br><span class="line">        13: dup</span><br><span class="line">        14: ldc           #3 // String HB</span><br><span class="line">        16: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure><p>使用了关键字new后，会有稍微不同，new 指令会在堆中创建一个新的String 对象，并将其引用值压入栈顶，通过dup指令 复制栈顶的新对象的引用值并把复制值压入栈顶，本地变量name 所保存的值就为该引用值；接下来在遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用, 所以在运行时，会创建两个String对象哦~接下来的过程和前面的差不多，就不一一叙述啦！</p><ul><li><strong>其他重要值得关注的示例</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;hb&quot;);</span><br><span class="line">String s2 = &quot;hb&quot;;</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line">String s3 = s1.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s2 == s3);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s5 = &quot;hb&quot; + &quot;haha&quot;;  // 虚拟机会优化进行优化, 当成一个整体 &quot;hbhaha&quot;成立, 而不会用StringBuild::append()处理</span><br><span class="line">String s6 = &quot;hbhaha&quot;;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String temp = &quot;hb&quot;;</span><br><span class="line">String s7 = temp + &quot;haha&quot;; // 采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s7 == s6);  // false</span><br><span class="line">String s8 = s7.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s8 == s6); // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s9 = new String(&quot;hb&quot;) + new String(&quot;haha&quot;);  //采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s9 == s6); // false</span><br><span class="line">String s10 = s9.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s10 == s6); // true</span><br><span class="line"></span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s11 = new StringBuilder(&quot;hello&quot;).append(&quot; world&quot;).toString();</span><br><span class="line">System.out.println(s11 == s11.intern()); // true - 一个很特殊的例子, intern()方法会把s11引用放入到字符串常量池中</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s12 = new StringBuilder(&quot;hello&quot;).append(&quot; java&quot;).toString();</span><br><span class="line">String s13 = &quot;hello java&quot;;</span><br><span class="line">System.out.println(s12 == s12.intern()); // false - 一个很特殊的例子, intern()方法返回s13 在常量池中的引用</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>String 对象存在于堆中，字符串常量池存放了它们的引用</li><li>字符串常量池存储String对象的引用，且是全局共享的，相同的字符串都将指向同一个字符串对象</li><li>运行时创建的字符串（new）关键字 和 “” (字面量形式) 创建的字符串存在不同</li><li>检查字符串是否相同的最好方法是 equal()</li><li>可以通过String:: intern() 方法从常量池中得到String对象的引用，或 将String 对象的引用存入到 字符串常量池中</li><li>上述所有的实验都是在JDK 8 HotSpot虚拟机下进行的，在JDK 7 中HotSpot，字符串常量池移到了堆中哦~，所以不同JDK版本，不同虚拟机下可能存在差异</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html" rel="external nofollow noopener noreferrer" target="_blank">https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>[2] <a href="https://www.iteye.com/blog/rednaxelafx-774673#comments" rel="external nofollow noopener noreferrer" target="_blank">https://www.iteye.com/blog/rednaxelafx-774673#comments</a><br>[3] <a href="https://www.zhihu.com/question/55994121/answer/408891707" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/55994121/answer/408891707</a><br>[4] <a href="https://www.cnblogs.com/Kidezyq/p/8040338.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/Kidezyq/p/8040338.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 缓存设计 - 缓存穿透/雪崩/击穿</title>
      <link href="/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF.html"/>
      <url>/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓存收益和成本"><a class="markdownIt-Anchor" href="#缓存收益和成本"></a> 缓存收益和成本</h2><ol><li>缓存收益</li></ol><ul><li>加速读写</li><li>减低后端负载</li></ul><ol start="2"><li>缓存成本</li></ol><ul><li>数据不一致问题：缓冲层和数据层保存的数据可能不一致</li><li>代码维护成本变高，多了一层缓存逻辑</li><li>运维成本，例如 Redis cluster的维护</li></ul><ol start="3"><li>使用场景</li></ol><ul><li>减低后端负载：对高消耗的SQL结果进行缓存，例如join结果集/分组统计结果</li><li>加速请求响应</li><li>大量写合并为批量写，如计数器先Redis累加再批量写到DB</li></ul><h2 id="缓存更新策略"><a class="markdownIt-Anchor" href="#缓存更新策略"></a> 缓存更新策略</h2><ol><li>LRU(Least Recently Used)，根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，则延迟其淘汰时间” - <a href="https://blog.csdn.net/yunhua_lee/article/details/7599671" rel="external nofollow noopener noreferrer" target="_blank">LRU缓存更新</a></li><li>LFU(Least Frequently Used)根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”- <a href="https://blog.csdn.net/yunhua_lee/article/details/7648549" rel="external nofollow noopener noreferrer" target="_blank">LFU缓存更新</a></li><li>FIFO ，根据&quot;先进先出&quot; 思想来更新缓存数据</li><li>超时剔除 - expire</li><li>主动更新 - 开发控制生命周期</li><li>扩展：缓存污染 - 缓存污染降低了缓存的使用率，把不常用的数据读取到缓存，同时会把常用的数据移出缓存，这样会直接降低系统的数据命中率</li></ol><h2 id="缓存穿透问题"><a class="markdownIt-Anchor" href="#缓存穿透问题"></a> 缓存穿透问题</h2><ol><li><p>定义：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询），导致大量请求发到了数据库上。<img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/缓存穿透.png" title="缓存穿透"></p></li><li><p>解决方法</p></li></ol><ul><li>缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，不超过5分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库。<br><strong>存在的问题：</strong><br>（1）需要更多的键，所以通常设置较短过期时间<br>（2）缓存层和存储层数据&quot;短期&quot;不一致</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/设置NULL.jpg" title="设置NULL"><ul><li>布隆过滤器拦截：<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。例如Redis可以使用bitMap来实现布隆过滤器</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/布隆过滤器.jpg" title="布隆过滤器"><h2 id="缓存雪崩问题"><a class="markdownIt-Anchor" href="#缓存雪崩问题"></a> 缓存雪崩问题</h2><ol><li>定义：缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务（可能是机器宕机或大量的缓存(key)在同一时间失效 - 过期），于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</li><li>解决方法</li></ol><ul><li>保证缓存层服务高可用性：即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，比如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</li><li>依赖隔离组件为后端限流并降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>数据预热：可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul><h2 id="缓存击穿问题"><a class="markdownIt-Anchor" href="#缓存击穿问题"></a> 缓存击穿问题</h2><ol><li>定义：一个存在的热点key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到数据库，造成瞬时数据库请求量大压力骤增。</li><li>解决方法</li></ol><ul><li>互斥锁</li><li>永不过期</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a><br>[2] <a href="https://www.cnblogs.com/George1994/p/10668889.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/George1994/p/10668889.html</a><br>[3] <a href="https://www.jianshu.com/p/b57d0773ee96" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b57d0773ee96</a><br>[4] <a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster 故障转移</title>
      <link href="/Redis-Cluster-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.html"/>
      <url>/Redis-Cluster-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="故障发现"><a class="markdownIt-Anchor" href="#故障发现"></a> 故障发现</h2><ol><li>通过ping/pong消息来实现故障发现：不需要sentinel</li><li>主观下线：某个节点认为另一个节点不可用，“偏见” <img src="/Redis-Cluster-故障转移/主观下线.png" title="主观下线"></li><li>客观下线：当半数以上持有槽的主节点都标记了某节点主观下线<img src="/Redis-Cluster-故障转移/客观下线.png" title="客观下线"></li></ol><ul><li>故障链表可以维护了每个节点对其他节点的&quot;看法&quot;，即认为主观下线与否</li><li>尝试客观下线流程如下：<img src="/Redis-Cluster-故障转移/客观下线流程.png" title="客观下线流程"></li></ul><h2 id="故障恢复"><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h2><ol><li>资格检查<br>检查每个从节点与故障主节点的断线时间。超过cluster-node-timeout * cluster-slave-validity-factor(默认10)则取消资格。</li><li>准备选举时间<br>准备选举时间，偏移量更大的从节点拥有延迟更小的选举时间，尽量保证从节点与主节点的数据一致性<img src="/Redis-Cluster-故障转移/选举时间.png" title="选举时间"></li><li>选举投票<img src="/Redis-Cluster-故障转移/选举投票.png" title="选举投票"></li><li>替换主节点</li></ol><ul><li>当前从节点取消复制变为主节点（slaveof no one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给新的主节点</li><li>向集群广播自己的pong消息，表明已经替换了故障主节点</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster 重定向问题 - Moved/Ask重定向</title>
      <link href="/Redis-Cluster-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98-Moved-Ask%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
      <url>/Redis-Cluster-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98-Moved-Ask%E9%87%8D%E5%AE%9A%E5%90%91.html</url>
      
        <content type="html"><![CDATA[<p>相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。</p><h2 id="moved-重定向"><a class="markdownIt-Anchor" href="#moved-重定向"></a> Moved 重定向</h2><img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved.png" title="Moved"><ol><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。<br>从下面可以看出 php 的槽位9244不在当前节点中，所以会重定向到节点 192.168.2.23:7001中。redis-cli会帮你自动重定向（如果没有集群方式启动，即没加参数 -c，redis-cli不会自动重定向），并且编写程序时，寻找目标节点的逻辑需要交予程序员手动完成。<br><em>cluster keyslot keyName</em>  # 得到keyName的槽<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved2.png" title="Moved2"></li></ol><h2 id="ask-重定向"><a class="markdownIt-Anchor" href="#ask-重定向"></a> ASK 重定向</h2><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/ASK.png" title="ASK"></p><h2 id="smart客户端"><a class="markdownIt-Anchor" href="#smart客户端"></a> smart客户端</h2><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来减低复杂性，追求更好的性能。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。<br>实现原理：</p><ol><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/映射关系.png" title="映射关系"></li><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/命令操作流程.png" title="命令操作流程"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster 集群伸缩</title>
      <link href="/Redis-Cluster-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9.html"/>
      <url>/Redis-Cluster-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9.html</url>
      
        <content type="html"><![CDATA[<h2 id="集群伸缩"><a class="markdownIt-Anchor" href="#集群伸缩"></a> 集群伸缩</h2><p>在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动</p><h2 id="集群扩容"><a class="markdownIt-Anchor" href="#集群扩容"></a> 集群扩容</h2><ol><li>准备新节点，把新节点配置为集群模式，相关配置信息和其他节点统一，启动后新节点是孤立节点，和集群之间还没有联系</li><li>使用 <em>cluster meet newNodeIP newNodePort</em> 把新节点加入到集群中，当然也可以使用官方的 redis-trib.rb的 相关命令来加入新节点（需要配置Ruby 环境~）。节点加入集群后，可以有两个作用：1. 为它迁移槽和数据实现扩容 ；2. 作为从节点负责故障转移</li><li>若新加入的节点大于一个，还可以进行主从分配， <em>cluster replicate nodeId</em></li><li>迁移槽和数据</li></ol><ul><li>制订迁移计划，每个节点要迁移多少个槽给新节点</li></ul><img src="/Redis-Cluster-集群伸缩/集群扩容.png" title="集群扩容"><ul><li>开始迁移操作<br> a. 对目标节点： <em>cluster setslot {slot} importing {sourceNodeId}</em>  让目标节点准备导入槽的数据<br> b. 对源节点： <em>cluster setslot {slot} migrating {targetNodeId}</em> 让源节点准备迁出槽的数据<br> c. 源节点循环执行  <em>cluster getkeysinslot {slot} {count}</em> 每次获取count个属于槽的键<br> d. 在源节点执行 <em>migrate {targetIp} {targetPort} key 0 {timeout}</em> 命令把指定key迁移，0 表示数据库0<br> e. 重复执行步骤 3 ~ 4直到槽下所有的键数据迁移到目标节点<br> f. 向集群内所有主节点发送  <em>cluster setslot {slot} node {targetNodeId}</em> 命令，告诉所有主节点 槽分配给了目标节点   <img src="/Redis-Cluster-集群伸缩/slot迁移.png" title="slot迁移"></li></ul><p>  上述的迁移操作很是繁琐，可以使用官方提供的redis-trib.rb的相关命令进行操作。使用 redis-trib.rb reshard IP:Port 进行交互模式来完成槽的移动  - <a href="https://www.jianshu.com/p/21f67bd739cc" rel="external nofollow noopener noreferrer" target="_blank">redis-trib工具使用</a></p><h2 id="集群收缩"><a class="markdownIt-Anchor" href="#集群收缩"></a> 集群收缩</h2><ol><li>下线集群节点之前，需要看节点是否持有槽，即是否有数据，若有，则需要迁移到其他节点<br><em>redis-trib.rb reshard --from {downNodeId} --to {migrateNodeId} --slots {slotNumber}  IP:Port</em>，其中的 IP:Port，任意一个节点的 IP:Port都行哦~<img src="/Redis-Cluster-集群伸缩/集群收缩.png" title="集群收缩"></li><li>通知其他所有节点忘记下线节点，<em>cluster forget {downNodeId}</em>_ 或者 <em>redis-trib.rb del-node IP:Port {forgetNodeId}</em> 。若有主从复制，要先下线从节点哦~ <img src="/Redis-Cluster-集群伸缩/集群收缩2.png" title="集群收缩2"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法 - 基于《算法》第四版</title>
      <link href="/KMP%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.html"/>
      <url>/KMP%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2><ol><li>规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)</li><li>基本思想：当出现不匹配时，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配），根据这些已经知晓的内容决定  <strong>在出现不匹配时，模式应在处于哪个位置和文本的下一个字符比较 - 即找到已知晓内容和模式的最长公共前缀（利用模式去匹配已知晓的内容）</strong></li></ol><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><p>看《算法》的时候，有点部分真的太简洁了，看的晦涩难懂( 是我太菜了~ /(ㄒoㄒ)/~~） ，关注一下几个要点，要结合书中内容看可能会有新的理解</p><ol><li><p>指向文本的指针 i 永远不会回退，不会重复扫描文本，只有模式的指针 j 会进行回退。</p></li><li><p>有限状态机（DFA）只和 模式 有关，所以只要计算出了一个 模式的有限状态机（DFA），就可以匹配不同的文本。</p></li><li><p>DFA[txt.charAt(i)][j] = next， 表示 当前状态 j 时，遇到 文本字符 txt.charAt(i) （即 txt.charAt(i) 和 pat.charAt(j)进行比较）后的下一个状态是 next ( 即模式的指针 j 需要回退/前进到 next 处 和 文本字符 txt.charAt(i + 1)进行比较) 。</p></li><li><p>在一个状态中，要确定状态会进行何种转移，需要知道 <strong>当前状态</strong> 和 <strong>遇到的字符</strong>。</p></li><li><p>构造DFA：匹配成功时，即txt.charAt(i) == pat.charAt(j)，DFA[txt.charAt(i)][j] = j +1； 匹配失败时，模式指针 j 的回退也不是盲目回退， 它会根据 <strong>部分已经匹配成功的字符串与模式进行匹配后所处的状态（即书上所说的 X 重启状态）</strong> 以及 <strong>当前匹配失败的输入</strong> 来决定回退到哪个位置<img src="/KMP算法-基于《算法》第四版/匹配图.png" title="匹配图">在箭头处出现了不匹配，那此时pat 指针 j 应该回退到哪个地方在和 txt 的下一个字符 A 比较呢？<br>知道 状态 j 遇到了 字符D 发生了不匹配，意味着pat的前 j  个字符串 (0… j-1)和文本的 (i - j, i - 1)是相匹配的， 就像上述所示，但是我们不用理会 txt.charAt(i-j)，因为 i - j处已经不可能出现匹配，所以  <strong>部分已经匹配成功的字符串</strong> 就为 B A B A （pat[1… j - 1]）。<br>现我们考虑 B A B A 和 模式 进行匹配会到达什么状态（所到达的状态也是书中所提到的 <strong>重启状态 X</strong>），这个过程我们也可以看成是找 <strong>部分已经匹配成功的字符串</strong>  和 <strong>模式</strong> 的 <strong>最长公共前缀</strong> 的过程。<img src="/KMP算法-基于《算法》第四版/匹配图2.png" title="匹配图2">可以看到 B A B A 和 模式 进行匹配之后到达了 状态 3，即 X =3。则可以知道 DFA[D][5] = DFA[D][3]，即在状态 5 遇到 字符 D发生不匹配时应该回退的位置 就是在状态 3 遇到 字符 D 时 应该到达的位置。 这可以对应到书中代码 DFA[C][j] = DFA[C][X]。</p></li><li><p>困扰我很久的一个 X 如何进行求得，可以将其看成一个 X[] 数组，记录了模式与 部分匹配成功的字符串（pat[1…j -1]）所达到的所有状态（书本P765，图5.3.8很好的表达了此点）。它们之间关系是一个递推关系，X[i+1]为X[j]状态 遇到 pat.charAt(j)时所到达的状态，即 X[j + 1] = DFA[pat.charAt(j)][x[j]]，X[0]初始化状态为0。 这也便是书中代码中的 X = DFA[pat.charAt(j)][X]。理解了上述6,7之后，就可以写出构造DFA的过程（当然，我对于上述6，7的说明都是基于你已经看过了《算法》中字符串查找部分哦~）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] DFA;</span><br><span class="line">public void generateDFA(String pat)&#123;</span><br><span class="line">        int M = pat.length();</span><br><span class="line">        int R = 256;  // ASCII字符不会操过256种</span><br><span class="line">        DFA = new int[R][M];</span><br><span class="line">        // 初始化状态0, 在状态0只有遇到了pat.charAt(0)才会向前推进, 遇到其他为0(java默认初始化数组为0)</span><br><span class="line">        DFA[pat.charAt(0)][0] = 1;</span><br><span class="line">        int X = 0;  // 初始化重启状态为0</span><br><span class="line">        for (int j = 1; j &lt; M; j++)&#123;  // 构造DFA数组过程</span><br><span class="line">           for (int c = 0; c &lt; R; c++)</span><br><span class="line">          // 状态j遇到字符c不匹配时,把重启状态X遇到字符c到达哪个状态赋值DFA[c][j]</span><br><span class="line">                DFA[c][j] = DFA[c][X];</span><br><span class="line">           DFA[pat.charAt(j)][j] = j + 1;  // 匹配成功, 状态向前推进</span><br><span class="line">           X = DFA[pat.charAt(j)][X];  // 部分已经成功匹配字符串中增加了pat.charAt(i), 需要更新重启状态X,即它们的最长重叠字符会发生变化</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>我们已经计算出了DFA，下面是利用DFA来搜索文本的算法 - 结合书本P498 图5.3.7理解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int search(String txt) &#123;</span><br><span class="line">   int M = pat.length();</span><br><span class="line">   int N = txt.length();</span><br><span class="line">   int i,j;</span><br><span class="line">    // pat 的初始态为 0 - 模拟有限状态机运行</span><br><span class="line">   for (i = 0,j = 0; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">        // 当前是状态 j，遇到字符 txt[i]，</span><br><span class="line">        // pat 应该转移到哪个状态？</span><br><span class="line">        j = dp[txt.charAt(i)][j];</span><br><span class="line">        // 如果达到终止态，返回匹配开头的索引</span><br><span class="line">        if (j == M) return i - M;</span><br><span class="line">   &#125;</span><br><span class="line">   // 没到达终止态，匹配失败</span><br><span class="line">   return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>结合上面两部分就可以得到具体的KMP算法啦！ （ 具体参考书籍上的算法哦</p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>要使用KMP算法进行匹配，重要的是求出 DFA 数组，而要求出正确的得到DFA数组，格外需要关注（难理解）的是重启状态X和重启状态X的转移，即为每次发生匹配时，模式 和 pat[1…j]的最长公共前缀。只要得到了DFA数组之后，模拟有限状态机运行就可以进行匹配操作了。</li><li>对于长度为M的模式字符串和长度为N的文本，KMP查找算法访问字符串不会超过 N + M个。</li><li>就算书上所提的一样，KMP算法为最坏情况提供的线性级别运行时间保证的一个理论成果，在实际运用中，它比暴力算法的速度优势并不明显</li></ol><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="https://judes.me/tech/2016/04/10/kmp.html" rel="external nofollow noopener noreferrer" target="_blank">https://judes.me/tech/2016/04/10/kmp.html</a><br>[2] <a href="https://book.douban.com/subject/19952400/discussion/59623403/" rel="external nofollow noopener noreferrer" target="_blank">https://book.douban.com/subject/19952400/discussion/59623403/</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/83334559" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/83334559</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster学习</title>
      <link href="/Redis-Cluster%E5%AD%A6%E4%B9%A0.html"/>
      <url>/Redis-Cluster%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称当个Redis可以使用10万并发），高可用问题（部分节点不可达能继续处理命令）。 Redis 集群常常和主从复制结合使用。</p><h2 id="分布式数据库-数据分区"><a class="markdownIt-Anchor" href="#分布式数据库-数据分区"></a> 分布式数据库 - 数据分区</h2><img src="/Redis-Cluster学习/数据分区.png" title="数据分区"><h3 id="哈希分区"><a class="markdownIt-Anchor" href="#哈希分区"></a> 哈希分区</h3><p>假如有1~100条数据，按照哈希函数（例如 hash(key)%3），把数据分区到不同的三个数据库</p><ol><li>节点取余分区： hash(key) % nodes。若增加/减少节点，会进行大量数据迁移，例如当前有3个节点，增加了一个节点，按照新的hash(key) % 4进行计算时，很多数据需要进行移动。 建议进行 多倍扩容，例如当前有3个节点，可以扩容到6个节点，减少数据迁移量。节点取余也成为 不一致性哈希。比较适合缓存的场景</li><li>一致性哈希分区<br>能保证最小迁移数据，比较适合缓存的场景 - <a href="http://blog.codinglabs.org/articles/consistent-hashing.html" rel="external nofollow noopener noreferrer" target="_blank">一致性哈希分区</a></li><li>虚拟槽分区：Redis cluster采用此种分区方式，预设虚拟槽（slot），每个虚拟槽映射一个数据子集，每个节点管理一定数量的虚拟槽，redis 虚拟槽范围 0 ~ 16383。<br>使用分散函数（例如CRC16(keys) % slots ）计算出 keys 属于哪个槽，再根据节点所管理的槽的范围，从而确定数据属于哪个节点（节点中共享信息，若一个虚拟槽不属于当前节点，会告诉虚拟操去哪个节点去存储）</li></ol><img src="/Redis-Cluster学习/虚拟槽分区.png" title="虚拟槽分区"><h3 id="顺序分区"><a class="markdownIt-Anchor" href="#顺序分区"></a> 顺序分区</h3><p>假如有1 ~ 100条数据，按照顺序分区规则，可以把1 ~ 33，34 ~ 66，67 ~ 100分区到三个不同的三个数据库</p><h3 id="方式对比"><a class="markdownIt-Anchor" href="#方式对比"></a> 方式对比</h3><img src="/Redis-Cluster学习/分区比较.png" title="分区比较"><h2 id="cluster-架构"><a class="markdownIt-Anchor" href="#cluster-架构"></a> Cluster 架构</h2><img src="/Redis-Cluster学习/cluster架构.png" title="cluster架构"><ol><li>通过配置文件 cluster-enabled yes 将一个节点设置为一个集群节点</li><li>节点之间通过gossip协议进行通信，了解彼此的信息</li><li>将虚拟槽指派给上述节点</li><li>客户端通过 CRC16( key ) % 16383 并可知道对应的key应该到哪个虚拟槽的哪个节点进行处理</li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="配置集群节点"><a class="markdownIt-Anchor" href="#配置集群节点"></a> 配置集群节点</h3><ol><li><em>cluster-enabled yes</em>  # 配置当前节点为集群节点</li><li><em>cluster-config-file nodes-${port}.conf</em>  # 配置cluster节点自身配置文件</li><li><em>cluster-node-timeout 15000</em>  # 集群中各个节点相互通讯（ping）时，允许&quot;失联&quot;的最大毫秒数，如果超过这个时间没有得到响应，会认为该节点故障，若节点是主节点，则会进行故障转移</li><li><em>cluster-require-full-coverage yes</em>  # 若配置为 yes，则当集群中有节点不可用时，整个集群都不能提供服务，通常设置为 no</li></ol><h3 id="通过meet把每个集群节点组合成集群-集群发现"><a class="markdownIt-Anchor" href="#通过meet把每个集群节点组合成集群-集群发现"></a> 通过meet把每个集群节点组合成集群 - 集群发现</h3><ol><li><em>cluster meet ip port</em>  #当前节点去发现新的集群节点</li></ol><img src="/Redis-Cluster学习/发现集群.png" title="发现集群"><h3 id="分配槽"><a class="markdownIt-Anchor" href="#分配槽"></a> 分配槽</h3><ol><li><em>cluster addslots slot [slot…]</em>   # 为当前节点分配槽</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># addslots.sh</span><br><span class="line"># 开始槽</span><br><span class="line">start=$1</span><br><span class="line"># 结束槽</span><br><span class="line">end=$2</span><br><span class="line"># 分配端口</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">   echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">   redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 分配操作</span><br><span class="line">sh addslots 0 5461 7000</span><br><span class="line">sh addslots 5462 10923 7001</span><br><span class="line">sh addslots 10923 16383 7002</span><br></pre></td></tr></table></figure><p>在第二步中配置了6个集群节点，但是只为7000 ~ 7002分配槽，7000 ~ 7002作为master，其余作为slave节点</p><h3 id="配置主从关系"><a class="markdownIt-Anchor" href="#配置主从关系"></a> 配置主从关系</h3><ol><li><em>cluster replicate node-id</em>  # 对 node-id节点进行复制，node-id在集群启动时会进行分配。</li><li><em>cluster nodes</em>  # 查看node-id</li></ol><img src="/Redis-Cluster学习/配置主从关系.png" title="配置主从关系"><h3 id="ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"><a class="markdownIt-Anchor" href="#ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"></a> Ruby配置集群 -除了上述安装方式，官方提供了脚本进行快速集群配置</h3><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>Gossip 协议：所有节点都保存了一份元数据，当节点发生伸缩或更新时，会将最新的元数据信息传播给所有节点。 - <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">gossip协议</a><br>Redis 使用Gossip协议时采用了meet，ping，pong，fail消息进行通信</li></ol><img src="/Redis-Cluster学习/gossip协议.png" title="gossip协议"><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://blog.csdn.net/makyan/article/details/104798725" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/makyan/article/details/104798725</a><br>[2] <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/8279d6fd65bb</a><br>[3] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;LeetCode&gt;最长回文子串</title>
      <link href="/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
      <url>/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探动态规划算法</title>
      <link href="/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
      <url>/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Sentinel学习</title>
      <link href="/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html"/>
      <url>/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sentinel生产可用。sentinel作为一个独立的进程，监控多个运行的Redis 数据库。<br>主要解决主从复制发生故障时，进行手动故障转移的复杂性问题，当主节点宕机后，需要手动选择一个从节点作为新的主数节点，其他作为从节点，而利用sentinel能自动完成故障转移过程。<br>sentinel也支持集群，因为使用单个sentinel进程了监控Redis是不可靠的，容易出现单点问题</p><ul><li>即使有一些sentinel进程宕掉了，依然可以进行Redis 集群的主从切换</li><li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现Redis 集群的主从切换</li><li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于Redis 集群中的信息</li></ul><h2 id="功能和架构"><a class="markdownIt-Anchor" href="#功能和架构"></a> 功能和架构</h2><ol><li>功能<ul><li>监控Redis的运行状况</li><li>当发生故障时实现主从切换。当一个master宕机之后，从它的多个slave中投票选举中一个新的master，剩余节点作为新的master的slave</li></ul></li><li>架构</li></ol><img src="/Redis-Sentinel学习/架构图.png" title="架构图"><p>在这个架构中，sentinel节点会监控master和slave的相关信息，主要值得关注的是client与sentinel之间的交互：</p><ol><li>client首先需要知道sentinel节点集合和mastername信息，通过遍历它所知道的sentinel集合，获取到一个可用的sentinel节点</li><li>找到可用的sentinel节点之后，client通过 sentinel get-master-addr-by-name masterName 命令的得到master节点的地址和端口</li><li>得到master相关信息之后，会进行一次role/role replication验证，master节点会返回验证信息，至此client可以对master进行写入和读取</li><li>sentine也会将redis数据节点的变化通知给客户端 - 使用发布订阅模式进行通知</li><li>上述过程不是通过代理模式实现的，即上述client和master建立关系的过程通常只需执行一次即可</li></ol><h2 id="故障转移过程"><a class="markdownIt-Anchor" href="#故障转移过程"></a> 故障转移过程</h2><ol><li>当一个sentinel检测master宕机并不会马上进行故障转移（主观下线），只有当后面的sentinel也都认为master不可用并达到一定数量时（客观下线），选举出一个领导者sentinel来进行故障转移操作</li><li>选出一个slave作为master，执行 slave of one 让其成为master节点</li><li>通知其余slave做为新的master的slave</li><li>等待老的master复活，若复活成功，成为新的master的slave</li><li>通知客户端发生了主从变化</li></ol><p>实现上述故障转移依靠三个定时任务：</p><ol><li>每10s每个sentinel对master和slave执行info操作<ul><li>发现slave操作</li><li>确认主从关系</li></ul></li><li>每2s每个sentinel通过master节点的channel交换信息<ul><li>发布订阅模式</li><li>通过_sentinel_:hello频道交互</li><li>交互对节点的&quot;看法&quot;和自身信息 - 可以知道其他sentinel的相关信息或投票来确定哪个sentinel来进行故障转移<img src="/Redis-Sentinel学习/sentinel发布订阅图.png" title="sentinel发布订阅图"></li></ul></li><li>每1s每个sentinel对其他sentinel和redis执行ping<ul><li>心跳检测，失败判定依据，比如可以作为客观下线的依据。</li></ul></li></ol><h2 id="sentinel配置和启动"><a class="markdownIt-Anchor" href="#sentinel配置和启动"></a> Sentinel配置和启动</h2><ol><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel运行端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 守护进程启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># sentinel工作目录</span><br><span class="line">dir &quot;/usr/local/share/redis/redis-3.0.5/backs&quot;</span><br><span class="line"></span><br><span class="line"># sentinel 日志文件</span><br><span class="line">logfile &quot;sentinel-26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master信息 master-name ip port quorum - 当quorm个数sentinel节点认为maste</span><br><span class="line"># r失联,则执行故障转移</span><br><span class="line">sentinel monitor mymaster 192.168.2.23 6379 2</span><br><span class="line"></span><br><span class="line"># 一定时间内,master没有应答哨兵sentinel, sentinel认为master主观下线 默认30秒(ping 30 次没有ping通)</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 在进行主从切换时(故障转移),最多可以几个slave对新的master进行同步。若设置的值很小, 则同</span><br><span class="line">步需要花费很长时间, 值很大,则有很多slave应为同步复制而不可用, 也会降低master节点的性能</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移超时时间, 应用于以下情况</span><br><span class="line"># 1. 同一个sentinel对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2. 当一个slave从一个错误的master那里同步数据开始计算时间,直到slave被纠正为向正确的mast</span><br><span class="line"># er那里同步数据时</span><br><span class="line"># 3.当想要取消一个正在进行的failover所需要的时间  </span><br><span class="line"># 4.当进行failover时,配置所有slaves指向新的master所需的最大时间。不过，即使过了这个时间,</span><br><span class="line"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则进行处理</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>注：可以看到sentinel.conf配置文件主要是对master节点进行监控，通过master节点使用 info replecation 进行slave的相关信息获取，会将获取的slave信息自动添加到 sentinel.conf配置文件之中，在配置文件中的标识为：Generated by CONFIG REWRITE，需要注意的是，redis在添加slave信息的同时，也会对一些配置信息进行更改，例如sentinel down-after-milliseconds，sentinel parallel-syncs，sentinel failover-timeout会被移除，添加sentinel config-epoch，sentinel leader-epoch等配置 。</p><ol start="2"><li>启动</li></ol><p>  <em>redis-sentinel sentinel.conf</em>  # 启动sentinel<br>  <em>redis-cli -p 26379</em>  # 连接sentinel, sentinel也当成一个普通的Redis 节点来对待</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>主观下线：每个sentinel节点对Redis 节点失败的&quot;偏见&quot;，可能由于网络问题，Redis 节点不能在规定的时间内回应sentinel节点</li><li>客观下线：所有sentin节点对Redis 节点失败达成&quot;共识&quot;，即sentinel节点中认为Redis 节点可以进行客观下线的个数超过quorum的个数，此时可以真正进行故障转移操作。其中达成共识通过sentinel is-master-down-by-addr命令询问其他sentinel节点的&quot;意见&quot;来完成的</li><li>领导者选举<ul><li>原因：只需要一个sentinel节点来进行故障转移</li><li>如何：1. 每个做主观下线的sentinel节点通过sentinel is-master-down-by-addr 来询问其他sentinel节点的&quot;意见&quot;是否要对master节点进行客观下线的时候，通过也会要求将其设置为领导者；2. 收到命令的sentinel节点如果没有同意其他sentinel节点成为领导者的请求，那就同意，否则拒绝；3. 如果该sentinel节点发现自己的票数超过了sentinel集合半数且超过了quorum，那么它将成为领导者来进行故障处理；4. 如果有多个sentin节点成为领导者，则过一段时间再进行选举</li></ul></li><li>如何选择合适的slave让其成为master<ul><li>选择 slave-priority优先级最高的slave节点</li><li>若全部优先级相同，则选择复制偏移量最大（与以前的master节点数据最接近）的slave节点</li><li>若上述都不成立，则选择runId最小的节点，即启动最早的slave</li></ul></li></ol><h2 id="运维问题"><a class="markdownIt-Anchor" href="#运维问题"></a> 运维问题</h2><ol><li>主节点手动下线，进行故障转移<br>  <em>sentinel failover masterName</em></li><li>高可用的读写分离<br>sentinel只会对master节点进行故障转移，对于slave节点只有进行主观下线，所以要实现高可用的读写分离，客户端要关注slave节点的变化，例如关注以下三个消息: +switch-master: 从节点晋升为主节点，+conver-to-slave:  原主节点降为从节点，+sdown: 主观下线</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://segmentfault.com/a/1190000002680804" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002680804</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
      <url>/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave）上，数据流向是单向的 - Master -&gt; Slave。通常主数据进行数据写入操作，从数据库进行读操作，实现数据的读写分离。</p><h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2><ol><li><p>命令方式</p><ul><li><em>slaveof  slavehost</em> # 将 slavehost 将复制为当前Redis数据库的从数据库，异步操作，会将数据库的数据进行清除。<br><em>e.g., 127.0.0.1: 6380 &gt; slaveof 127.0.0.1: 6379</em>  # 127.0.0.1: 6379将会成为127.0.0.1: 6380的主数据库</li><li><em>slaveof  no one</em> # 取消当前命令执行数据库的复制，以前主数据库已经同步的数据不会清除。</li><li><em>info replication</em>  # 当前数据库是主还是从数据库的相关信息</li></ul></li><li><p>配置 - redis.conf，配置之后需重启</p><ul><li><em>slaveof  masterip masterport</em></li><li><em>slave-read-only yes</em></li></ul></li></ol><h2 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h2><p>执行完全量复制之后，主从数据库之间数据库状态已经相同了。但这个状态并非一成不变，如果主数据库执行了写操作，那么主数据库的数据库状态就会修改，并导致主从数据库状态不再一致。所以为了让主从数据库再次回到一致状态，主数据库需要对从数据库执行命令传播操作：主数据库会将自己执行的写命令，也即是造成主从数据库不一致的那条写命令，发送给从数据库执行，当从数据库执行了相同的写命令之后，主从数据库将再次回到一致状态。</p><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><img src="/Redis主从复制/主从复制.png" title="全量复制"><ol><li>复制过程<ul><li>从数据库向主数据库发送PSYNC命令 - 从2.8开始，SYNC替换成PSYNC，提供了完整重同步和部分重同步</li><li>收到PSYNC命令后，主数据库将自身的runId和offset传给从数据库，之后主数据库执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主数据库的BGSAVE命令执行完毕时，主数据库会将BGSAVE命令生成的RDB文件发送给从数据库，从数据库接收并载入这个RDB文件，将自己的数据库状态更新至主数据库执行BGSAVE命令时的数据库状态</li><li>主数据库将记录在缓冲区里面的所有写命令发送给从数据库，从数据库执行这些写命令，将自己的数据库状态更新至主数据库数据库当前所处的状态</li></ul></li><li>开销<ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>清空从数据库花费时间</li><li>从数据库加载RBD文件花费的时间，并且载入期间，从数据库可能因为阻塞而无法处理客户端请求</li></ul></li></ol><h2 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h2><img src="/Redis主从复制/部分复制.png" title="部分复制"> <ol><li>解决问题：处理从数据库断线后的重连问题。当从数据库在断线后重新连接主数据库时，如果条件允许，主数据库可以将主从数据库连接断开期间执行的写命令发送给从数据库，从数据库只要接收并执行这些写命令，就可以将数据库更新至主数据库当前所处的状态。而2.8以前，断连之后还要进行一次SYNC操作。</li><li>复制过程<ul><li>当从数据库断线后，主数据库会继续把写命令放入到复制积压缓冲区（replication backlog）中</li><li>当从数据库重新连上主数据库时，从数据库会通过PSYNC命令将自己的复制偏移量（replication offset）和主数据库的运行ID（run id）发送给主数据库，主数据库会根据这个复制偏移量和运行ID来决定对从数据库执行何种同步操作</li><li>如果从数据库发送的运行ID和当前连接的主数据库的运行ID相同，那么说明从数据库断线之前复制的就是当前连接的这个主数据库，主数据库可以继续尝试执行部分复制操作</li><li>相反，如果从数据库发送的运行ID和当前连接的主数据库的运行ID并不相同，主数据库将对从数据库执行全量复制操作</li><li>如果从数据库的复制偏移量之后的数据（也即是offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主数据库将对从数据库执行部分复制操作</li><li>相反，如果offset之后的数据已经不存在于复制积压缓冲区，那么主数据库将对从数据库执行全量复制操作</li></ul></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>复制偏移量（replication offset）：主数据库和从数据库会分别维护一个复制偏移量：<ul><li>主数据库每次向从数据库传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从数据库每次收到主数据库传播来的N个字节的数据时，就将自己的复制偏移量的值加上N<br>对比主从数据库的复制偏移量，可知道主从数据库是否处于一致状态：</li><li>如果主从数据库处于一致状态，那么主从数据库两者的偏移量总是相同的</li><li>相反，如果主从数据库两者的偏移量并不相同，那么说明主从数据库并未处于一致状态</li></ul></li></ol><img src="/Redis主从复制/复制偏移量.png" title="复制偏移量"><ol start="2"><li><p>复制积压缓冲区（replication backlog）：复制积压缓冲区是由主数据库维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主数据库进行命令传播时，它不仅会将写命令发送给所有从数据库，还会将写命令入队到复制积压缓冲区里面。因此，主数据库的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量<img src="/Redis主从复制/复制积压缓冲区.png" title="复制积压缓冲区"><br>复制积压缓冲区默认大小为1MB，如果主数据库需要执行大量写命令，又或者主从数据库断线后重连接所需的时间比较长，那么Redis的部分复制功能可能会达不到想要的效果。复制积压缓冲区的最小大小可以根据公式 second*write_size_per_second 来估算：</p><ul><li>second为从数据库断线后重新连接上主数据库所需的平均时间（以秒计算）</li><li>write_size_per_second是主数据库平均每秒产生的写命令数据量。</li><li>例如，如果主数据库平均每秒产生1 MB的写数据，而从数据库断线之后平均要5秒才能重新连接上主数据库，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理，可以通过修改repl-backlog-size配置进行设置。</li></ul></li><li><p>数据库运行ID<br>每个Redis数据库，不论主数据库还是从服务，都会有自己的运行ID。运行ID在数据库启动时自动生成，由40个随机的十六进制字符组成，例53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。<br>当从数据库对主数据库进行初次复制时，主数据库会将自己的运行ID传送给从数据库，而从数据库则会将这个运行ID保存起来。当从数据库断线并重新连上一个主数据库时，从数据库将向当前连接的主数据库发送之前保存的运行ID。</p></li></ol><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li>读写分离<ul><li>数据复制延迟</li><li>读到过期数据</li><li>从数据库故障</li></ul></li><li>主从数据库配置不一致<ul><li>maxmemory不一致：丢失数据</li><li>数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致</li></ul></li><li>规避全量复制<ul><li>第一次全量复制不可避免 - 尽量低峰（夜间）进行</li><li>避免主数据库runId不匹配导致的全量复制</li><li>避免复制积压缓冲区不足导致的全量复制 - 修改rel_backlog_size配置</li></ul></li><li>规避复制风暴<ul><li>单主数据库复制风暴 - 主数据库重启，多从数据库复制</li><li>单机器复制风暴 - 机器有多个主数据库，机器宕机，大量全量复制。避免多个主数据库部署在一个机器上</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化常见问题</title>
      <link href="/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
      <url>/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="fork操作"><a class="markdownIt-Anchor" href="#fork操作"></a> Fork操作</h2><ol><li>定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这是一种内核机制，在创建子进程并不发生复制，创建子进程后父子进程共用数据，只有在修改数据是才会创建新的空间。</li><li>Redis中需要用到fork操作的相关命令：bgsave，bgrewriteaof，查看上一次fork消耗时间：info stats</li><li>同步操作 - 会对父进程执行的业务造成影响</li><li>与内存量息息相关 - 内存越大，耗时越长，同时也与机器类型相关</li><li>改善fork：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存: maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1 。修改sysctl vm.overcommit_memory=1<br>  0  -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br> b1 -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>  2 -  表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>降低fork频率：例如放宽AOP重写的自动触发时机</li></ul></li></ol><h2 id="子进程的开销和优化"><a class="markdownIt-Anchor" href="#子进程的开销和优化"></a> 子进程的开销和优化</h2><ol><li>CPU<ul><li>开销: RDB和AOF文件的生成，属于CPU密集型</li><li>优化： 不做CPU绑定 ，不和CPU密集型一起部署</li></ul></li><li>内存<ul><li>开销: fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>硬盘<ul><li>开销：AOF和RDB文件写入，结合iostat，iotop分析</li><li>优化：不和高硬盘负载服务部署在一起，根据写入量决定磁盘类型。</li></ul></li><li>扩展：<ul><li>CPU绑定 - 进程和CPU的绑定是为了让应用获得更好的性能，进程的Affinity属性指明了进程调度器能够把这个进程调度到哪些CPU上。CPU Affinity分为2种，soft affinity和hard affinity。soft affinity仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的CPU上。hard affinity是调度器必须遵守的规则。</li><li>CPU密集型（CPU-bound），也叫计算密集型，系统运作时CPU的消耗接近100%，I/O读写可以在很短的时间完成，但是CPU的计算任务繁重。多重程序系统中，大部份时间用来做计算、逻辑判断等的程序称之CPU bound，一般而言，CPU bound的程序CPU占用率相当高。</li><li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，CPU消耗并不高。I/O bound的程序需要大量的I/O操作。</li><li>Transparent hugepage默认是被开启的以便去改善操作系统的内存管理，但是在某种情况下会造成不可预知的节点重启和性能问题</li></ul></li></ol><h2 id="aof追加阻塞"><a class="markdownIt-Anchor" href="#aof追加阻塞"></a> AOF追加阻塞</h2><ol><li><p>定义：如果AOF文件同步时间与上次同步时间相比大于2s，Redis主进程就会阻塞，等待同步完成；如果AOF文件同步时间与上次同步时间相比小于2s，Redis主进程就会返回。其实这样做的目的是为了保证文件安全性的一种策略。 <img src="/Redis持久化常见问题/AOF追加阻塞.png" title="AOF追加阻塞"></p></li><li><p>问题：</p><ul><li>主线程阻塞造成业务受影响</li><li>虽然每秒everysec刷盘策略，但是实际上不是丢失1s数据，实际有可能丢失2s数据</li></ul></li><li><p>问题定位</p><ul><li><p>Redis日志<img src="/Redis持久化常见问题/Redis日志.png" title="Redis日志"></p></li><li><p>Info Persistence中的aof_delayed_fsync,同步延迟历史总数</p></li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
      <url>/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化</p><h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2><ol><li><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行了指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB生成的文件也可作为复制媒介使用。</p></li><li><p>触发方式</p><ul><li><em>save</em>  # 客户端发出命令后，redis会生成相应的dump.rdb文件（若存在老的RDB文件，则新替老）。该命令为同步命令，进行Save 命令时，其他命令不能执行，容易发生阻塞， O(n)</li><li><em>bgsave</em> #与Save 不同的是，该命令为异步命令，会开一个子进程进行处理， O(n)</li></ul> <img src="/Redis持久化/RDB持久化.png" title="RDB持久化"> <img src="/Redis持久化/RDB持久化2.png" title="RDB持久化2"> <ul><li>利用配置文件进行触发 - 采用 bgsave方式</li></ul> <img src="/Redis持久化/RDB持久化3.png" title="RDB持久化3"> <p>  <strong>重要配置项：</strong><br>   dbfilename dump.rdb  # 指定本地数据库名<br>   dir ./   # 指定本地数据库存放目录<br>   rdbcompression yes #默认开启数据压缩，redis采用LZF压缩方式，但占用了一点CPU的时间。<br>   stop-writes-on-bgsave-error yes #出现错误是否停止写入<br>   rdbchecksum yes #是否对RDB文件进行校验</p><ul><li>全量复制 - 主从复制时会自动生成RDB文件</li><li>debug reload - 也会生成RDB文件</li><li>shutdown - Redis也会RDB文件</li></ul></li><li><p>优缺点</p><ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li><li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了 - 不可控，丢失数据。</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件 - 耗时，耗性能</li></ul></li></ol><h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2><ol><li><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></li><li><p>配置文件</p><ul><li>appendonly yes  # 开启AOF</li><li>appendfilename “appendonly-6379.aof” # 指定本地数据库名</li><li>appendfsysnc always/everysec/no # 指定更新日志条件<br>  - always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但是数据完整性比较好（慢，安全）<br>  - everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>  - no ：不同步，由OS决定何时把命令写入到文件中</li></ul> <img src="/Redis持久化/AOF持久化.png" title="AOF持久化">  <img src="/Redis持久化/AOF持久化2.png" title="AOF持久化2">  <img src="/Redis持久化/AOF持久化3.png" title="AOF持久化3"> <ul><li>为了缩小AOF文件的大小，提供了AOP重写,目的减少磁盘占用量（减少冗余）,加速恢复速度</li></ul> <img src="/Redis持久化/AOF持久化4.png" title="AOF持久化4"> <p>  <strong>重写原理</strong><br>  Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中，并没有读取旧文件，最后替换旧的aof文件。<br>  <strong>重写方式</strong><br>  a. bgrewriteaof  #异步，会开启一个子进程来进行处理<br>  b. 配置文件 - 执行bgrewriteaof<br>    auto-aof-rewrite-min-size #AOF文件重写需要的尺寸<br>    auto-aof-rewrite-percentage #AOF文件增加率<br>    当AOF文件大小是上次rewrite后大小的一倍（增加率）且文件大于64M（尺寸）时触发</p><ul><li>no-appendfsync-on-rewrite yes # 在重写时是否可以进行AOF持久化操作</li><li>aof-load-truncated yes # 在AOF文件出现错误时，是否忽略错误，尽量加载更多的数据</li><li>在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复</li></ul></li><li><p>优缺点</p><ul><li>更高的数据完整性和一致性</li><li>随着时间的增加，AOF文件会越来越大，数据恢复速度会越来越慢，可以通过重写解决</li></ul></li></ol><h2 id="持久化策略对比"><a class="markdownIt-Anchor" href="#持久化策略对比"></a> 持久化策略对比</h2><img src="/Redis持久化/持久化对比.png" title="持久化对比"> <h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/itdragon/p/7906481.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/itdragon/p/7906481.html</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis其他特性和功能</title>
      <link href="/Redis%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%92%8C%E5%8A%9F%E8%83%BD.html"/>
      <url>/Redis%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%92%8C%E5%8A%9F%E8%83%BD.html</url>
      
        <content type="html"><![CDATA[<h2 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询"></a> 慢查询</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来，可将其持久化到磁盘中供开发人员分析。</p><h3 id="客户端请求生命周期"><a class="markdownIt-Anchor" href="#客户端请求生命周期"></a> 客户端请求生命周期</h3><img src="/Redis其他特性和功能/请求生命周期.png" title="请求生命周期"><p>慢查询是一个先进先出的队列，该队列固定长度，保存在内存中。若一条命令在第三阶段的执行过程中被判断为慢查询，则会进行该队列。</p><h3 id="慢查询配置"><a class="markdownIt-Anchor" href="#慢查询配置"></a> 慢查询配置</h3><img src="/Redis其他特性和功能/慢查询.png" title="慢查询"><ol><li>slowlog-log-slower-than: 命令是否是慢查询的界定条件（阈值），单位微秒，例如超过10毫秒就认为该命令是慢查询，= 0 是代表记录所有命令，&lt; 0 不记录任何命令，默认：10000。</li><li>slowlog-max-len: 慢查询列表的固定长度，默认：128</li><li>slowlog list:  指明有哪些慢查询</li><li>参数配置：<ul><li>修改配置文件</li><li>动态配置：config set slowlog-max-len 1000</li></ul></li></ol><h3 id="慢查询命令"><a class="markdownIt-Anchor" href="#慢查询命令"></a> 慢查询命令</h3><ol><li><em>slowlog get [n]</em> # 获取慢查询队列， n 指明获取几个慢查询记录</li><li><em>slowlog len</em>  # 获取慢查询队列长度</li><li><em>slowlog reset</em> # 清空慢查询队列</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>slowlog-max-len：线上环境建议调大慢查询日志的列表，记录慢查询日志时Redis会对长命令做截断操作，并不会占用大量内存。增大慢查询列表可以减缓慢查询被剔除出列表的可能性。例如线上可以设置为1000以上。</li><li>slowlog-log-lower-than：需要根据redis的并发量调整该值。由于redis采用单线程，对于高流量的场景，如果执行命令的时间在1毫秒以上，那么redis最多可支撑OPS（每秒操作次数）不到1000，因此高OPS场景的redis建议设置为1毫秒。</li><li>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行slow get命令将慢查询日志持久化到其他存储中，然后制作可视化界面查询。</li></ol><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> pipeline</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><p>利用pipeline可以一次从发送多条命令（打包），在服务端执行之后，在把结果一次性返回，节省了命令/结果在网络中的传输时间。若没有使用pipeline，n次命令的操作，要额外花费n-1网络时间，因为redis的命令执行都是微秒级别，所以网络时间通常是瓶颈所在。</p><img src="/Redis其他特性和功能/pipeline.png" title="pipeline"><img src="/Redis其他特性和功能/pipeline2.png" title="pipeline2"><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">pipeline.set(&quot;product&quot;,&quot;computer&quot;);</span><br><span class="line">pipeline.set(&quot;producttwo&quot;,&quot;microwave&quot;);</span><br><span class="line">pipeline.syncAndReturnAll();</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3><ol><li>注意每次pipeline携带数据量</li><li>pipeline每次只能作用在一个Redis节点上</li><li>M操作（mset）是原子操作，pipeline命令非原子操作。</li></ol><h2 id="发布订阅"><a class="markdownIt-Anchor" href="#发布订阅"></a> 发布订阅</h2><h3 id="发布订阅模型"><a class="markdownIt-Anchor" href="#发布订阅模型"></a> 发布订阅模型</h3><img src="/Redis其他特性和功能/发布订阅.png" title="发布订阅"><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><ol><li><em>publish channel message</em> # 发布者向对应频道发布消息, 返回订阅者数量<br><em>e.g., publish sohu:tv “hello!”</em></li><li><em>subscribe [channel]</em>  # 订阅一个或多个频道</li><li><em>unsubscribe [channel]</em>  # 取消订阅一个或多个频道</li><li><em>psubscribe [pattern…]</em>  # 订阅一个或多个符合给定模式的频道<br>e.g., psubscribe it*   # 将会订阅以it开头的频道</li><li><em>punsubscribe [pattern…]</em>  # 取消订阅一个或多个符合给定模式的频道</li><li><em>pubsub channels</em>  # 列出至少有一个订阅者的频道</li><li><em>pubsub numsub [channels…]</em>  # 列出给定频道的订阅者数量</li></ol><h3 id="与消息队列的区别"><a class="markdownIt-Anchor" href="#与消息队列的区别"></a> 与消息队列的区别</h3><p>发布订阅时，所以订阅者都可以收到发布者的信息，而消息队列是消息订阅者从消息队列中取消息，不保证每个消息订阅者都可以得到消息。</p><h2 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h2><h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3><p>位图（也称为位数组，位向量等）是紧凑存储位的数组数据结构。redis提供了对位的操作。</p><img src="/Redis其他特性和功能/位图.png" title="位图"><h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3><p>位数组是自动扩展的，如果超出现有内容范围，它会自动将位数组进行零扩充。</p><img src="/Redis其他特性和功能/位图特征.png" title="位图特征"><h3 id="api-2"><a class="markdownIt-Anchor" href="#api-2"></a> API</h3><ol><li><em>setbit key offset value</em> # 给位图指定偏移量设置值</li><li><em>getbit key offset</em> #  得到指定偏移量的值</li><li><em>bitcount  key [start end]</em> #  获取位图指定范围(start - end, 单位为字节， 不指定则代表获取全部)位值位1的个数</li><li><em>bitop  op destkey key[key…]</em>  #  对多个位图进行 and (交集)，or(并集)，not(非)，xor(异或)操作，并把结果保存在 destkey 中</li><li><em>bitpos  key targetBit [start] [end]</em>   #计算位图指定范围(start-end, 单位为字节, 不指定则代表获取全部)第一个值等于 targetBit 的偏移量</li></ol><h3 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h3><ol><li>Type = String, 最大512MB</li><li>注意setbit时的偏移量，可能损耗大</li><li>活跃用户统计/用户的签到等等应用都有奇效</li></ol><h2 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h2><h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3><p>基于HyperLogLog算法，极小空间完成独立数量（基数）统计。本质还是字符串。<br>基数统计：一个集合（注意：这里集合的含义是 Object 的聚合，可以包含重复元素）中不重复元素的个数。例如集合 {1,2,3,1,2}，它有5个元素，但它的基数/Distinct 数为3。</p><h3 id="api-3"><a class="markdownIt-Anchor" href="#api-3"></a> API</h3><ol><li><em>pfadd key element [element…</em> # 向hyperloglog添加元素</li><li><em>pfcount key [key…</em> # 计算hyperloglog的独立总数</li><li><em>pfmerge destkey  sourcekey[sourcekey…</em> # 合并多个hyperloglog</li></ol><h3 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h3><ol><li>存在错误率 - 0.81%</li><li>不能取出单条数据</li><li>鉴于 HyperLogLog 不保存数据内容的特性，所以，它只适用于一些特定的场景。例如计算日活、月活数据等等</li></ol><h2 id="geo-redis-32支持"><a class="markdownIt-Anchor" href="#geo-redis-32支持"></a> GEO - redis 3.2+支持</h2><h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3><p>GEO: 地理信息定位，存储经纬度，计算两地距离，范围计算等。redis的geo实现采用数据结构为zset</p><h3 id="api-4"><a class="markdownIt-Anchor" href="#api-4"></a> API</h3><ol><li>geoadd key longitude latitude member [longitude latitude member… # 增加地理位置信息<br>e.g., geoadd city:location 116.28 39.55 bejing</li><li>geopos key member [member… # 获取地理位置信息</li><li>geolist key member1 member2 [unit] # 获取两个地理位置的距离 unit: m, km, mi, ft</li><li>georadius<img src="/Redis其他特性和功能/GEO.png" title="GEO"></li><li>zrem key member # edis的geo实现采用数据结构为 zset，遂可以使用zset API进行删除</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构和相应操作</title>
      <link href="/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%9B%B8%E5%BA%94%E6%93%8D%E4%BD%9C.html"/>
      <url>/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%9B%B8%E5%BA%94%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<h2 id="redis通用操作"><a class="markdownIt-Anchor" href="#redis通用操作"></a> Redis通用操作</h2><ol><li><em>Keys [pattern]</em> # 遍历出指定模式的key，可使用 <em>, ?等通配符 - 一般不在生产环境中使用，O(n)<br>  _Keys</em>_  # 遍历出所有key<br>  <em>Keys he[h-l]*</em>   # 遍历以 he 开头，第三个字符在 h-l 期间的匹配key</li><li><em>dbsize</em> # 计算 key 的总数，O(1)</li><li><em>exists key</em> # 检查 key 是否存在，O(1)级别时间复杂度</li><li><em>del key</em> # 删除指定 key ，O(1)</li><li><em>expire key seconds</em> #  key在 seconds 秒后过期 ，O(1)</li><li><em>ttl key</em> #  查看 key 剩余过期时间  -1 表达无过期时间  -2表示已过期，O(1)</li><li><em>persist key</em> #  去掉 key 的过期时间 ，O(1)</li><li><em>type key</em> # 返回 key 的类型 ，O(1)</li></ol><h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> String类型</h2><h3 id="string键值结构"><a class="markdownIt-Anchor" href="#string键值结构"></a> String键值结构</h3><img src="/Redis数据结构和相应操作/String数据结构.png" title="String数据结构"><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><em>get key</em> # 获取 key 对应value ，O(1)</li><li><em>set key value</em> # 设置 key-value ，已有相同 key 值，则进行覆盖，O(1)</li><li><em>setnx key value</em> # 设置 key-value ，key 不存在，才进行设置，O(1)</li><li><em>set key value</em> xx # 设置 key-value ，key 存在，才进行设置，O(1)</li><li><em>del key</em> # 删除 key-value ，O(1)</li><li><em>incr key</em> # key 自增1, 如果key不存在，自增都get(key)=1 ，O(1)</li><li><em>decr key</em> # key 自减1, 如果key不存在，自减都get(key)=-1 ，O(1)</li><li><em>incrby key k</em> # key 自增k, 如果key不存在，自增都get(key)=k ，O(1)</li><li><em>decrby key k</em> # key 自减k, 如果key不存在，自减都get(key)=-k，O(1)</li><li><em>mget key1 key2  key3…</em> # 批量获取key，原子操作，O(n)</li><li><em>mset key1 value1 key2 value2 key3 value3…</em> # 批量设置key-value，原子操作，O(n)</li><li><em>getset key newvalue</em>   #  set key newvalue并返回 oldvalue，O(1)</li><li><em>append key value</em>   #  将 value 将追加到  oldvalue，O(1)</li><li><em>strlen key</em>   #  返回字符串长度（注意中文） ，O(1)</li><li><em>incrbyfloat key floatValue</em>   #  增加key 对应的值 ，O(1)</li><li><em>getrange key start end</em>   #  获取字符串指定下标的所有值 ，O(1)</li><li><em>setrange key index value</em>   #  设置指定下标对应的值 ，O(1)</li></ol><h2 id="hash类型"><a class="markdownIt-Anchor" href="#hash类型"></a> Hash类型</h2><h3 id="hash键值结构"><a class="markdownIt-Anchor" href="#hash键值结构"></a> Hash键值结构</h3><img src="/Redis数据结构和相应操作/Hash数据结构.png" title="Hash数据结构"><p>注： field不能相同，value可以相同</p><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><ol><li><em>hget key field</em> # 获取 hash key 对应field 的 value ，O(1)</li><li><em>hset key field value</em> # 设置 hash key 对应field 的 value ，O(1)</li><li><em>hdel key field</em> # 删除 hash key 对应field 的 value ，O(1)</li><li><em>hexists key field</em> # 判断 hash key 是否有对应 field ，O(1)</li><li><em>hlen key</em> # 获取 hash key 的 field 数量，O(1)</li><li><em>hmget key field1 field2…</em>  # 批量获取hash-key的一批 field 对应值，O(n)</li><li><em>hmset key  field1 value1 field2 value2…</em> # 批量设置 hash-key的一批 field 对应值，O(n)</li><li><em>hgetall key</em>   # 返回 hash-key 对应所有的 field-value 值，O(n)</li><li><em>hvals key</em>   # 返回 hash-key 对应所有 field 的 value 值，O(n)</li><li><em>hkeys key</em>   # 返回 hash-key 对应所有 field ，O(n)</li><li><em>hincrby key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hincrbyfloat key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hsetnx key field value</em> # 设置 hash key对应 field的 value ，field 不存在，才进行设置，O(1)</li></ol><h2 id="list类型"><a class="markdownIt-Anchor" href="#list类型"></a> List类型</h2><h3 id="list键值结构"><a class="markdownIt-Anchor" href="#list键值结构"></a> List键值结构</h3><img src="/Redis数据结构和相应操作/List数据结构.png" title="List数据结构"><p>注: 有序（由插入顺序决定遍历顺序），可以重复，左右两边插入弹出</p><h3 id="操作-3"><a class="markdownIt-Anchor" href="#操作-3"></a> 操作</h3><ol><li><em>rpush key value1 value2…</em> # 从列表的右端插入值 ，O(1~n)</li><li><em>lpush key value1 value2…</em> # 从列表的左端插入值 ，O(1~n)</li><li>linsert key before/after value newvalue # 在list指定的值前|后插入新值，O(n)</li><li><em>lpop key</em>  # 从列表的左端弹出一个值（删除） ，O(1)</li><li><em>rpop key</em>  # 从列表的右端弹出一个值（删除） ，O(1)</li><li><em>lrem key count value</em>  # 根据 count  值，从列表中删除所有 value  相等的项 ，O(n)<ul><li>count  &gt; 0 , 从左到右，删除最多 count  个 value  相等的项目</li><li>count  &lt; 0 , 从右到左，删除最多 Math.abs(count)  个 value  相等的项目</li><li>count  = 0 , 删除所有 value  相等的项目</li></ul></li><li><em>ltrim key start end</em>  # 按照索引范围(索引从 0 开始 ，-1 表示最后一个元素)修剪列表 ，O(n)</li><li><em>lrange key start end</em>  # 获取列表指定索引范围(索引从 0 开始，-1 表示最后一个元素，包括 end )的值 ，O(n)<ul><li>lrange list 0 5 = lrange list -6 -1 = lrange list 0 -1</li></ul></li><li><em>lindex key index</em>  # 获取列表指定索引的值 ，O(n)</li><li><em>llen key</em>  # 获取列表长度 ，O(1)</li><li><em>lset key index newValue</em>  # 设置列表指定索引的值 ，O(n)</li><li><em>blpop key timeout</em>  # lpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li><li><em>rlpop key timeout</em>  # rpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li></ol><h2 id="set类型"><a class="markdownIt-Anchor" href="#set类型"></a> Set类型</h2><h3 id="set键值结构"><a class="markdownIt-Anchor" href="#set键值结构"></a> Set键值结构</h3><img src="/Redis数据结构和相应操作/Set数据结构.png" title="Set数据结构"><p>注: 无序（顺序不由插入顺序决定），不可重复，支持集合间的操作</p><h2 id="操作-4"><a class="markdownIt-Anchor" href="#操作-4"></a> 操作</h2><ol><li><em>sadd key value1 value2…</em>.  # 向集合 key 中添加元素，若已有重复元素，则添加失败 ，O(n)</li><li><em>srem key value1 value2…</em>. # 移除集合 key 中元素，O(n)</li><li><em>scard key</em>   # 计算集合元素个数，O(1)</li><li><em>sismember key value</em> # 判断集合 key 中 value 元素是否存在，O(n)</li><li><em>srandmember key count</em>  # 随机从集合 key 中挑选 count  个元素，O(n)</li><li><em>spop key</em>  # 随机从集合 key 中挑选 1 个元素，O(1)</li><li><em>smembers key</em>  # 获取集合 key 中所有元素，O(n)</li><li><em>sdiff key1 key2</em>  # 两个集合的差集，O(n)</li><li><em>sinter key1 key2</em>  # 两个集合的交集，O(n)</li><li><em>sunion key1 key2</em>  # 两个集合的并集，O(n)</li><li><em>sunionstore/sdiffstore/sinterstore destkey key1 key2</em>   # 并集/差集/交集结果存到 destkey  中，O(n)</li></ol><h2 id="sorted-set类型"><a class="markdownIt-Anchor" href="#sorted-set类型"></a> Sorted Set类型</h2><h3 id="sorted-set键值结构"><a class="markdownIt-Anchor" href="#sorted-set键值结构"></a> Sorted Set键值结构</h3><img src="/Redis数据结构和相应操作/SortedSet数据结构.png" title="SortedSet数据结构"><p>注: 有序，不可重复，支持集合间的操作</p><h2 id="操作-5"><a class="markdownIt-Anchor" href="#操作-5"></a> 操作</h2><ol><li><em>zadd key score value score2 value2…</em>.  # 向有序集合 key 中添加score value对，value不可重复元素，否则添加失败 ，O(logN)</li><li><em>zrem key  value  value2…</em>.  # 删除有序集合 key 中添加元素 ，O(1)</li><li><em>zscore key  value</em>   # 获取有序集合 key 中 value 对应的 score ，O(1)</li><li><em>zincrby key increScore value</em>   # 增加有序集合 key 中 value 对应的 score 值，O(1)</li><li><em>zcard key</em>   # 获取有序集合 key 中 value 个数，O(1)</li><li><em>zrank key value</em>   # 获取有序集合 key 中 value 的排名(从低到高)，O(1)</li><li><em>zrevrank key value</em>   # 获取有序集合 key 中 value 的排名(从高到低)，O(1)</li><li><em>zrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 降序，O(logn + m)</li><li><em>zrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 降序，O(logn + m)</li><li><em>zcount key minScore maxScore</em>    #  获取有序集合指定分数范围的值的个数 ，O(logn + m)</li><li><em>zremrangebyrank key start end</em> #  删除指定排名内的升序元素，O(logn + m)</li><li><em>zremrangebyscore key minScore maxScore</em> #  删除指定分数范围的升序元素，O(logn + m)</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="http://redisdoc.com/" rel="external nofollow noopener noreferrer" target="_blank">http://redisdoc.com/</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis是什么?</title>
      <link href="/Redis%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
      <url>/Redis%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted set），哈希（Hash）。</p><h2 id="数据结构和内部编码"><a class="markdownIt-Anchor" href="#数据结构和内部编码"></a> 数据结构和内部编码</h2><img src="/Redis是什么/数据结构图.png" title="数据结构图"><p>Redis 源码中设置了一个redisObject数据结构，描述了此种关系。</p><img src="/Redis是什么/内部编码图.png" title="内部编码图"><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ol><li>速度快 - 基于内存，C语言编写，单线程 - 纯内存，非阻塞IO（实时性好，但是占用大量CPU资源），避免线程切换和竞态消耗。</li><li>持久化 - Rdis所有数据保持在内存中，可对数据进行持久化在磁盘中。</li><li>多种数据结构，在新的版本中，还提供了位图（Bitmaps），超小内存唯一值计数（HyperLogLog），地理信息定位（GEO）数据结构。但是其数据结构内部还是基于上述五种基本的数据结构实现的，Bitmaps，HyperLogLog都是String数据类型。</li><li>支持多种客户端语言 - Java, PHP, Python等。</li><li>功能丰富 - 发布订阅, 事务, Lua脚本, pipeline。</li><li>“简单” - 不依赖外部库，单线程模型。</li><li>主从复制</li><li>高可用 - Redis-Sentinel(V2.8)，分布式 - Redis-Cluster(V3.0)</li><li>多数据库 - 一个redis实例包括了15个数据库，可以选择连接哪个数据据进行操作。选择数据据命令为select 1。 同时可以选择move somekey 1把当前数据库的key移动到数据库1。</li><li>事务 - multi：开始事务，后面的命令都会被认为是事务的一部分操作；exec：提交事务；discard：事务回滚。</li><li>注意: Redis是单线程，一次执行一条命令，所以拒绝长（慢命令） - keys，flushall，flushdb，slow，lua script，mutil/exec，operate big value(collection)。对于fysnc file descriptor，close file descriptor会开启另外一个独立线程进行操作。</li></ol><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li>缓存系统</li><li>消息队列 - 秒杀，抢购等。<a href="https://www.zhihu.com/question/54152397" rel="external nofollow noopener noreferrer" target="_blank">什么是消息队列？</a></li><li>计数器 - 网站访问统计，微博转发评论，视频播放</li><li>排行榜</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;LeetCode&gt;最长公共前缀</title>
      <link href="/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"/>
      <url>/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br></p><ul><li><p>示例 1:<br>输入: [“flower”,“flow”,“flight”]<br>输出: “fl”<br></p></li><li><p>示例 2:<br>输入: [“dog”,“racecar”,“car”]&lt;<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="垂直扫描法"><a class="markdownIt-Anchor" href="#垂直扫描法"></a> 垂直扫描法</h2><p><img src="https://pic.leetcode-cn.com/b647cab7c3d2bd157cecae10917e0b9b671756b92c9cfcefec1a2bdae299c11c-file_1555694071243" alt="水平扫描法"></p><ol><li>取出第一个字符串暂时作为最长公共前缀（prefixStr）；</li><li>依次遍历字符串数组中的其他字符串，分别与prefixStr比较；</li><li>若当前字符不包含prefixStr，则对prefixStr进行裁取（长度减一），再次与当前字符进行比较；</li><li>若当前字符包含prefixStr，则取出字符串数组的下一个字符串与prefixStr进行比较；</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><ul><li>时间复杂度：O(S)，S是所有字符串中字符数量的总和，最坏情况时n个字符串全部相同，则indexOf要比较S次字符比较</li><li>空间复杂度：O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) return &quot;&quot;;</span><br><span class="line">        String prefixStr = strs[0];  </span><br><span class="line">        for(int i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">            while(strs[i].indexOf(prefixStr) != 0)&#123;  </span><br><span class="line">                prefixStr = prefixStr.substring(0,prefixStr.length() - 1); </span><br><span class="line">                if(prefixStr.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefixStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平扫描法"><a class="markdownIt-Anchor" href="#水平扫描法"></a> 水平扫描法</h2><ol><li>取出字符串数组中的第一个字符串，遍历该字符串中的字符，依次与数组中的其他字符串的同列字符比较；</li><li>若出现不同的字符，则对第一个字符串进行相应位置截取，便得最长公共前缀；</li><li>若某字符串长度等于当前所比较字符位置（i = strs[j].length()），则也进行第2步的截取操作；</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><ul><li>时间复杂度: O(S)，S 是所有字符串中字符数量的总和</li><li>空间复杂度: O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for(int i = 0; i &lt; strs[0].length(); i++)&#123;</span><br><span class="line">            char a = strs[0].charAt(i);</span><br><span class="line">            for(int j = 1; j &lt; strs.length; j++)&#123;</span><br><span class="line">                if( i == strs[j].length() || a != strs[j].charAt(i))&#123;    // 先执行||, 然后执行后面, 且i == strs[j].length()表示存在字符串已经遍历完</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;LeetCode&gt; 无重复字符的最长子串长度</title>
      <link href="/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html"/>
      <url>/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br></p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h2><p>滑动窗口算法用于对给定的大缓冲区或数组的特定窗口大小执行所需的操作(即在遍历大缓存区或数组时, 对其特定的窗口大小执行特定操作)。目的是将很少出现问题的嵌套for循环转换为单个for循环，从而降低时间复杂度。例如: 找出某数组中和最大的子数组， 规定子数组元素个数为3， 即窗口大小为3， 当然窗口大小也可以是动态的。具体过程如下：<br><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动过程"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>实现一</strong></p><ul><li>时间复杂度: O(2n)=O(n)，最糟糕的情况下，每个字符要被i，j分别访问一次</li><li>空间复杂度: O(min(m, n))，滑动窗口法需要 O(k)的空间，其中 k表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int record = 0,i = 0,j = 0;  // record记录最长子串长度</span><br><span class="line">        int length = s.length(); </span><br><span class="line">        Set strSet = new HashSet();  // 使用HashSet作为滑动窗口</span><br><span class="line">        while(i &lt; length &amp;&amp; j &lt; length)&#123;</span><br><span class="line">            if(!strSet.contains(s.charAt(j)))&#123;  // s.charAt(j)不在strSet中</span><br><span class="line">                strSet.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                record = Math.max(record, j - i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                strSet.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现二</strong><br><br>该实现是对滑动窗口的优化，即在窗口中存在与当前元素相同的字符，直接把窗口左端移动到相同字符的后一位，而不是一步一步的移动左端窗口。</p><ul><li>时间复杂度: O(n)，单单j会遍历n次</li><li>空间复杂度: O(min(m, n))</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length(), record = 0;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0, j = 0; j &lt; length; j++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(j)))&#123;  // 包含了有相同字符</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)),i);  // 把i定位到存储在map中且与s.charAt(j)相同的字符的下一个索引位置</span><br><span class="line">            &#125;</span><br><span class="line">            record = Math.max(record,j - i + 1);  // + 1是因为前面已经排除了相同字符, 遂可把s.charAt(j)字符加入参与长度计算 </span><br><span class="line">            map.put(s.charAt(j), j + 1);  // 把s.charAt(j)索引+1是方便i的定位(定位到相同元素的后一位)</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习课程练习代码实现(Octave版/Python版)</title>
      <link href="/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html"/>
      <url>/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习课程练习代码实现octave版python版"><a class="markdownIt-Anchor" href="#吴恩达机器学习课程练习代码实现octave版python版"></a> 吴恩达机器学习课程练习代码实现(Octave版/Python版)</h1><p> 吴恩达老师的机器学习课程成为了众多机器学习爱好者进入机器学习世界的敲门砖, 老师通俗易懂的授课方式让人能够快速的了解机器学习。 老师的课后练习使用Octave语言进行编写, 但是现在机器学习中使用更加普遍的是Python语言, 为了兼顾两者, 我就自己编写的两个版本的代码实现进行分享。对于每个作业PDF文档也进行了相应注释。</p><ul><li>Linear Regression</li><li>Logistic Regression</li><li>Neural Network</li><li>NN Back Propagation</li><li>Bias vs Variance</li><li>SVM</li><li>Kmeans and PCA</li><li>Anomaly Detection and Recommendation</li></ul><p>  <strong>具体代码文档下载链接:</strong> <a href="https://github.com/hbheyho/MachineLearningExam-Andrew-Ng" rel="external nofollow noopener noreferrer" target="_blank">MachineLearningExam-Andrew-Ng</a><br> ps: 若查看Python版本, 建议使用Jupyter Notebook进行阅读</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 服务/脚本/命令自启动配置</title>
      <link href="/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html"/>
      <url>/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h2 id="linux服务自启动"><a class="markdownIt-Anchor" href="#linux服务自启动"></a> Linux服务自启动</h2><p> 若程序（脚本）已注册成服务，则可通过service serviceName start/stop/status来启动服务、停止服务和查看服务状态，也可通过/etc/init.d/serviceName start/stop来开启和停止服务。<br> 可通过/etc/rc.d/init.d或/etc/init.d查看linux全部服务。</p><h3 id="方法一修改配置文件"><a class="markdownIt-Anchor" href="#方法一修改配置文件"></a> 方法一：修改配置文件</h3><p> 修改 /etc/rc.d/rc.local或/etc/rc.local文件（该文件在系统启动时，在输入用户名和密码之前最后读取的文件），加入服务启动命令来实现服务自启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"># 系统启动时，tomcat6服务自启动</span><br><span class="line">/etc/rc.d/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><h3 id="方法二chkconfig命令"><a class="markdownIt-Anchor" href="#方法二chkconfig命令"></a> 方法二：chkconfig命令</h3><p> chkconfig命令格式：<em>chkconfig serviceName on/off</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自启动tomcat服务</span><br><span class="line">chkconfig tomcat on</span><br><span class="line">#关闭tomcat自启动</span><br><span class="line">chkconfig tomcat off</span><br></pre></td></tr></table></figure><h3 id="方法三通过ntsysv调用窗口模式来管理服务的自启动"><a class="markdownIt-Anchor" href="#方法三通过ntsysv调用窗口模式来管理服务的自启动"></a> 方法三：通过ntsysv调用窗口模式来管理服务的自启动</h3><p> ntsysv命令格式：<em>ntsysv [–level 运行级别]</em><br>          --level 运行级别：可以指定设定自启动的运行级别；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只设定2、3、5级别的服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv --level 235</span><br><span class="line">#按默认的运行级别设置服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv</span><br></pre></td></tr></table></figure><p>执行上述命令之后linux界面如下，使用空格键来选定/取消服务的自启动，其中*号代表该服务自启动。</p><img src="/Linux-服务-脚本-命令自启动配置/ntsysv设置自启动.png" title="ntsysv设置自启动"><p><strong>注意：ntsysv属于redhat系列linux的专有命令</strong></p><h2 id="linux脚本自启动"><a class="markdownIt-Anchor" href="#linux脚本自启动"></a> Linux脚本自启动</h2><h3 id="方法一把脚本放到etcrclocal"><a class="markdownIt-Anchor" href="#方法一把脚本放到etcrclocal"></a> 方法一：把脚本放到/etc/rc.local</h3><p>脚本文件start_tomcat.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#启动tomcat</span><br><span class="line">/etc/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><p>把需自启动的脚本文件放入/etc/rc.local</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#当系统启动时便执行start_tomcat.sh脚本</span><br><span class="line">/root/start_tomcat.sh        #脚本执行方式：绝对路径执行方式，path/脚本文件</span><br></pre></td></tr></table></figure><h3 id="方法二把sh脚本移动到etcprofiled"><a class="markdownIt-Anchor" href="#方法二把sh脚本移动到etcprofiled"></a> 方法二：把sh脚本移动到/etc/profile.d</h3><p> /etc/profile.d中的脚本文件执行情景：当一个用户登录Linux系统或使用切换到另一个用户时才会调用，所以不建议使用</p><h2 id="linux自启动命令"><a class="markdownIt-Anchor" href="#linux自启动命令"></a> Linux自启动命令</h2><p> 若要自启动命令，则把需要自启动的命令放在/etc/rc.local中。</p>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Shell提取文件名称和目录方法</title>
      <link href="/Linux-Shell%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95.html"/>
      <url>/Linux-Shell%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="单路径提取"><a class="markdownIt-Anchor" href="#单路径提取"></a> 单路径提取</h2><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用${}</h3><p> ${}主要用来进行变量的提取和替换等等操作，它可以提取非常多的内容，<strong>提取文件路径知识它使用的一个特例</strong>。</p><ul><li>#：表示从左边算起第一个</li><li>%：表示从右边算起第一个</li><li>##：表示从左边算起最后一个</li><li>%%：表示从右边算起最后一个</li><li>＊：表示要删除的内容，对于#和##的情况，它位于指定的字符（例子中的’/‘和’.’）的左边，表于删除指定字符及其左边的内容；对于%和%%的情况，它位于指定的字符（例子中的’/‘和’.’）的右边，表示删除指定字符及其右边的内容。这里的’*'的位置不能互换，即不能把*号放在#或##的右边，反之亦然。</li></ul><h4 id="filepath"><a class="markdownIt-Anchor" href="#filepath"></a> ${filePath##*/}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’/‘字符及其左边的内容，返回从左边算起的最后一个’/’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo $&#123;filePath##*/&#125;</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><h4 id="filepath-2"><a class="markdownIt-Anchor" href="#filepath-2"></a> ${filePath##*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’.‘字符及其左边的内容，返回从左边算起的最后一个’.’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath##*.&#125;</span><br><span class="line">txt</span><br></pre></td></tr></table></figure><h4 id="filepath-3"><a class="markdownIt-Anchor" href="#filepath-3"></a> ${filePath#*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的第一个’.‘字符及其左边的内容，返回从左边算起第一个’.’（不含该字符）的右边部分的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.tar.zip&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath#*.&#125;</span><br><span class="line">tar.zip</span><br></pre></td></tr></table></figure><h4 id="filepath-4"><a class="markdownIt-Anchor" href="#filepath-4"></a> ${filePath%/*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的第一个’/‘字符及其右边的内容，返回从右边算起的第一个’/’（不含该字符）的左边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%/*&#125;</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h4 id="filepath-5"><a class="markdownIt-Anchor" href="#filepath-5"></a> ${filePath%%.*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的最后一个’.‘字符及其右边的内容，返回从右边算起的最后一个’.’（不含该字符）的左边的内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%%.*&#125;</span><br><span class="line">/tmp/test</span><br></pre></td></tr></table></figure><h3 id="使用basename-dirname"><a class="markdownIt-Anchor" href="#使用basename-dirname"></a> 使用basename、dirname</h3><p> basename和dirname命令就是专门为做这一件事而已准备的了。</p><h4 id="basename"><a class="markdownIt-Anchor" href="#basename"></a> basename</h4><p> 该命令的作用是从路径中提取出文件名，使用方法为basename NAME [SUFFIX]。</p><ul><li>从路径中提出文件名（带后缀）：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath)</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><ul><li>从上面命令的用法中可以看到，后缀（SUFFIX）是一个可选项。所以，若只想提取出文件名file，而不带有后缀，还可以在变量的后面加上后缀名：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath .txt)</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="dirname"><a class="markdownIt-Anchor" href="#dirname"></a> dirname</h4><p>  该命令的作用是从路径中提取出目录名，使用方法为 dirname NAME</p><ul><li>提取test.txt所在目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirname /tmp/test.txt</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><p>注：该命令不仅能提取出普通文件所的目录，它能提取出任何文件所在的目录，例如目录所在的目录，如下：</p><ul><li>提取目录的目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirPath=/tmp/testDir/</span><br><span class="line">[root@localhost tmp]# dirname $dirPath</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h2 id="提取目录中所有文件名称"><a class="markdownIt-Anchor" href="#提取目录中所有文件名称"></a> 提取目录中所有文件名称</h2><h3 id="get_filenamesh"><a class="markdownIt-Anchor" href="#get_filenamesh"></a> get_fileName.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">folderPath=&quot;/root&quot;</span><br><span class="line">files=$(ls $FloderPath)</span><br><span class="line">for filename in $files</span><br><span class="line">do</span><br><span class="line">echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# bash get_fileName.sh</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">start_tomcat.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]Linux中防火墙概述</title>
      <link href="/%E8%BD%AC-Linux%E4%B8%AD%E9%98%B2%E7%81%AB%E5%A2%99%E6%A6%82%E8%BF%B0.html"/>
      <url>/%E8%BD%AC-Linux%E4%B8%AD%E9%98%B2%E7%81%AB%E5%A2%99%E6%A6%82%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<p>Linux防火墙概述</p><p><strong>转载</strong>： <a href="http://www.zsythink.net/archives/1199" rel="external nofollow noopener noreferrer" target="_blank">http://www.zsythink.net/archives/1199</a></p><h3 id="防火墙相关概述"><a class="markdownIt-Anchor" href="#防火墙相关概述"></a> 防火墙相关概述</h3><p>  从逻辑上讲。防火墙可以大体分为主机防火墙和网络防火墙。</p><ul><li>主机防火墙：针对于单个主机进行防护。</li><li>网络防火墙：往往处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。</li></ul><p>  网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。<br>  从物理上讲，防火墙可以分为硬件防火墙和软件防火墙。</p><ul><li>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。</li><li>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。</li></ul><h3 id="iptables是什么"><a class="markdownIt-Anchor" href="#iptables是什么"></a> iptables是什么</h3><p>  iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的安全框架中，这个安全框架才是真正的防火墙，这个框架的名字叫netfilter。netfilter才是防火墙真正的安全框架（framework），netfilter位于内核空间。<br>  iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。<br>  netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。<br>  Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p><ul><li>网络地址转换(Network Address Translate)</li><li>数据包内容修改</li><li>数据包过滤的防火墙功能</li></ul><p>  所以说，虽然我们使用service iptables start启动iptables服务，但是其实准确的来说，iptables并没有一个守护进程，所以并不能算是真正意义上的服务，而应该算是内核提供的功能。</p><h3 id="规则的定义"><a class="markdownIt-Anchor" href="#规则的定义"></a> 规则的定义</h3><p>  <strong>规则</strong>：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。配置防火墙的主要工作就是添加、修改和删除这些规则。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。<br>  那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条链都是一个关卡，每个通过这个关卡的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个报文，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的规则，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合器宇轩昂的标准，所以把你放行了，而我不符合标准，所以没有被放行，其实，<strong>器宇轩昂就是一种匹配条件，放行就是一种动作，匹配条件与动作组成了规则</strong>。<br>  规则由匹配条件和处理动作组成。</p><ul><li><p>匹配条件分为基本匹配条件与扩展匹配条件</p><ul><li>基本匹配条件：源地址Source IP，目标地址 Destination IP</li><li>扩展匹配条件：除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。源端口Source Port, 目标端口Destination Port都可以作为扩展匹配条件。</li></ul></li><li><p>处理动作在iptables中被称为target，动作也可以分为基本动作和扩展动作。</p><ul><li>ACCEPT：允许数据包通过。</li><li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li><li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li><li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li><li>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li><li>DNAT：目标地址转换。</li><li>REDIRECT：在本机做端口映射。</li><li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li></ul></li></ul><h3 id="链的定义"><a class="markdownIt-Anchor" href="#链的定义"></a> 链的定义</h3><p>  我们知道，防火墙的作用就在于对经过的报文匹配规则，然后执行对应的动作 , 所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了链 , 每个经过这个关卡的报文，都要将这条链上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。</p><img src="/转-Linux中防火墙概述/链的定义.png" title="链的定义"><h3 id="表的定义"><a class="markdownIt-Anchor" href="#表的定义"></a> 表的定义</h3><p>  我们对每个链上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。<br>  我们把具有相同功能的规则的集合叫做表，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下表</p><ul><li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li><li>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</li><li>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</li><li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</li></ul><p>  也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张表中。</p><h3 id="链和表关系"><a class="markdownIt-Anchor" href="#链和表关系"></a> 链和表关系</h3><p>  但是我们需要注意的是，某些链中注定不会包含某类规则，就像某些关卡天生就不具备某些功能一样，比如，A关卡只负责打击陆地敌人，没有防空能力，B关卡只负责打击空中敌人，没有防御步兵的能力，C关卡可能比较NB，既能防空，也能防御陆地敌人，D关卡最屌，海陆空都能防。<br>  让我们看看每个链上的规则都存在于哪些表中。</p><ul><li>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</li><li>INPUT的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</li><li>FORWARD的规则可以存在于：mangle表，filter表。</li><li>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</li><li>POSTROUTING的规则可以存在于：mangle表，nat表。</li></ul><p>  但是，我们在实际的使用过程中，往往是通过表作为操作入口，对规则进行定义的，之所以按照上述过程介绍iptables，是因为从关卡的角度更容易从入门的角度理解，但是为了以便在实际使用的时候，更加顺畅的理解它们，此处我们还要将各表与链的关系罗列出来，<br>表（功能）-----------------------&gt; 链（钩子）：</p><ul><li>raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT</li><li>mangle表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li><li>nat表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）</li><li>filter表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</li></ul><img src="/转-Linux中防火墙概述/链与表关系.png" title="链与表关系"><p>  其实我们还需要注意一点，因为数据包经过一个链的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张表中，那么，哪些表中的规则会放在链的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting链做图示。</p><img src="/转-Linux中防火墙概述/preouting优先级.png" title="preouting优先级">   <p>  prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：raw --&gt; mangle --&gt; nat<br>  但是我们知道，iptables为我们定义了4张表,当他们处于同一条链时，执行的优先级如下。<br>优先级次序（由高而低）：raw --&gt; mangle --&gt; nat --&gt; filter<br>  4张表中的规则处于同一条链的目前只有output链，它就是传说中海陆空都能防守的关卡。<br>  为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较短的链子，这条短链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要焊接在iptables默认定义链子上，才能被IPtables使用。</p><h3 id="数据经过防火墙流程"><a class="markdownIt-Anchor" href="#数据经过防火墙流程"></a> 数据经过防火墙流程</h3><p>  所以，根据上图，我们能够想象出某些常用场景中，报文的流向：</p><img src="/转-Linux中防火墙概述/数据经过防火墙流程.png" title="数据经过防火墙流程"><ul><li>到本机某进程的报文：PREROUTING --&gt; INPUT</li><li>由本机转发的报文：PREROUTING --&gt; FORWARD --&gt; POSTROUTING</li><li>由本机的某进程发出报文（通常为响应报文）：OUTPUT --&gt; POSTROUTING</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为blog生成定制RSS</title>
      <link href="/%E4%B8%BAblog%E7%94%9F%E6%88%90%E5%AE%9A%E5%88%B6RSS.html"/>
      <url>/%E4%B8%BAblog%E7%94%9F%E6%88%90%E5%AE%9A%E5%88%B6RSS.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是rss"><a class="markdownIt-Anchor" href="#什么是rss"></a> 什么是RSS？</h2><blockquote><p>RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。 你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。 它不会过时，信息越是过剩，它的意义也越加彰显。</p></blockquote><h2 id="怎么定制blogrss基于hexo"><a class="markdownIt-Anchor" href="#怎么定制blogrss基于hexo"></a> 怎么定制blogRSS（基于hexo）？</h2><p><strong>step1</strong>： 下载hexo plugin</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><strong>step2</strong>：修改_config配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  # Extensions</span><br><span class="line">plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br></pre></td></tr></table></figure><p> 属性解释：</p><ul><li>type: RSS的类型(atom/rss2)</li><li>path: 文件路径，默认是 atom.xml/rss2.xml</li><li>limit: 展示文章的数量,使用 0 或则 false 代表展示全部</li><li>hub:  PubSubHubbub hubs的URL (如果使用不到可以为空)</li><li>content: （可选）设置 true 可以在RSS文件中包含文章全部内容，默认：false</li><li>content_limit: （可选）摘要中使用的帖子内容的默认长度。 仅在content设置为false且未显示自定义帖子描述时才使用。</li><li>content_limit_delim: （可选，默认不使用）如果content_limit启用来缩短帖子内容,则在达到字符限制之前， 在分隔符最后出现时进行剪切。</li><li>order_by: 订阅内容的顺序. (默认: -date)</li><li>icon - (可选) 自定义的推送图标.默认为主配置中指定的电子邮件的gravatar。</li></ul><h2 id="生成rssatomxml"><a class="markdownIt-Anchor" href="#生成rssatomxml"></a> 生成RSS（atom.xml）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g  // 生成路径public-&gt;atom.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm --save-dev与--save 的区别</title>
      <link href="/npm-save-dev%E4%B8%8E-save-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/npm-save-dev%E4%B8%8E-save-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p> npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install–save另一个是 npm install –save-dev，他们<strong>表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下</strong>，譬如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.2.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-latest"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"cross-env"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^0.25.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^11.1.4"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^2.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不过这只是它们的表面区别。它们真正的区别是：<br> <strong>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖</strong>。即devDependencies下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记FTP学习的一个小坑</title>
      <link href="/%E8%AE%B0FTP%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
      <url>/%E8%AE%B0FTP%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p> 在搭建好FTP服务器之后，用浏览器进行连接一直连接不上(<strong>在保证用户名和密码都正确的基础上</strong>)，Chrome完全没有提示信息，火狐提示如下：</p><img src="/记FTP学习的一个小坑/火狐提示信息.png" title="火狐提示信息"><p> 从提示可以看出<strong>Policy requires SSL 即SSL策略需要SSL的验证</strong>，我们只需修改自身的FTP服务器SSL配置，把需要SSL连接修改为允许SSL连接</p><img src="/记FTP学习的一个小坑/设置界面.png" title="设置界面"><p><strong>PS</strong>：需要注意的是，使用FTP客户端工具，类似于FileZilla是可以连接的，它会有相应的提示，提示说该连接不安全巴拉巴拉的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Ajax异步请求的跨域以及Session问题</title>
      <link href="/%E5%85%B3%E4%BA%8EAjax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8ASession%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%85%B3%E4%BA%8EAjax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8ASession%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p> 根据浏览器的保护规则，跨域时候的SeeionId是不会被保存下来，即我们的每次Ajax请求都会是一个新的请求，都会产生新的SeesionId，后台自然不能根据前台传过来的SeesionId判断你是否处于登录状态。<br> 我们可以对前台的Ajax以及后台进行相应的修改，就可以对上述问题进行完美解决：</p><h3 id="前端ajax请求"><a class="markdownIt-Anchor" href="#前端ajax请求"></a> 前端Ajax请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;    </span><br><span class="line">    url:url,</span><br><span class="line">    xhrFields: &#123;      </span><br><span class="line">         withCredentials: <span class="literal">true</span>   <span class="comment">// 加上此部分</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    crossDomain: <span class="literal">true</span>,     <span class="comment">// 加上此部分</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;, </span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="controller部分代码"><a class="markdownIt-Anchor" href="#controller部分代码"></a> Controller部分代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"XXXX.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">XXXXX</span><span class="params">( HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"><span class="comment">// 解决跨域</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>,request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line"><span class="comment">// 跨域的session 保证同一性</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Credentials"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">  somecode</span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure><p><strong>PS</strong>: withCredentials：默认情况下，跨源请求不提供凭据(cookie、HTTP认证及客户端SSL证明等)。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。<br> 如果服务器接收带凭据的请求，会用下面的HTTP头部来响应,Access-Control-Allow-Credentials: true。如果发送的是带凭据的请求，但服务器的相应中没有包含这个头部，那么浏览器就不会把相应内容交给Ajax(于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序)。<br> 支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解各种推荐机制原理</title>
      <link href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8E%A8%E8%8D%90%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html"/>
      <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8E%A8%E8%8D%90%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于人口统计学的推荐"><a class="markdownIt-Anchor" href="#基于人口统计学的推荐"></a> 基于人口统计学的推荐</h2><p> 基于人口统计学的推荐机制（Demographic-based Recommendation）是一种最易于实现的推荐方法，它只是简单的根据系统用户的基本信息发现用户的相关程度，然后将相似用户喜爱的其他物品推荐给当前用户。</p><img src="/深入理解各种推荐机制原理/基于人口统计学的推荐机制.png" title="基于人口统计学的推荐机制"><h3 id="基于人口统计学的推荐机制工作原理"><a class="markdownIt-Anchor" href="#基于人口统计学的推荐机制工作原理"></a> 基于人口统计学的推荐机制工作原理</h3><p> 从图中可以很清楚的看到，首先，系统对每个用户都有一个用户 Profile 的建模，其中包括用户的基本信息，例如用户的年龄，性别等等；然后，系统会根据用户的 Profile 计算用户的相似度，可以看到用户 A 的 Profile 和用户 C 一样，那么系统会认为用户 A 和 C 是相似用户，在推荐引擎中，可以称他们是“邻居”；最后，基于“邻居”用户群的喜好推荐给当前用户一些物品，图中将用户 A 喜欢的物品 A 推荐给用户 C。</p><h3 id="好处"><a class="markdownIt-Anchor" href="#好处"></a> 好处</h3><p>  1. 因为不使用当前用户对物品的喜好历史数据，所以对于新用户来讲没有“冷启动（Cold Start）”的问题。<br>  2. 这个方法不依赖于物品本身的数据，所以这个方法在不同物品的领域都可以使用，它是领域独立的（domain-independent）。</p><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><p> 这种基于用户的基本信息对用户进行分类的方法过于粗糙，尤其是对品味要求较高的领域，比如图书，电影和音乐等领域，无法得到很好的推荐效果。可能在一些电子商务的网站中，这个方法可以给出一些简单的推荐。另外一个局限是，这个方法可能涉及到一些与信息发现问题本身无关却比较敏感的信息，比如用户的年龄等，这些用户信息不是很好获取。</p><h2 id="基于内容的推荐"><a class="markdownIt-Anchor" href="#基于内容的推荐"></a> 基于内容的推荐</h2><p> 基于内容的推荐是在推荐引擎出现之初应用最为广泛的推荐机制，它的核心思想是根据推荐物品或内容的元数据，发现物品或者内容的相关性，然后基于用户以往的喜好记录，推荐给用户相似的物品。</p><img src="/深入理解各种推荐机制原理/基于内容的推荐机制.png" title="基于内容的推荐机制"><h3 id="基于内容的推荐工作原理"><a class="markdownIt-Anchor" href="#基于内容的推荐工作原理"></a> 基于内容的推荐工作原理</h3><p> 电影推荐系统，首先我们需要对电影的元数据有一个建模，这里只简单的描述了一下电影的类型；然后通过电影的元数据发现电影间的相似度，因为类型都是“爱情，浪漫”电影 A 和 C 被认为是相似的电影（当然，只根据类型是不够的，要得到更好的推荐，我们还可以考虑电影的导演，演员等等）；最后实现推荐，对于用户 A，他喜欢看电影 A，那么系统就可以给他推荐类似的电影 C。</p><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><p> 这种基于内容的推荐机制的好处在于它能很好的建模用户的口味，能提供更加精确的推荐。但它也存在以下几个问题：<br>  1. 需要对物品进行分析和建模，推荐的质量依赖于对物品模型的完整和全面程度。在现在的应用中我们可以观察到关键词和标签（Tag）被认为是描述物品元数据的一种简单有效的方法。<br>  2. 物品相似度的分析仅仅依赖于物品本身的特征，这里没有考虑人对物品的态度。<br>  3. 因为需要基于用户以往的喜好历史做出推荐，所以对于新用户有“冷启动”的问题。</p><p> 虽然这个方法有很多不足和问题，但他还是成功的应用在一些电影，音乐，图书的社交站点，有些站点还请专业的人员对物品进行基因编码，比如潘多拉，在一份报告中说道，在潘多拉的推荐引擎中，每首歌有超过 100 个元数据特征，包括歌曲的风格，年份，演唱者等等。</p><h2 id="基于协同过滤的推荐"><a class="markdownIt-Anchor" href="#基于协同过滤的推荐"></a> 基于协同过滤的推荐</h2><p> 随着 Web2.0 的发展，Web站点更加提倡用户参与和用户贡献，因此基于协同过滤的推荐机制因运而生。它的原理很简单，就是根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，然后再基于这些关联性进行推荐。基于协同过滤的推荐可以分为三个子类：基于用户的推荐（User-based Recommendation），基于项目的推荐（Item-based Recommendation）和基于模型的推荐（Model-based Recommendation）。下面我们一个一个详细的介绍着三种协同过滤的推荐机制。</p><h3 id="基于用户的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于用户的协同过滤推荐"></a> 基于用户的协同过滤推荐</h3><p> 基于用户的协同过滤推荐的基本原理是，根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。</p><img src="/深入理解各种推荐机制原理/基于用户的协同过滤工作原理.png" title="基于用户的协同过滤工作原理"><p> 上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A，物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A ，物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。<br> 基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。</p><h3 id="基于项目的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于项目的协同过滤推荐"></a> 基于项目的协同过滤推荐</h3><p> 基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，然后根据用户的历史偏好信息，将类似的物品推荐给用户。</p><img src="/深入理解各种推荐机制原理/基于项目的协同过滤工作原理.png" title="基于项目的协同过滤工作原理"><p> 假设用户 A 喜欢物品 A 和物品 C，用户 B 喜欢物品 A，物品 B 和物品 C，用户 C 喜欢物品 A，从这些用户的历史喜好可以分析出物品 A 和物品 C 时比较类似的，喜欢物品 A 的人都喜欢物品 C，基于这个数据可以推断用户 C 很有可能也喜欢物品 C，所以系统会将物品 C 推荐给用户 C。<br> 与上面讲的类似，基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。<br> 同时协同过滤，在基于用户和基于项目两个策略中应该如何选择呢？其实基于项目的协同过滤推荐机制是 Amazon 在基于用户的机制上改良的一种策略，因为在大部分的 Web 站点中，物品的个数是远远小于用户的数量的，而且物品的个数和相似度相对比较稳定，同时基于项目的机制比基于用户的实时性更好一些。但也不是所有的场景都是这样的情况，可以设想一下在一些新闻推荐系统中，也许物品，也就是新闻的个数可能大于用户的个数，而且新闻的更新程度也有很快，所以它的形似度依然不稳定。所以，其实可以看出，推荐策略的选择其实和具体的应用场景有很大的关系。</p><h3 id="基于模型的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于模型的协同过滤推荐"></a> 基于模型的协同过滤推荐</h3><p> 基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。<br> 基于协同过滤的推荐机制是现今应用最为广泛的推荐机制，它有以下几个显著的<strong>优点</strong>：<br>  1. 它不需要对物品或者用户进行严格的建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。<br>  2. 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好</p><p>存在的<strong>问题</strong>：</p><p>  1. 方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。<br>  2. 推荐的效果依赖于用户历史偏好数据的多少和准确性。<br>  3. 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。<br>  4. 对于一些特殊品味的用户不能给予很好的推荐。<br>  5. 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。</p><h2 id="混合的推荐机制"><a class="markdownIt-Anchor" href="#混合的推荐机制"></a> 混合的推荐机制</h2><p> 在现行的 Web 站点上的推荐往往都不是单纯只采用了某一种推荐的机制和策略，他们往往是将多个方法混合在一起，从而达到更好的推荐效果。关于如何组合各个推荐机制，这里讲几种比较流行的组合方法。</p><p>  <strong>（1）加权的混合（Weighted Hybridization）</strong>: 用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最 好的推荐效果。<br>  <strong>（2）切换的混合（Switching Hybridization）</strong>：前面也讲到，其实对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，那么切换的混合方式，就是允许在不同的情况下，选择最为合适的推荐机制计算推荐。<br>  <strong>（3）分区的混合（Mixed Hybridization）</strong>：采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户。其实，Amazon，当当网等很多电子商务网站都是采用这样的方式，用户可以得到很全面的推荐，也更容易找到他们想要的东西。<br>  <strong>（4）分层的混合（Meta-Level Hybridization）</strong>: 采用多种推荐机制，并将一个推荐机制的结果作为另一个的输入，从而综合各个推荐机制的优缺点，得到更加准确的推荐。</p><p><strong>转载</strong>：<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html?ca=drs-" rel="external nofollow noopener noreferrer" target="_blank">IBM Developer 推荐引擎初探</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell无法连接虚拟机的几个原因</title>
      <link href="/Xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%9B%A0.html"/>
      <url>/Xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%9B%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机没有设置相应ip地址"><a class="markdownIt-Anchor" href="#虚拟机没有设置相应ip地址"></a> 虚拟机没有设置相应IP地址</h2><p> 具体设置IP地址可参考： <a href="https://www.cnblogs.com/fuly550871915/p/4949513.html" title="桥接模式下设置IP地址" rel="external nofollow noopener noreferrer" target="_blank">桥接模式下设置IP地址</a></p><h2 id="ssh服务没有启动"><a class="markdownIt-Anchor" href="#ssh服务没有启动"></a> SSH服务没有启动</h2><blockquote><p>Secure Shell（缩写为 SSH），由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为一项创建在应用层和传输层基础上的安全协议，为计算机上的 Shell（壳层）提供安全的传输和使用环境。</p></blockquote><h3 id="查看ssh状态"><a class="markdownIt-Anchor" href="#查看ssh状态"></a> 查看SSH状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo service sshd status</span><br></pre></td></tr></table></figure><h3 id="安装ssh服务"><a class="markdownIt-Anchor" href="#安装ssh服务"></a> 安装SSH服务</h3><p> 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ sudo yum install sshd</span><br><span class="line">或者</span><br><span class="line"> $ sudo yum install openssh-server（由osc网友 火耳提供）</span><br></pre></td></tr></table></figure><p> 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ sudo apt-get install sshd</span><br><span class="line">或者</span><br><span class="line"> $ sudo apt-get install openssh-server（由osc网友 火耳提供）</span><br></pre></td></tr></table></figure><h3 id="开启ssh服务"><a class="markdownIt-Anchor" href="#开启ssh服务"></a> 开启SSH服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo service sshd start</span><br></pre></td></tr></table></figure><p> 执行完命令后，用第一步：查看ssh服务状态的命令，如果出现以下提示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active: active (running) since Sun 2013-04-07 13:43:11 CST; 15s ago</span><br></pre></td></tr></table></figure><h3 id="卸载ssh服务"><a class="markdownIt-Anchor" href="#卸载ssh服务"></a> 卸载SSH服务</h3><p> 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove sshd</span><br></pre></td></tr></table></figure><p> 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get –purge remove sshd</span><br></pre></td></tr></table></figure><h2 id="20端口被暂用"><a class="markdownIt-Anchor" href="#20端口被暂用"></a> 20端口被暂用</h2><h3 id="查看端口情况"><a class="markdownIt-Anchor" href="#查看端口情况"></a> 查看端口情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp|grep 80</span><br></pre></td></tr></table></figure><h3 id="打开端口号"><a class="markdownIt-Anchor" href="#打开端口号"></a> 打开端口号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT -ptcp --dport 端口号-j ACCEPT</span><br><span class="line">$ service iptables save   // 保存设置</span><br></pre></td></tr></table></figure><h2 id="防火墙未关闭"><a class="markdownIt-Anchor" href="#防火墙未关闭"></a> 防火墙未关闭</h2><h3 id="关闭虚拟机防火墙"><a class="markdownIt-Anchor" href="#关闭虚拟机防火墙"></a> 关闭虚拟机防火墙</h3><pre class="highlight"><code class>    永久性生效：       开启： $ chkconfig iptables on       关闭： $ chkconfig iptables off    即时生效，重启后失效：       开启： $ service iptables start       关闭： $ service iptables stop</code></pre><h3 id="关闭宿主机防火墙"><a class="markdownIt-Anchor" href="#关闭宿主机防火墙"></a> 关闭宿主机防火墙</h3><p> 没有必要因小失大去关闭整个防火墙，可设置相应的入栈和出栈规则即可。即入站规则和出站规则内的 “文件和打印共享（回显请求 – ICMPv4-In）”允许连接，在出站规则中为 “文件和打印共享（回显请求 – ICMPv4-Out）”允许连接。</p><hr><p> <strong>ps</strong>：我主要面临的问题是虚拟机可以ping通宿主机，宿主机无法ping通虚拟机，就是被防火墙问题困扰，关闭之后需要重启一下电脑便生效。</p>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
