<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="J.U.C之并发容器(CopyOnWriteArrayList, ConcurrentHashMap)"><meta name="keywords" content="J.U.C"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>J.U.C之并发容器(CopyOnWriteArrayList, ConcurrentHashMap) | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发容器和同步容器"><span class="toc-number">1.</span> <span class="toc-text"> 并发容器和同步容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步容器"><span class="toc-number">1.1.</span> <span class="toc-text"> 同步容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发容器"><span class="toc-number">1.2.</span> <span class="toc-text"> 并发容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见并发容器"><span class="toc-number">2.</span> <span class="toc-text"> 常见并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#copyonwritearraylist"><span class="toc-number">2.1.</span> <span class="toc-text"> CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用缺点"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 应用缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考资料"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 参考资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap"><span class="toc-number">2.2.</span> <span class="toc-text"> ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-2"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析-2"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料-2"><span class="toc-number">3.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">J.U.C之并发容器(CopyOnWriteArrayList, ConcurrentHashMap)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Concurrency/">Concurrency</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><span>Reading time: 20 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发容器和同步容器"><a class="markdownIt-Anchor" href="#并发容器和同步容器"></a> 并发容器和同步容器</h2>
<h3 id="同步容器"><a class="markdownIt-Anchor" href="#同步容器"></a> 同步容器</h3>
<p>同步容器常见的有Vector，HashTable等，这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步（使用synchronized关键字来修饰）使得每次只有一个线程能访问容器的状态。<br>
在多线程场景下，能安全的使用同步容器所附带的方法，但是在某些情况下可能需要额外的客户端加锁来保护复合操作。常见的复合操作：迭代，跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算。<br>
所以同步容器不光削弱了并发性，降低了吞吐量，在某些符合复合操作的场景下任然会有着线程安全问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object getLast (Vector list) &#123;</span><br><span class="line">    int lastIndex = list.size - 1;</span><br><span class="line">    return list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast (Vector list) &#123;</span><br><span class="line">    int lastIndex = list.size - 1;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若有多个线程交替执行上述两个方法，则可能会面临着线程安全问题，如下图所示：</p>
<img src="/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap/线程安全.jpg" title="线程安全">
<p>要解决上述问题就需要客户端加锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object getLast (Vector list) &#123;</span><br><span class="line">    synchronized(list)&#123;</span><br><span class="line">        int lastIndex = list.size - 1;</span><br><span class="line">        return list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteLast (Vector list) &#123;</span><br><span class="line">    synchronized(list)&#123;</span><br><span class="line">        int lastIndex = list.size - 1;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于同步容器的迭代操作也会面临线程不安全情况，如果在迭代过程中，有其他的线程删除了一个元素，并且迭代过程和删除过程交替执行，那么将会抛出ArrayIndexOutOfBoundsException异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是可以通过客户端加锁来解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(vector)&#123;</span><br><span class="line">    for(int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">        doSomething(vector.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发容器"><a class="markdownIt-Anchor" href="#并发容器"></a> 并发容器</h3>
<p>JAVA 5.0 提供了多种并发容器类来改进同步容器的性能，通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。主要是因为同步容器将所有对容器状态的访问都串行化，实现它们的线程安全性，但是这种的代价严重降低了并发性，当多个线程竞争容器的锁时，吞吐量严重降低。<br>
并发容器是针对多个线程并发访问设计的，也提供了一些在使用同步容器时需要客户端加锁的复合操作，在Java 5.0 增加了ConcurrentHashMap用来替代同步且基于散列的Map，以及CopyOnWriteArrayList用于在遍历操作为主要操作的情况下替代同步的List，Java 6 也引入了ConcurrentSkipListMap 和 ConcurrentSkipListSet，分别作为同步的SortedMap（TreeMap） 和 SortedSet（TreeSet）的并发替代品。</p>
<h2 id="常见并发容器"><a class="markdownIt-Anchor" href="#常见并发容器"></a> 常见并发容器</h2>
<h3 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> CopyOnWriteArrayList</h3>
<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteArraySet。<br>
copyOnWriteArrayList 用于替代同步List（除此之外，还有copyOnWriteArraySet来替代同步的Set），在某些情况下提供了更好的并发性能，在迭代期间（读取）不需要对容器进行加锁或复制。<br>
“写入时复制(Copy-On-Write)” 容器的线程安全性在于，只要正确发布一个事实不可变对象，那么在访问该对象时就不需要进一步的同步。<br>
在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性，修改操作都在新的容器副本上进行，那么旧的容器可以看作为一个事实不可变对象，并且在修改时使用ReentrantLock锁来保证同步。<br>
在对容器进行迭代的时候，&quot;写入时复制&quot;容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的初始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>
&quot;写入时复制&quot;容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素和迭代器创建时的元素完全一致，而不必考虑修改所带来的影响。、<br>
CopyOnWriteAarryList并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>
<h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4>
<ol>
<li>
<p>add()方法<br>
add方法向CopyOnWirteArrayList中添加元素，在添加过程中会使用一个ReentrantLock来保证添加操作的线程安全性。<br>
由于每当修改容器时都会复制底层数组，需要花费一定的开销，尤其是当容器规模较大时，只有迭代操作远远大于修改操作时才会使用&quot;写入时复制&quot;容器。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 使用一个可重入锁来保证同步</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 得到旧数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        // 记录旧数组长度</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        // 创建一个新数组, 并将旧数组上的元素复制到新数组</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        // 添加元素到新数组中</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        // 新数组的引用重新只需旧数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>get()方法<br>
get方法通过getArray方法获得旧数组，然后根据index索引来得到元素。因为在读取期间，可能有线程根据旧的数组copy了一个新的数组，在新的数组上进行添加操作，但是get方法操作的还是旧数组，那么get方法可能得到是&quot;脏&quot;数组。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    // 通过getArray方法得到旧数组</span><br><span class="line">    // 通过index索引来得到元素</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>iterator()方法<br>
在对容器进行迭代的时候，&quot;写入时复制&quot;容器的迭代器保留一个指向底层基础数组（旧数组）的引用，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>
&quot;写入时复制&quot;容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素和迭代器创建时的元素完全一致，而不必考虑修改所带来的影响。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 然后迭代器对象的时候, 会把当前数组传递给迭代器进行备份</span><br><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">// CopyOnWriteArrayList 迭代器</span><br><span class="line">private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="应用缺点"><a class="markdownIt-Anchor" href="#应用缺点"></a> 应用缺点</h4>
<ol>
<li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（写的时候会创建新容器来保持数据，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，，那么这个时候很有可能造成频繁的Yong GC和Full GC。</li>
<li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ol>
<h4 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h4>
<p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3938914.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3938914.html</a></p>
<h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3>
<h4 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h4>
<p>在线程不安全的HashMap以及（多线程操作下可能会形成环形链表）效率低下的HashTable（HashTable虽说是线程安全的，但是它是通过全表锁来实现的，即简单粗暴的使用synchronized关键字对put方法加锁，导致了在多线程访问下所有操作的串行话）的背景下，急需一个满足多线程安全并且高效率的Hash表并发容器。<br>
ConcurrentHashMap 在HashTable的基础上进行了优化，他使用了分段锁技术来达到线程安全要求，其将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<br>
并且ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p>
<h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h4>
<ol>
<li>
<p>JDK1.7 源码<br>
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment继承了可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。<br>
一个ConcurrentHashMap里包含一个Segment数组，Segment的结构是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，可以将一个Segment可以看作是一个类似于HashMap结构。当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
 <img src="/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap/ConcurrentHashMap.png" title="ConcurrentHashMap">
<p>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment。<br>
扩容操作只使用了HashEntry数组，Segment数组初始化之hou就不可变。</p>
<ol>
<li>
<p>Segment/HashEntry<br>
Segment定义如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; </span><br><span class="line">// Segment中元素的数量</span><br><span class="line">transient volatile int count;</span><br><span class="line">// 对HashEntry数组的操作次数(put/remove, 修改不算)</span><br><span class="line">transient int modCount;</span><br><span class="line">// 阈值, Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</span><br><span class="line">transient int threshold; </span><br><span class="line">// HashEntry数组, 数组中的每一个元素代表了一个链表的头部</span><br><span class="line">transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">// 负载因子, 用于确定threshold</span><br><span class="line">final float loadFactor;     </span><br><span class="line">                          …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashEntry定义如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123; </span><br><span class="line">final K key; </span><br><span class="line">// 根据key的hashCode计算得到的hash值</span><br><span class="line">// 用来定位HashEntry在HashEntry数组中的位置</span><br><span class="line">final int hash;</span><br><span class="line">volatile V value;</span><br><span class="line">// next为final类型, 这代表着next指针不可修改</span><br><span class="line">// 所以put操作都将新的HashEntry节点放置在链表头部</span><br><span class="line"> final HashEntry&lt;K,V&gt; next; </span><br><span class="line">                         ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不指定则为默认参数：</span><br><span class="line">//    initialCapacity：16</span><br><span class="line">//    loadFactor：0.75</span><br><span class="line">//    concurrencyLevel：16    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; </span><br><span class="line">    // 参数检验</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException(); </span><br><span class="line">    // 当concurrencyLevel大于Segment最大数量, 进行重置</span><br><span class="line">    // MAX_SEGMENTS 为1 &lt;&lt; 16 = 65536, 也就是最大并发数为65536</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line">    int sshift = 0; </span><br><span class="line">    int ssize = 1; </span><br><span class="line">    // 根据concurrencyLevel得到合适的segment数组长度ssize</span><br><span class="line">    // 为了更好根据hash值计算索引, segment长度需要为2的n次方</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">        ++sshift; </span><br><span class="line">        ssize &lt;&lt;= 1; </span><br><span class="line">    &#125; </span><br><span class="line">    // segmentShift：段偏移量 segmentMask：段掩码, 这两个变量在定位segment时用来计算segment索引</span><br><span class="line">    this.segmentShift = 32 - sshift; </span><br><span class="line">    this.segmentMask = ssize - 1; </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">    // 计算cap的大小, 即Segment中HashEntry的数组长度, cap也一定为2的n次方</span><br><span class="line">    int c = initialCapacity / ssize; </span><br><span class="line">    if (c * ssize &lt; initialCapacity) </span><br><span class="line">        ++c; </span><br><span class="line">    int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    while (cap &lt; c) </span><br><span class="line">        cap &lt;&lt;= 1; </span><br><span class="line">    //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化</span><br><span class="line">    Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">    (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    // 创建Segment数组</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); </span><br><span class="line">    this.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以知道，Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。这种设计其实主要是便于通过按位与的散列算法来定位Segment的index，即用hash &amp; (n - 1) 代替 hash % n。<br>
构造函数执行流程如下：</p>
<ol>
<li>必要参数校验；</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值；</li>
<li>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小；</li>
<li>记录 segmentShift 偏移量，这个值为 容量 = 2 的N次方 中的 N，在后面 Put 时计算位置时会用到，默认是 32 - sshift = 28；</li>
<li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15；</li>
<li>计算HashEntry数组的长度；</li>
<li>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 2 * 0.75=1.5，插入第二个值时才会进行扩容。</li>
</ol>
</li>
<li>
<p>put方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //concurrentHashMap不允许key/value为空</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 根据key的hashCode得到hash值</span><br><span class="line">    //hash函数对key的hashCode重新散列,避免差劲的不合理的hashcode,保证散列均匀</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    / 返回的hash值无符号右移segmentShift位与段掩码进行位运算,定位segment</span><br><span class="line">    // 默认segmentShift为28, segmentMask为15</span><br><span class="line">    // 即 hash &gt;&gt;&gt; 28 &amp; 15, 即高四位相与于1111</span><br><span class="line">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">    (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) </span><br><span class="line">        // 如果查找到的 Segment 为空, 初始化</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述put方法主要是根据key值计算segment的位置，并且如果segment为空，调用ensureSegment方法进行初始化。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    // 判断 u 位置的 Segment 是否为null</span><br><span class="line">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</span><br><span class="line">        // 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br><span class="line">        int cap = proto.table.length;</span><br><span class="line">        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br><span class="line">        float lf = proto.loadFactor;</span><br><span class="line">        // 计算扩容阀值</span><br><span class="line">        int threshold = (int)(cap * lf);</span><br><span class="line">        // 创建一个 cap 容量的 HashEntry 数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // recheck</span><br><span class="line">            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br><span class="line">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            // 自旋检查 u 位置的 Segment 是否为null</span><br><span class="line">             while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">                // 使用CAS 赋值，只会成功一次</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当获取的segment为空，调用ensureSegment方法进行初始化。初始化流程如下：</p>
<ol>
<li>检查计算得到的位置的 Segment 是否为null；</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组；</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null；</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment；</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment；</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找到了指定的segment之后, 将数据存放到其HashEntry数组对应位置</span><br><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    // 获取 ReentrantLock 独占锁，获取不到, scanAndLockForPut 获取, 该方法会不断自旋tryLock获取锁, 当自旋次数大于指定次数时lock()阻塞获取锁, 并且返回表头node节点</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        // 计算要put的数据在HashEntry的哪个位置</span><br><span class="line">        int index = (tab.length - 1) &amp; hash;</span><br><span class="line">        // CAS 获取 index 坐标的值</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        // 遍历当前位置HashEntry链表, 找到合适的插入位置</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br><span class="line">                K k;</span><br><span class="line">                // 已经存在了相同的key, 直接用新值覆盖</span><br><span class="line">                if ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 发生了地址冲突, 采用链表头插法进行插入</span><br><span class="line">                if (node != null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    // 当前HashEntry链表还是为空</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c = count + 1;</span><br><span class="line">                // 容量大于扩容阀值，小于最大容量，进行扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    // index 位置赋值 node, node 可能是一个元素, 也可能是一个链表的表头</span><br><span class="line">                setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述put方法完成真正的数据存放操作，即将数组存入到HashEntry中。具体执行流程如下：</p>
<ol>
<li>tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。scanAndLockForPut 该方法会不断自旋tryLock()获取锁，当自旋次数大于指定次数时lock()阻塞获取锁, 获取锁成功后返回返回要存放的node节点（根据传入的Key，Value构造）；</li>
<li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</li>
<li>遍历HashEntry链表以便得到合适位置来存放新元素，分为以下两种情况：
<ol>
<li>如果这个位置上的 HashEntry 存在：
<ul>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，一致则替换值；</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表遍历完毕没有相同的。</li>
</ul>
</li>
<li>如果这个位置上的 HashEntry 不存在：
<ul>
<li>如果当前容量大于扩容阀值，小于最大容量，进行扩容；</li>
<li>直接头插法插入。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>rehash方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// rehash扩容只针对HashEntry的扩容, 不会对Segment机械能扩容</span><br><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">     // 老容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // 新容量, 扩大两倍</span><br><span class="line">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">    // 新的扩容阀值 </span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    // 创建新的数组</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    // 新的掩码, 默认2扩容后是4, 4 - 1 = 3, 二进制就是11</span><br><span class="line">    int sizeMask = newCapacity - 1;</span><br><span class="line">    for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        // 遍历老数组</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 计算新的位置,新的位置只可能是不变或者是老的位置+老的容量</span><br><span class="line">            int idx = e.hash &amp; sizeMask;</span><br><span class="line">            if (next == null)</span><br><span class="line">                // 如果当前位置还不是链表,只是一个元素，直接赋值</span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            else &#123; </span><br><span class="line">                // 如果是链表了</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                int lastIdx = idx;</span><br><span class="line">                // 新的位置只可能是不变或者是老的位置+老的容量</span><br><span class="line">                // 遍历结束后，lastRun 后面的元素位置都是相同的</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123;</span><br><span class="line">                    int k = last.hash &amp; sizeMask;</span><br><span class="line">                                              </span><br><span class="line">                    if (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // lastRun 后面的元素位置都是相同的, 直接作为链表赋值到新位置</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                // 遍历剩余元素，头插法到指定 k 位置</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    int h = p.hash;</span><br><span class="line">                    int k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    // 头插法插入新的节点</span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask;</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。<br>
源码种的第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的，然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。</p>
</li>
<li>
<p>get方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; </span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h = hash(key);</span><br><span class="line">    // 得到segment索引</span><br><span class="line">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">    (tab = s.table) != null) &#123;</span><br><span class="line">        // 得到在HashEntry数组中的索引</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">        e != null; e = e.next) &#123;</span><br><span class="line">            // 如果是链表, 遍历查找到相同 key 的 value</span><br><span class="line">            K k;</span><br><span class="line">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法的具体流程如下：</p>
<ol>
<li>计算得到 key 的存放位置；</li>
<li>遍历指定位置查找相同 key 的 value 值。<br>
get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>JDK1.8 源码<br>
Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<br>
源码分析！挖坑~ 现在太累了/(ㄒoㄒ)/~~ 都晚上12点了都！</p>
</li>
</ol>
<h2 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h2>
<p>[1] <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap源码+底层数据结构分析.md</a><br>
[2] <a href="https://www.cnblogs.com/chengxiao/p/6842045.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chengxiao/p/6842045.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap.html">http://www.huangbin.fun/J-U-C之并发容器-CopyOnWriteArrayList-ConcurrentHashMap.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J-U-C/">J.U.C</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/转-Fork-Join框架.html"><span>[转] Fork/Join框架</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>