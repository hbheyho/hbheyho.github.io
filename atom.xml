<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HB&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangbin.fun/"/>
  <updated>2020-04-18T03:20:48.129Z</updated>
  <id>http://www.huangbin.fun/</id>
  
  <author>
    <name>HB</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis Cluster学习</title>
    <link href="http://www.huangbin.fun/Redis-Cluster%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster学习.html</id>
    <published>2020-04-18T02:57:05.000Z</published>
    <updated>2020-04-18T03:20:48.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称当个Redis可以使用10万并发），高可用问题（部分节点不可达能继续处理命令）。 Redis 集群常常和主从复制结合使用。</p><h2 id="分布式数据库-数据分区"><a class="markdownIt-Anchor" href="#分布式数据库-数据分区"></a> 分布式数据库 - 数据分区</h2><img src="/Redis-Cluster学习/数据分区.png" title="数据分区"><h3 id="哈希分区"><a class="markdownIt-Anchor" href="#哈希分区"></a> 哈希分区</h3><p>假如有1~100条数据，按照哈希函数（例如 hash(key)%3），把数据分区到不同的三个数据库</p><ol><li>节点取余分区： hash(key) % nodes。若增加/减少节点，会进行大量数据迁移，例如当前有3个节点，增加了一个节点，按照新的hash(key) % 4进行计算时，很多数据需要进行移动。 建议进行 多倍扩容，例如当前有3个节点，可以扩容到6个节点，减少数据迁移量。节点取余也成为 不一致性哈希。比较适合缓存的场景</li><li>一致性哈希分区<br>能保证最小迁移数据，比较适合缓存的场景 - <a href="http://blog.codinglabs.org/articles/consistent-hashing.html" rel="external nofollow noopener noreferrer" target="_blank">一致性哈希分区</a></li><li>虚拟槽分区：Redis cluster采用此种分区方式，预设虚拟槽（slot），每个虚拟槽映射一个数据子集，每个节点管理一定数量的虚拟槽，redis 虚拟槽范围 0 ~ 16383。<br>使用分散函数（例如CRC16(keys) % slots ）计算出 keys 属于哪个槽，再根据节点所管理的槽的范围，从而确定数据属于哪个节点（节点中共享信息，若一个虚拟槽不属于当前节点，会告诉虚拟操去哪个节点去存储）</li></ol><img src="/Redis-Cluster学习/虚拟槽分区.png" title="虚拟槽分区"><h3 id="顺序分区"><a class="markdownIt-Anchor" href="#顺序分区"></a> 顺序分区</h3><p>假如有1 ~ 100条数据，按照顺序分区规则，可以把1 ~ 33，34 ~ 66，67 ~ 100分区到三个不同的三个数据库</p><h3 id="方式对比"><a class="markdownIt-Anchor" href="#方式对比"></a> 方式对比</h3><img src="/Redis-Cluster学习/分区比较.png" title="分区比较"><h2 id="cluster-架构"><a class="markdownIt-Anchor" href="#cluster-架构"></a> Cluster 架构</h2><img src="/Redis-Cluster学习/cluster架构.png" title="cluster架构"><ol><li>通过配置文件 cluster-enabled yes 将一个节点设置为一个集群节点</li><li>节点之间通过gossip协议进行通信，了解彼此的信息</li><li>将虚拟槽指派给上述节点</li><li>客户端通过 CRC16( key ) % 16383 并可知道对应的key应该到哪个虚拟槽的哪个节点进行处理</li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="配置集群节点"><a class="markdownIt-Anchor" href="#配置集群节点"></a> 配置集群节点</h3><ol><li><em>cluster-enabled yes</em>  # 配置当前节点为集群节点</li><li><em>cluster-config-file nodes-${port}.conf</em>  # 配置cluster节点自身配置文件</li><li><em>cluster-node-timeout 15000</em>  # 集群中各个节点相互通讯（ping）时，允许&quot;失联&quot;的最大毫秒数，如果超过这个时间没有得到响应，会认为该节点故障，若节点是主节点，则会进行故障转移</li><li><em>cluster-require-full-coverage yes</em>  # 若配置为 yes，则当集群中有节点不可用时，整个集群都不能提供服务，通常设置为 no</li></ol><h3 id="通过meet把每个集群节点组合成集群-集群发现"><a class="markdownIt-Anchor" href="#通过meet把每个集群节点组合成集群-集群发现"></a> 通过meet把每个集群节点组合成集群 - 集群发现</h3><ol><li><em>cluster meet ip port</em>  #当前节点去发现新的集群节点</li></ol><img src="/Redis-Cluster学习/发现集群.png" title="发现集群"><h3 id="分配槽"><a class="markdownIt-Anchor" href="#分配槽"></a> 分配槽</h3><ol><li><em>cluster addslots slot [slot…]</em>   # 为当前节点分配槽</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># addslots.sh</span><br><span class="line"># 开始槽</span><br><span class="line">start=$1</span><br><span class="line"># 结束槽</span><br><span class="line">end=$2</span><br><span class="line"># 分配端口</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">   echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">   redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 分配操作</span><br><span class="line">sh addslots 0 5461 7000</span><br><span class="line">sh addslots 5462 10923 7001</span><br><span class="line">sh addslots 10923 16383 7002</span><br></pre></td></tr></table></figure><p>在第二步中配置了6个集群节点，但是只为7000 ~ 7002分配槽，7000 ~ 7002作为master，其余作为slave节点</p><h3 id="配置主从关系"><a class="markdownIt-Anchor" href="#配置主从关系"></a> 配置主从关系</h3><ol><li>cluster replicate node-id  # 对 node-id节点进行复制，node-id在集群启动时会进行分配。</li><li>cluster nodes  # 查看node-id</li></ol><img src="/Redis-Cluster学习/配置主从关系.png" title="配置主从关系"><h3 id="ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"><a class="markdownIt-Anchor" href="#ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"></a> Ruby配置集群 -除了上述安装方式，官方提供了脚本进行快速集群配置</h3><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>Gossip 协议：所有节点都保存了一份元数据，当节点发生伸缩或更新时，会将最新的元数据信息传播给所有节点。 - <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">gossip协议</a><br>Redis 使用Gossip协议时采用了meet，ping，pong，fail消息进行通信</li></ol><img src="/Redis-Cluster学习/gossip协议.png" title="gossip协议"><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://blog.csdn.net/makyan/article/details/104798725" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/makyan/article/details/104798725</a><br>[2] <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/8279d6fd65bb</a><br>[3] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长回文子串</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长回文子串.html</id>
    <published>2020-04-13T10:40:48.000Z</published>
    <updated>2020-04-14T02:30:32.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;br&gt;
示例 1：&lt;br&gt;
输入: “ba
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.huangbin.fun/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>初探动态规划算法</title>
    <link href="http://www.huangbin.fun/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/初探动态规划算法.html</id>
    <published>2020-04-13T09:18:28.000Z</published>
    <updated>2020-04-14T02:30:30.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h1&gt;
&lt;p&gt;维基百科的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dynamic programming is a method for solvi
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="Gynamic Programming" scheme="http://www.huangbin.fun/tags/Gynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel学习</title>
    <link href="http://www.huangbin.fun/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Sentinel学习.html</id>
    <published>2020-04-10T14:10:33.000Z</published>
    <updated>2020-04-14T02:35:15.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sentinel生产可用。sentinel作为一个独立的进程，监控多个运行的Redis 数据库。<br>主要解决主从复制发生故障时，进行手动故障转移的复杂性问题，当主节点宕机后，需要手动选择一个从节点作为新的主数节点，其他作为从节点，而利用sentinel能自动完成故障转移过程。<br>sentinel也支持集群，因为使用单个sentinel进程了监控Redis是不可靠的，容易出现单点问题</p><ul><li>即使有一些sentinel进程宕掉了，依然可以进行Redis 集群的主从切换</li><li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现Redis 集群的主从切换</li><li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于Redis 集群中的信息</li></ul><h2 id="功能和架构"><a class="markdownIt-Anchor" href="#功能和架构"></a> 功能和架构</h2><ol><li>功能<ul><li>监控Redis的运行状况</li><li>当发生故障时实现主从切换。当一个master宕机之后，从它的多个slave中投票选举中一个新的master，剩余节点作为新的master的slave</li></ul></li><li>架构</li></ol><img src="/Redis-Sentinel学习/架构图.png" title="架构图"><p>在这个架构中，sentinel节点会监控master和slave的相关信息，主要值得关注的是client与sentinel之间的交互：</p><ol><li>client首先需要知道sentinel节点集合和mastername信息，通过遍历它所知道的sentinel集合，获取到一个可用的sentinel节点</li><li>找到可用的sentinel节点之后，client通过 sentinel get-master-addr-by-name masterName 命令的得到master节点的地址和端口</li><li>得到master相关信息之后，会进行一次role/role replication验证，master节点会返回验证信息，至此client可以对master进行写入和读取</li><li>sentine也会将redis数据节点的变化通知给客户端 - 使用发布订阅模式进行通知</li><li>上述过程不是通过代理模式实现的，即上述client和master建立关系的过程通常只需执行一次即可</li></ol><h2 id="故障转移过程"><a class="markdownIt-Anchor" href="#故障转移过程"></a> 故障转移过程</h2><ol><li>当一个sentinel检测master宕机并不会马上进行故障转移（主观下线），只有当后面的sentinel也都认为master不可用并达到一定数量时（客观下线），选举出一个领导者sentinel来进行故障转移操作</li><li>选出一个slave作为master，执行 slave of one 让其成为master节点</li><li>通知其余slave做为新的master的slave</li><li>等待老的master复活，若复活成功，成为新的master的slave</li><li>通知客户端发生了主从变化</li></ol><p>实现上述故障转移依靠三个定时任务：</p><ol><li>每10s每个sentinel对master和slave执行info操作<ul><li>发现slave操作</li><li>确认主从关系</li></ul></li><li>每2s每个sentinel通过master节点的channel交换信息<ul><li>发布订阅模式</li><li>通过_sentinel_:hello频道交互</li><li>交互对节点的&quot;看法&quot;和自身信息 - 可以知道其他sentinel的相关信息或投票来确定哪个sentinel来进行故障转移<img src="/Redis-Sentinel学习/sentinel发布订阅图.png" title="sentinel发布订阅图"></li></ul></li><li>每1s每个sentinel对其他sentinel和redis执行ping<ul><li>心跳检测，失败判定依据，比如可以作为客观下线的依据。</li></ul></li></ol><h2 id="sentinel配置和启动"><a class="markdownIt-Anchor" href="#sentinel配置和启动"></a> Sentinel配置和启动</h2><ol><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel运行端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 守护进程启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># sentinel工作目录</span><br><span class="line">dir &quot;/usr/local/share/redis/redis-3.0.5/backs&quot;</span><br><span class="line"></span><br><span class="line"># sentinel 日志文件</span><br><span class="line">logfile &quot;sentinel-26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master信息 master-name ip port quorum - 当quorm个数sentinel节点认为maste</span><br><span class="line"># r失联,则执行故障转移</span><br><span class="line">sentinel monitor mymaster 192.168.2.23 6379 2</span><br><span class="line"></span><br><span class="line"># 一定时间内,master没有应答哨兵sentinel, sentinel认为master主观下线 默认30秒(ping 30 次没有ping通)</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 在进行主从切换时(故障转移),最多可以几个slave对新的master进行同步。若设置的值很小, 则同</span><br><span class="line">步需要花费很长时间, 值很大,则有很多slave应为同步复制而不可用, 也会降低master节点的性能</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移超时时间, 应用于以下情况</span><br><span class="line"># 1. 同一个sentinel对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2. 当一个slave从一个错误的master那里同步数据开始计算时间,直到slave被纠正为向正确的mast</span><br><span class="line"># er那里同步数据时</span><br><span class="line"># 3.当想要取消一个正在进行的failover所需要的时间  </span><br><span class="line"># 4.当进行failover时,配置所有slaves指向新的master所需的最大时间。不过，即使过了这个时间,</span><br><span class="line"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则进行处理</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>注：可以看到sentinel.conf配置文件主要是对master节点进行监控，通过master节点使用 info replecation 进行slave的相关信息获取，会将获取的slave信息自动添加到 sentinel.conf配置文件之中，在配置文件中的标识为：Generated by CONFIG REWRITE，需要注意的是，redis在添加slave信息的同时，也会对一些配置信息进行更改，例如sentinel down-after-milliseconds，sentinel parallel-syncs，sentinel failover-timeout会被移除，添加sentinel config-epoch，sentinel leader-epoch等配置 。</p><ol start="2"><li>启动</li></ol><p>  <em>redis-sentinel sentinel.conf</em>  # 启动sentinel<br>  <em>redis-cli -p 26379</em>  # 连接sentinel, sentinel也当成一个普通的Redis 节点来对待</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>主观下线：每个sentinel节点对Redis 节点失败的&quot;偏见&quot;，可能由于网络问题，Redis 节点不能在规定的时间内回应sentinel节点</li><li>客观下线：所有sentin节点对Redis 节点失败达成&quot;共识&quot;，即sentinel节点中认为Redis 节点可以进行客观下线的个数超过quorum的个数，此时可以真正进行故障转移操作。其中达成共识通过sentinel is-master-down-by-addr命令询问其他sentinel节点的&quot;意见&quot;来完成的</li><li>领导者选举<ul><li>原因：只需要一个sentinel节点来进行故障转移</li><li>如何：1. 每个做主观下线的sentinel节点通过sentinel is-master-down-by-addr 来询问其他sentinel节点的&quot;意见&quot;是否要对master节点进行客观下线的时候，通过也会要求将其设置为领导者；2. 收到命令的sentinel节点如果没有同意其他sentinel节点成为领导者的请求，那就同意，否则拒绝；3. 如果该sentinel节点发现自己的票数超过了sentinel集合半数且超过了quorum，那么它将成为领导者来进行故障处理；4. 如果有多个sentin节点成为领导者，则过一段时间再进行选举</li></ul></li><li>如何选择合适的slave让其成为master<ul><li>选择 slave-priority优先级最高的slave节点</li><li>若全部优先级相同，则选择复制偏移量最大（与以前的master节点数据最接近）的slave节点</li><li>若上述都不成立，则选择runId最小的节点，即启动最早的slave</li></ul></li></ol><h2 id="运维问题"><a class="markdownIt-Anchor" href="#运维问题"></a> 运维问题</h2><ol><li>主节点手动下线，进行故障转移<br>  <em>sentinel failover masterName</em></li><li>高可用的读写分离<br>sentinel只会对master节点进行故障转移，对于slave节点只有进行主观下线，所以要实现高可用的读写分离，客户端要关注slave节点的变化，例如关注以下三个消息: +switch-master: 从节点晋升为主节点，+conver-to-slave:  原主节点降为从节点，+sdown: 主观下线</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://segmentfault.com/a/1190000002680804" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002680804</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sent
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.huangbin.fun/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://www.huangbin.fun/Redis主从复制.html</id>
    <published>2020-04-10T13:53:44.000Z</published>
    <updated>2020-04-14T02:33:00.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave）上，数据流向是单向的 - Master -&gt; Slave。通常主数据进行数据写入操作，从数据库进行读操作，实现数据的读写分离。</p><h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2><ol><li><p>命令方式</p><ul><li><em>slaveof  slavehost</em> # 将 slavehost 将复制为当前Redis数据库的从数据库，异步操作，会将数据库的数据进行清除。<br><em>e.g., 127.0.0.1: 6380 &gt; slaveof 127.0.0.1: 6379</em>  # 127.0.0.1: 6379将会成为127.0.0.1: 6380的主数据库</li><li><em>slaveof  no one</em> # 取消当前命令执行数据库的复制，以前主数据库已经同步的数据不会清除。</li><li><em>info replication</em>  # 当前数据库是主还是从数据库的相关信息</li></ul></li><li><p>配置 - redis.conf，配置之后需重启</p><ul><li><em>slaveof  masterip masterport</em></li><li><em>slave-read-only yes</em></li></ul></li></ol><h2 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h2><p>执行完全量复制之后，主从数据库之间数据库状态已经相同了。但这个状态并非一成不变，如果主数据库执行了写操作，那么主数据库的数据库状态就会修改，并导致主从数据库状态不再一致。所以为了让主从数据库再次回到一致状态，主数据库需要对从数据库执行命令传播操作：主数据库会将自己执行的写命令，也即是造成主从数据库不一致的那条写命令，发送给从数据库执行，当从数据库执行了相同的写命令之后，主从数据库将再次回到一致状态。</p><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><img src="/Redis主从复制/主从复制.png" title="全量复制"><ol><li>复制过程<ul><li>从数据库向主数据库发送PSYNC命令 - 从2.8开始，SYNC替换成PSYNC，提供了完整重同步和部分重同步</li><li>收到PSYNC命令后，主数据库将自身的runId和offset传给从数据库，之后主数据库执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主数据库的BGSAVE命令执行完毕时，主数据库会将BGSAVE命令生成的RDB文件发送给从数据库，从数据库接收并载入这个RDB文件，将自己的数据库状态更新至主数据库执行BGSAVE命令时的数据库状态</li><li>主数据库将记录在缓冲区里面的所有写命令发送给从数据库，从数据库执行这些写命令，将自己的数据库状态更新至主数据库数据库当前所处的状态</li></ul></li><li>开销<ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>清空从数据库花费时间</li><li>从数据库加载RBD文件花费的时间，并且载入期间，从数据库可能因为阻塞而无法处理客户端请求</li></ul></li></ol><h2 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h2><img src="/Redis主从复制/部分复制.png" title="部分复制"> <ol><li>解决问题：处理从数据库断线后的重连问题。当从数据库在断线后重新连接主数据库时，如果条件允许，主数据库可以将主从数据库连接断开期间执行的写命令发送给从数据库，从数据库只要接收并执行这些写命令，就可以将数据库更新至主数据库当前所处的状态。而2.8以前，断连之后还要进行一次SYNC操作。</li><li>复制过程<ul><li>当从数据库断线后，主数据库会继续把写命令放入到复制积压缓冲区（replication backlog）中</li><li>当从数据库重新连上主数据库时，从数据库会通过PSYNC命令将自己的复制偏移量（replication offset）和主数据库的运行ID（run id）发送给主数据库，主数据库会根据这个复制偏移量和运行ID来决定对从数据库执行何种同步操作</li><li>如果从数据库发送的运行ID和当前连接的主数据库的运行ID相同，那么说明从数据库断线之前复制的就是当前连接的这个主数据库，主数据库可以继续尝试执行部分复制操作</li><li>相反，如果从数据库发送的运行ID和当前连接的主数据库的运行ID并不相同，主数据库将对从数据库执行全量复制操作</li><li>如果从数据库的复制偏移量之后的数据（也即是offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主数据库将对从数据库执行部分复制操作</li><li>相反，如果offset之后的数据已经不存在于复制积压缓冲区，那么主数据库将对从数据库执行全量复制操作</li></ul></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>复制偏移量（replication offset）：主数据库和从数据库会分别维护一个复制偏移量：<ul><li>主数据库每次向从数据库传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从数据库每次收到主数据库传播来的N个字节的数据时，就将自己的复制偏移量的值加上N<br>对比主从数据库的复制偏移量，可知道主从数据库是否处于一致状态：</li><li>如果主从数据库处于一致状态，那么主从数据库两者的偏移量总是相同的</li><li>相反，如果主从数据库两者的偏移量并不相同，那么说明主从数据库并未处于一致状态</li></ul></li></ol><img src="/Redis主从复制/复制偏移量.png" title="复制偏移量"><ol start="2"><li><p>复制积压缓冲区（replication backlog）：复制积压缓冲区是由主数据库维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主数据库进行命令传播时，它不仅会将写命令发送给所有从数据库，还会将写命令入队到复制积压缓冲区里面。因此，主数据库的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量<img src="/Redis主从复制/复制积压缓冲区.png" title="复制积压缓冲区"><br>复制积压缓冲区默认大小为1MB，如果主数据库需要执行大量写命令，又或者主从数据库断线后重连接所需的时间比较长，那么Redis的部分复制功能可能会达不到想要的效果。复制积压缓冲区的最小大小可以根据公式 second*write_size_per_second 来估算：</p><ul><li>second为从数据库断线后重新连接上主数据库所需的平均时间（以秒计算）</li><li>write_size_per_second是主数据库平均每秒产生的写命令数据量。</li><li>例如，如果主数据库平均每秒产生1 MB的写数据，而从数据库断线之后平均要5秒才能重新连接上主数据库，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理，可以通过修改repl-backlog-size配置进行设置。</li></ul></li><li><p>数据库运行ID<br>每个Redis数据库，不论主数据库还是从服务，都会有自己的运行ID。运行ID在数据库启动时自动生成，由40个随机的十六进制字符组成，例53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。<br>当从数据库对主数据库进行初次复制时，主数据库会将自己的运行ID传送给从数据库，而从数据库则会将这个运行ID保存起来。当从数据库断线并重新连上一个主数据库时，从数据库将向当前连接的主数据库发送之前保存的运行ID。</p></li></ol><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li>读写分离<ul><li>数据复制延迟</li><li>读到过期数据</li><li>从数据库故障</li></ul></li><li>主从数据库配置不一致<ul><li>maxmemory不一致：丢失数据</li><li>数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致</li></ul></li><li>规避全量复制<ul><li>第一次全量复制不可避免 - 尽量低峰（夜间）进行</li><li>避免主数据库runId不匹配导致的全量复制</li><li>避免复制积压缓冲区不足导致的全量复制 - 修改rel_backlog_size配置</li></ul></li><li>规避复制风暴<ul><li>单主数据库复制风暴 - 主数据库重启，多从数据库复制</li><li>单机器复制风暴 - 机器有多个主数据库，机器宕机，大量全量复制。避免多个主数据库部署在一个机器上</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化常见问题</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangbin.fun/Redis持久化常见问题.html</id>
    <published>2020-04-10T13:45:43.000Z</published>
    <updated>2020-04-14T02:35:04.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fork操作"><a class="markdownIt-Anchor" href="#fork操作"></a> Fork操作</h2><ol><li>定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这是一种内核机制，在创建子进程并不发生复制，创建子进程后父子进程共用数据，只有在修改数据是才会创建新的空间。</li><li>Redis中需要用到fork操作的相关命令：bgsave，bgrewriteaof，查看上一次fork消耗时间：info stats</li><li>同步操作 - 会对父进程执行的业务造成影响</li><li>与内存量息息相关 - 内存越大，耗时越长，同时也与机器类型相关</li><li>改善fork：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存: maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1 。修改sysctl vm.overcommit_memory=1<br>  0  -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br> b1 -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>  2 -  表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>降低fork频率：例如放宽AOP重写的自动触发时机</li></ul></li></ol><h2 id="子进程的开销和优化"><a class="markdownIt-Anchor" href="#子进程的开销和优化"></a> 子进程的开销和优化</h2><ol><li>CPU<ul><li>开销: RDB和AOF文件的生成，属于CPU密集型</li><li>优化： 不做CPU绑定 ，不和CPU密集型一起部署</li></ul></li><li>内存<ul><li>开销: fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>硬盘<ul><li>开销：AOF和RDB文件写入，结合iostat，iotop分析</li><li>优化：不和高硬盘负载服务部署在一起，根据写入量决定磁盘类型。</li></ul></li><li>扩展：<ul><li>CPU绑定 - 进程和CPU的绑定是为了让应用获得更好的性能，进程的Affinity属性指明了进程调度器能够把这个进程调度到哪些CPU上。CPU Affinity分为2种，soft affinity和hard affinity。soft affinity仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的CPU上。hard affinity是调度器必须遵守的规则。</li><li>CPU密集型（CPU-bound），也叫计算密集型，系统运作时CPU的消耗接近100%，I/O读写可以在很短的时间完成，但是CPU的计算任务繁重。多重程序系统中，大部份时间用来做计算、逻辑判断等的程序称之CPU bound，一般而言，CPU bound的程序CPU占用率相当高。</li><li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，CPU消耗并不高。I/O bound的程序需要大量的I/O操作。</li><li>Transparent hugepage默认是被开启的以便去改善操作系统的内存管理，但是在某种情况下会造成不可预知的节点重启和性能问题</li></ul></li></ol><h2 id="aof追加阻塞"><a class="markdownIt-Anchor" href="#aof追加阻塞"></a> AOF追加阻塞</h2><ol><li><p>定义：如果AOF文件同步时间与上次同步时间相比大于2s，Redis主进程就会阻塞，等待同步完成；如果AOF文件同步时间与上次同步时间相比小于2s，Redis主进程就会返回。其实这样做的目的是为了保证文件安全性的一种策略。 <img src="/Redis持久化常见问题/AOF追加阻塞.png" title="AOF追加阻塞"></p></li><li><p>问题：</p><ul><li>主线程阻塞造成业务受影响</li><li>虽然每秒everysec刷盘策略，但是实际上不是丢失1s数据，实际有可能丢失2s数据</li></ul></li><li><p>问题定位</p><ul><li><p>Redis日志<img src="/Redis持久化常见问题/Redis日志.png" title="Redis日志"></p></li><li><p>Info Persistence中的aof_delayed_fsync,同步延迟历史总数</p></li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fork操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork操作&quot;&gt;&lt;/a&gt; Fork操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.huangbin.fun/Redis持久化.html</id>
    <published>2020-04-10T12:44:30.000Z</published>
    <updated>2020-04-14T02:35:09.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化</p><h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2><ol><li><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行了指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB生成的文件也可作为复制媒介使用。</p></li><li><p>触发方式</p><ul><li><em>save</em>  # 客户端发出命令后，redis会生成相应的dump.rdb文件（若存在老的RDB文件，则新替老）。该命令为同步命令，进行Save 命令时，其他命令不能执行，容易发生阻塞， O(n)</li><li><em>bgsave</em> #与Save 不同的是，该命令为异步命令，会开一个子进程进行处理， O(n)</li></ul> <img src="/Redis持久化/RDB持久化.png" title="RDB持久化"> <img src="/Redis持久化/RDB持久化2.png" title="RDB持久化2"> <ul><li>利用配置文件进行触发 - 采用 bgsave方式</li></ul> <img src="/Redis持久化/RDB持久化3.png" title="RDB持久化3"> <p>  <strong>重要配置项：</strong><br>   dbfilename dump.rdb  # 指定本地数据库名<br>   dir ./   # 指定本地数据库存放目录<br>   rdbcompression yes #默认开启数据压缩，redis采用LZF压缩方式，但占用了一点CPU的时间。<br>   stop-writes-on-bgsave-error yes #出现错误是否停止写入<br>   rdbchecksum yes #是否对RDB文件进行校验</p><ul><li>全量复制 - 主从复制时会自动生成RDB文件</li><li>debug reload - 也会生成RDB文件</li><li>shutdown - Redis也会RDB文件</li></ul></li><li><p>优缺点</p><ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li><li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了 - 不可控，丢失数据。</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件 - 耗时，耗性能</li></ul></li></ol><h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2><ol><li><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></li><li><p>配置文件</p><ul><li>appendonly yes  # 开启AOF</li><li>appendfilename “appendonly-6379.aof” # 指定本地数据库名</li><li>appendfsysnc always/everysec/no # 指定更新日志条件<br>  - always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但是数据完整性比较好（慢，安全）<br>  - everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>  - no ：不同步，由OS决定何时把命令写入到文件中</li></ul> <img src="/Redis持久化/AOF持久化.png" title="AOF持久化">  <img src="/Redis持久化/AOF持久化2.png" title="AOF持久化2">  <img src="/Redis持久化/AOF持久化3.png" title="AOF持久化3"> <ul><li>为了缩小AOF文件的大小，提供了AOP重写,目的减少磁盘占用量（减少冗余）,加速恢复速度</li></ul> <img src="/Redis持久化/AOF持久化4.png" title="AOF持久化4"> <p>  <strong>重写原理</strong><br>  Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中，并没有读取旧文件，最后替换旧的aof文件。<br>  <strong>重写方式</strong><br>  a. bgrewriteaof  #异步，会开启一个子进程来进行处理<br>  b. 配置文件 - 执行bgrewriteaof<br>    auto-aof-rewrite-min-size #AOF文件重写需要的尺寸<br>    auto-aof-rewrite-percentage #AOF文件增加率<br>    当AOF文件大小是上次rewrite后大小的一倍（增加率）且文件大于64M（尺寸）时触发</p><ul><li>no-appendfsync-on-rewrite yes # 在重写时是否可以进行AOF持久化操作</li><li>aof-load-truncated yes # 在AOF文件出现错误时，是否忽略错误，尽量加载更多的数据</li><li>在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复</li></ul></li><li><p>优缺点</p><ul><li>更高的数据完整性和一致性</li><li>随着时间的增加，AOF文件会越来越大，数据恢复速度会越来越慢，可以通过重写解决</li></ul></li></ol><h2 id="持久化策略对比"><a class="markdownIt-Anchor" href="#持久化策略对比"></a> 持久化策略对比</h2><img src="/Redis持久化/持久化对比.png" title="持久化对比"> <h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/itdragon/p/7906481.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/itdragon/p/7906481.html</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化&lt;/p&gt;
&lt;h2 id=&quot;rdb持久化&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis其他特性和功能</title>
    <link href="http://www.huangbin.fun/Redis%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%92%8C%E5%8A%9F%E8%83%BD.html"/>
    <id>http://www.huangbin.fun/Redis其他特性和功能.html</id>
    <published>2020-04-10T12:26:49.000Z</published>
    <updated>2020-04-14T02:34:59.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询"></a> 慢查询</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来，可将其持久化到磁盘中供开发人员分析。</p><h3 id="客户端请求生命周期"><a class="markdownIt-Anchor" href="#客户端请求生命周期"></a> 客户端请求生命周期</h3><img src="/Redis其他特性和功能/请求生命周期.png" title="请求生命周期"><p>慢查询是一个先进先出的队列，该队列固定长度，保存在内存中。若一条命令在第三阶段的执行过程中被判断为慢查询，则会进行该队列。</p><h3 id="慢查询配置"><a class="markdownIt-Anchor" href="#慢查询配置"></a> 慢查询配置</h3><img src="/Redis其他特性和功能/慢查询.png" title="慢查询"><ol><li>slowlog-log-slower-than: 命令是否是慢查询的界定条件（阈值），单位微秒，例如超过10毫秒就认为该命令是慢查询，= 0 是代表记录所有命令，&lt; 0 不记录任何命令，默认：10000。</li><li>slowlog-max-len: 慢查询列表的固定长度，默认：128</li><li>slowlog list:  指明有哪些慢查询</li><li>参数配置：<ul><li>修改配置文件</li><li>动态配置：config set slowlog-max-len 1000</li></ul></li></ol><h3 id="慢查询命令"><a class="markdownIt-Anchor" href="#慢查询命令"></a> 慢查询命令</h3><ol><li><em>slowlog get [n]</em> # 获取慢查询队列， n 指明获取几个慢查询记录</li><li><em>slowlog len</em>  # 获取慢查询队列长度</li><li><em>slowlog reset</em> # 清空慢查询队列</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>slowlog-max-len：线上环境建议调大慢查询日志的列表，记录慢查询日志时Redis会对长命令做截断操作，并不会占用大量内存。增大慢查询列表可以减缓慢查询被剔除出列表的可能性。例如线上可以设置为1000以上。</li><li>slowlog-log-lower-than：需要根据redis的并发量调整该值。由于redis采用单线程，对于高流量的场景，如果执行命令的时间在1毫秒以上，那么redis最多可支撑OPS（每秒操作次数）不到1000，因此高OPS场景的redis建议设置为1毫秒。</li><li>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行slow get命令将慢查询日志持久化到其他存储中，然后制作可视化界面查询。</li></ol><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> pipeline</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><p>利用pipeline可以一次从发送多条命令（打包），在服务端执行之后，在把结果一次性返回，节省了命令/结果在网络中的传输时间。若没有使用pipeline，n次命令的操作，要额外花费n-1网络时间，因为redis的命令执行都是微秒级别，所以网络时间通常是瓶颈所在。</p><img src="/Redis其他特性和功能/pipeline.png" title="pipeline"><img src="/Redis其他特性和功能/pipeline2.png" title="pipeline2"><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">pipeline.set(&quot;product&quot;,&quot;computer&quot;);</span><br><span class="line">pipeline.set(&quot;producttwo&quot;,&quot;microwave&quot;);</span><br><span class="line">pipeline.syncAndReturnAll();</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3><ol><li>注意每次pipeline携带数据量</li><li>pipeline每次只能作用在一个Redis节点上</li><li>M操作（mset）是原子操作，pipeline命令非原子操作。</li></ol><h2 id="发布订阅"><a class="markdownIt-Anchor" href="#发布订阅"></a> 发布订阅</h2><h3 id="发布订阅模型"><a class="markdownIt-Anchor" href="#发布订阅模型"></a> 发布订阅模型</h3><img src="/Redis其他特性和功能/发布订阅.png" title="发布订阅"><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><ol><li><em>publish channel message</em> # 发布者向对应频道发布消息, 返回订阅者数量<br><em>e.g., publish sohu:tv “hello!”</em></li><li><em>subscribe [channel]</em>  # 订阅一个或多个频道</li><li><em>unsubscribe [channel]</em>  # 取消订阅一个或多个频道</li><li><em>psubscribe [pattern…]</em>  # 订阅一个或多个符合给定模式的频道<br>e.g., psubscribe it*   # 将会订阅以it开头的频道</li><li><em>punsubscribe [pattern…]</em>  # 取消订阅一个或多个符合给定模式的频道</li><li><em>pubsub channels</em>  # 列出至少有一个订阅者的频道</li><li><em>pubsub numsub [channels…]</em>  # 列出给定频道的订阅者数量</li></ol><h3 id="与消息队列的区别"><a class="markdownIt-Anchor" href="#与消息队列的区别"></a> 与消息队列的区别</h3><p>发布订阅时，所以订阅者都可以收到发布者的信息，而消息队列是消息订阅者从消息队列中取消息，不保证每个消息订阅者都可以得到消息。</p><h2 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h2><h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3><p>位图（也称为位数组，位向量等）是紧凑存储位的数组数据结构。redis提供了对位的操作。</p><img src="/Redis其他特性和功能/位图.png" title="位图"><h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3><p>位数组是自动扩展的，如果超出现有内容范围，它会自动将位数组进行零扩充。</p><img src="/Redis其他特性和功能/位图特征.png" title="位图特征"><h3 id="api-2"><a class="markdownIt-Anchor" href="#api-2"></a> API</h3><ol><li><em>setbit key offset value</em> # 给位图指定偏移量设置值</li><li><em>getbit key offset</em> #  得到指定偏移量的值</li><li><em>bitcount  key [start end]</em> #  获取位图指定范围(start - end, 单位为字节， 不指定则代表获取全部)位值位1的个数</li><li><em>bitop  op destkey key[key…]</em>  #  对多个位图进行 and (交集)，or(并集)，not(非)，xor(异或)操作，并把结果保存在 destkey 中</li><li><em>bitpos  key targetBit [start] [end]</em>   #计算位图指定范围(start-end, 单位为字节, 不指定则代表获取全部)第一个值等于 targetBit 的偏移量</li></ol><h3 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h3><ol><li>Type = String, 最大512MB</li><li>注意setbit时的偏移量，可能损耗大</li><li>活跃用户统计/用户的签到等等应用都有奇效</li></ol><h2 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h2><h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3><p>基于HyperLogLog算法，极小空间完成独立数量（基数）统计。本质还是字符串。<br>基数统计：一个集合（注意：这里集合的含义是 Object 的聚合，可以包含重复元素）中不重复元素的个数。例如集合 {1,2,3,1,2}，它有5个元素，但它的基数/Distinct 数为3。</p><h3 id="api-3"><a class="markdownIt-Anchor" href="#api-3"></a> API</h3><ol><li><em>pfadd key element [element…</em> # 向hyperloglog添加元素</li><li><em>pfcount key [key…</em> # 计算hyperloglog的独立总数</li><li><em>pfmerge destkey  sourcekey[sourcekey…</em> # 合并多个hyperloglog</li></ol><h3 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h3><ol><li>存在错误率 - 0.81%</li><li>不能取出单条数据</li><li>鉴于 HyperLogLog 不保存数据内容的特性，所以，它只适用于一些特定的场景。例如计算日活、月活数据等等</li></ol><h2 id="geo-redis-32支持"><a class="markdownIt-Anchor" href="#geo-redis-32支持"></a> GEO - redis 3.2+支持</h2><h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3><p>GEO: 地理信息定位，存储经纬度，计算两地距离，范围计算等。redis的geo实现采用数据结构为zset</p><h3 id="api-4"><a class="markdownIt-Anchor" href="#api-4"></a> API</h3><ol><li>geoadd key longitude latitude member [longitude latitude member… # 增加地理位置信息<br>e.g., geoadd city:location 116.28 39.55 bejing</li><li>geopos key member [member… # 获取地理位置信息</li><li>geolist key member1 member2 [unit] # 获取两个地理位置的距离 unit: m, km, mi, ft</li><li>georadius<img src="/Redis其他特性和功能/GEO.png" title="GEO"></li><li>zrem key member # edis的geo实现采用数据结构为 zset，遂可以使用zset API进行删除</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;慢查询&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#慢查询&quot;&gt;&lt;/a&gt; 慢查询&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h3&gt;
&lt;p&gt;慢查询日
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和相应操作</title>
    <link href="http://www.huangbin.fun/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%9B%B8%E5%BA%94%E6%93%8D%E4%BD%9C.html"/>
    <id>http://www.huangbin.fun/Redis数据结构和相应操作.html</id>
    <published>2020-04-10T12:00:59.000Z</published>
    <updated>2020-04-14T02:34:47.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis通用操作"><a class="markdownIt-Anchor" href="#redis通用操作"></a> Redis通用操作</h2><ol><li><em>Keys [pattern]</em> # 遍历出指定模式的key，可使用 <em>, ?等通配符 - 一般不在生产环境中使用，O(n)<br>  _Keys</em>_  # 遍历出所有key<br>  <em>Keys he[h-l]*</em>   # 遍历以 he 开头，第三个字符在 h-l 期间的匹配key</li><li><em>dbsize</em> # 计算 key 的总数，O(1)</li><li><em>exists key</em> # 检查 key 是否存在，O(1)级别时间复杂度</li><li><em>del key</em> # 删除指定 key ，O(1)</li><li><em>expire key seconds</em> #  key在 seconds 秒后过期 ，O(1)</li><li><em>ttl key</em> #  查看 key 剩余过期时间  -1 表达无过期时间  -2表示已过期，O(1)</li><li><em>persist key</em> #  去掉 key 的过期时间 ，O(1)</li><li><em>type key</em> # 返回 key 的类型 ，O(1)</li></ol><h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> String类型</h2><h3 id="string键值结构"><a class="markdownIt-Anchor" href="#string键值结构"></a> String键值结构</h3><img src="/Redis数据结构和相应操作/String数据结构.png" title="String数据结构"><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><em>get key</em> # 获取 key 对应value ，O(1)</li><li><em>set key value</em> # 设置 key-value ，已有相同 key 值，则进行覆盖，O(1)</li><li><em>setnx key value</em> # 设置 key-value ，key 不存在，才进行设置，O(1)</li><li><em>set key value</em> xx # 设置 key-value ，key 存在，才进行设置，O(1)</li><li><em>del key</em> # 删除 key-value ，O(1)</li><li><em>incr key</em> # key 自增1, 如果key不存在，自增都get(key)=1 ，O(1)</li><li><em>decr key</em> # key 自减1, 如果key不存在，自减都get(key)=-1 ，O(1)</li><li><em>incrby key k</em> # key 自增k, 如果key不存在，自增都get(key)=k ，O(1)</li><li><em>decrby key k</em> # key 自减k, 如果key不存在，自减都get(key)=-k，O(1)</li><li><em>mget key1 key2  key3…</em> # 批量获取key，原子操作，O(n)</li><li><em>mset key1 value1 key2 value2 key3 value3…</em> # 批量设置key-value，原子操作，O(n)</li><li><em>getset key newvalue</em>   #  set key newvalue并返回 oldvalue，O(1)</li><li><em>append key value</em>   #  将 value 将追加到  oldvalue，O(1)</li><li><em>strlen key</em>   #  返回字符串长度（注意中文） ，O(1)</li><li><em>incrbyfloat key floatValue</em>   #  增加key 对应的值 ，O(1)</li><li><em>getrange key start end</em>   #  获取字符串指定下标的所有值 ，O(1)</li><li><em>setrange key index value</em>   #  设置指定下标对应的值 ，O(1)</li></ol><h2 id="hash类型"><a class="markdownIt-Anchor" href="#hash类型"></a> Hash类型</h2><h3 id="hash键值结构"><a class="markdownIt-Anchor" href="#hash键值结构"></a> Hash键值结构</h3><img src="/Redis数据结构和相应操作/Hash数据结构.png" title="Hash数据结构"><p>注： field不能相同，value可以相同</p><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><ol><li><em>hget key field</em> # 获取 hash key 对应field 的 value ，O(1)</li><li><em>hset key field value</em> # 设置 hash key 对应field 的 value ，O(1)</li><li><em>hdel key field</em> # 删除 hash key 对应field 的 value ，O(1)</li><li><em>hexists key field</em> # 判断 hash key 是否有对应 field ，O(1)</li><li><em>hlen key</em> # 获取 hash key 的 field 数量，O(1)</li><li><em>hmget key field1 field2…</em>  # 批量获取hash-key的一批 field 对应值，O(n)</li><li><em>hmset key  field1 value1 field2 value2…</em> # 批量设置 hash-key的一批 field 对应值，O(n)</li><li><em>hgetall key</em>   # 返回 hash-key 对应所有的 field-value 值，O(n)</li><li><em>hvals key</em>   # 返回 hash-key 对应所有 field 的 value 值，O(n)</li><li><em>hkeys key</em>   # 返回 hash-key 对应所有 field ，O(n)</li><li><em>hincrby key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hincrbyfloat key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hsetnx key field value</em> # 设置 hash key对应 field的 value ，field 不存在，才进行设置，O(1)</li></ol><h2 id="list类型"><a class="markdownIt-Anchor" href="#list类型"></a> List类型</h2><h3 id="list键值结构"><a class="markdownIt-Anchor" href="#list键值结构"></a> List键值结构</h3><img src="/Redis数据结构和相应操作/List数据结构.png" title="List数据结构"><p>注: 有序（由插入顺序决定遍历顺序），可以重复，左右两边插入弹出</p><h3 id="操作-3"><a class="markdownIt-Anchor" href="#操作-3"></a> 操作</h3><ol><li><em>rpush key value1 value2…</em> # 从列表的右端插入值 ，O(1~n)</li><li><em>lpush key value1 value2…</em> # 从列表的左端插入值 ，O(1~n)</li><li>linsert key before/after value newvalue # 在list指定的值前|后插入新值，O(n)</li><li><em>lpop key</em>  # 从列表的左端弹出一个值（删除） ，O(1)</li><li><em>rpop key</em>  # 从列表的右端弹出一个值（删除） ，O(1)</li><li><em>lrem key count value</em>  # 根据 count  值，从列表中删除所有 value  相等的项 ，O(n)<ul><li>count  &gt; 0 , 从左到右，删除最多 count  个 value  相等的项目</li><li>count  &lt; 0 , 从右到左，删除最多 Math.abs(count)  个 value  相等的项目</li><li>count  = 0 , 删除所有 value  相等的项目</li></ul></li><li><em>ltrim key start end</em>  # 按照索引范围(索引从 0 开始 ，-1 表示最后一个元素)修剪列表 ，O(n)</li><li><em>lrange key start end</em>  # 获取列表指定索引范围(索引从 0 开始，-1 表示最后一个元素，包括 end )的值 ，O(n)<ul><li>lrange list 0 5 = lrange list -6 -1 = lrange list 0 -1</li></ul></li><li><em>lindex key index</em>  # 获取列表指定索引的值 ，O(n)</li><li><em>llen key</em>  # 获取列表长度 ，O(1)</li><li><em>lset key index newValue</em>  # 设置列表指定索引的值 ，O(n)</li><li><em>blpop key timeout</em>  # lpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li><li><em>rlpop key timeout</em>  # rpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li></ol><h2 id="set类型"><a class="markdownIt-Anchor" href="#set类型"></a> Set类型</h2><h3 id="set键值结构"><a class="markdownIt-Anchor" href="#set键值结构"></a> Set键值结构</h3><img src="/Redis数据结构和相应操作/Set数据结构.png" title="Set数据结构"><p>注: 无序（顺序不由插入顺序决定），不可重复，支持集合间的操作</p><h2 id="操作-4"><a class="markdownIt-Anchor" href="#操作-4"></a> 操作</h2><ol><li><em>sadd key value1 value2…</em>.  # 向集合 key 中添加元素，若已有重复元素，则添加失败 ，O(n)</li><li><em>srem key value1 value2…</em>. # 移除集合 key 中元素，O(n)</li><li><em>scard key</em>   # 计算集合元素个数，O(1)</li><li><em>sismember key value</em> # 判断集合 key 中 value 元素是否存在，O(n)</li><li><em>srandmember key count</em>  # 随机从集合 key 中挑选 count  个元素，O(n)</li><li><em>spop key</em>  # 随机从集合 key 中挑选 1 个元素，O(1)</li><li><em>smembers key</em>  # 获取集合 key 中所有元素，O(n)</li><li><em>sdiff key1 key2</em>  # 两个集合的差集，O(n)</li><li><em>sinter key1 key2</em>  # 两个集合的交集，O(n)</li><li><em>sunion key1 key2</em>  # 两个集合的并集，O(n)</li><li><em>sunionstore/sdiffstore/sinterstore destkey key1 key2</em>   # 并集/差集/交集结果存到 destkey  中，O(n)</li></ol><h2 id="sorted-set类型"><a class="markdownIt-Anchor" href="#sorted-set类型"></a> Sorted Set类型</h2><h3 id="sorted-set键值结构"><a class="markdownIt-Anchor" href="#sorted-set键值结构"></a> Sorted Set键值结构</h3><img src="/Redis数据结构和相应操作/SortedSet数据结构.png" title="SortedSet数据结构"><p>注: 有序，不可重复，支持集合间的操作</p><h2 id="操作-5"><a class="markdownIt-Anchor" href="#操作-5"></a> 操作</h2><ol><li><em>zadd key score value score2 value2…</em>.  # 向有序集合 key 中添加score value对，value不可重复元素，否则添加失败 ，O(logN)</li><li><em>zrem key  value  value2…</em>.  # 删除有序集合 key 中添加元素 ，O(1)</li><li><em>zscore key  value</em>   # 获取有序集合 key 中 value 对应的 score ，O(1)</li><li><em>zincrby key increScore value</em>   # 增加有序集合 key 中 value 对应的 score 值，O(1)</li><li><em>zcard key</em>   # 获取有序集合 key 中 value 个数，O(1)</li><li><em>zrank key value</em>   # 获取有序集合 key 中 value 的排名(从低到高)，O(1)</li><li><em>zrevrank key value</em>   # 获取有序集合 key 中 value 的排名(从高到低)，O(1)</li><li><em>zrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 降序，O(logn + m)</li><li><em>zrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 降序，O(logn + m)</li><li><em>zcount key minScore maxScore</em>    #  获取有序集合指定分数范围的值的个数 ，O(logn + m)</li><li><em>zremrangebyrank key start end</em> #  删除指定排名内的升序元素，O(logn + m)</li><li><em>zremrangebyscore key minScore maxScore</em> #  删除指定分数范围的升序元素，O(logn + m)</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="http://redisdoc.com/" rel="external nofollow noopener noreferrer" target="_blank">http://redisdoc.com/</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis通用操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis通用操作&quot;&gt;&lt;/a&gt; Redis通用操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Keys [pattern]&lt;/em&gt; # 遍历出指定模式的key，可使用 &lt;em
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis是什么?</title>
    <link href="http://www.huangbin.fun/Redis%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
    <id>http://www.huangbin.fun/Redis是什么.html</id>
    <published>2020-04-10T11:51:51.000Z</published>
    <updated>2020-04-14T02:34:53.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted set），哈希（Hash）。</p><h2 id="数据结构和内部编码"><a class="markdownIt-Anchor" href="#数据结构和内部编码"></a> 数据结构和内部编码</h2><img src="/Redis是什么/数据结构图.png" title="数据结构图"><p>Redis 源码中设置了一个redisObject数据结构，描述了此种关系。</p><img src="/Redis是什么/内部编码图.png" title="内部编码图"><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ol><li>速度快 - 基于内存，C语言编写，单线程 - 纯内存，非阻塞IO（实时性好，但是占用大量CPU资源），避免线程切换和竞态消耗。</li><li>持久化 - Rdis所有数据保持在内存中，可对数据进行持久化在磁盘中。</li><li>多种数据结构，在新的版本中，还提供了位图（Bitmaps），超小内存唯一值计数（HyperLogLog），地理信息定位（GEO）数据结构。但是其数据结构内部还是基于上述五种基本的数据结构实现的，Bitmaps，HyperLogLog都是String数据类型。</li><li>支持多种客户端语言 - Java, PHP, Python等。</li><li>功能丰富 - 发布订阅, 事务, Lua脚本, pipeline。</li><li>“简单” - 不依赖外部库，单线程模型。</li><li>主从复制</li><li>高可用 - Redis-Sentinel(V2.8)，分布式 - Redis-Cluster(V3.0)</li><li>多数据库 - 一个redis实例包括了15个数据库，可以选择连接哪个数据据进行操作。选择数据据命令为select 1。 同时可以选择move somekey 1把当前数据库的key移动到数据库1。</li><li>事务 - multi：开始事务，后面的命令都会被认为是事务的一部分操作；exec：提交事务；discard：事务回滚。</li><li>注意: Redis是单线程，一次执行一条命令，所以拒绝长（慢命令） - keys，flushall，flushdb，slow，lua script，mutil/exec，operate big value(collection)。对于fysnc file descriptor，close file descriptor会开启另外一个独立线程进行操作。</li></ol><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li>缓存系统</li><li>消息队列 - 秒杀，抢购等。<a href="https://www.zhihu.com/question/54152397" rel="external nofollow noopener noreferrer" target="_blank">什么是消息队列？</a></li><li>计数器 - 网站访问统计，微博转发评论，视频播放</li><li>排行榜</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted se
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长公共前缀</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长公共前缀.html</id>
    <published>2019-10-20T09:11:56.000Z</published>
    <updated>2019-10-20T09:17:44.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br></p><ul><li><p>示例 1:<br>输入: [“flower”,“flow”,“flight”]<br>输出: “fl”<br></p></li><li><p>示例 2:<br>输入: [“dog”,“racecar”,“car”]&lt;<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="垂直扫描法"><a class="markdownIt-Anchor" href="#垂直扫描法"></a> 垂直扫描法</h2><p><img src="https://pic.leetcode-cn.com/b647cab7c3d2bd157cecae10917e0b9b671756b92c9cfcefec1a2bdae299c11c-file_1555694071243" alt="水平扫描法"></p><ol><li>取出第一个字符串暂时作为最长公共前缀（prefixStr）；</li><li>依次遍历字符串数组中的其他字符串，分别与prefixStr比较；</li><li>若当前字符不包含prefixStr，则对prefixStr进行裁取（长度减一），再次与当前字符进行比较；</li><li>若当前字符包含prefixStr，则取出字符串数组的下一个字符串与prefixStr进行比较；</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><ul><li>时间复杂度：O(S)，S是所有字符串中字符数量的总和，最坏情况时n个字符串全部相同，则indexOf要比较S次字符比较</li><li>空间复杂度：O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) return &quot;&quot;;</span><br><span class="line">        String prefixStr = strs[0];  </span><br><span class="line">        for(int i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">            while(strs[i].indexOf(prefixStr) != 0)&#123;  </span><br><span class="line">                prefixStr = prefixStr.substring(0,prefixStr.length() - 1); </span><br><span class="line">                if(prefixStr.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefixStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平扫描法"><a class="markdownIt-Anchor" href="#水平扫描法"></a> 水平扫描法</h2><ol><li>取出字符串数组中的第一个字符串，遍历该字符串中的字符，依次与数组中的其他字符串的同列字符比较；</li><li>若出现不同的字符，则对第一个字符串进行相应位置截取，便得最长公共前缀；</li><li>若某字符串长度等于当前所比较字符位置（i = strs[j].length()），则也进行第2步的截取操作；</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><ul><li>时间复杂度: O(S)，S 是所有字符串中字符数量的总和</li><li>空间复杂度: O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for(int i = 0; i &lt; strs[0].length(); i++)&#123;</span><br><span class="line">            char a = strs[0].charAt(i);</span><br><span class="line">            for(int j = 1; j &lt; strs.length; j++)&#123;</span><br><span class="line">                if( i == strs[j].length() || a != strs[j].charAt(i))&#123;    // 先执行||, 然后执行后面, 且i == strs[j].length()表示存在字符串已经遍历完</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt; 无重复字符的最长子串长度</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html"/>
    <id>http://www.huangbin.fun/LeetCode-无重复字符的最长子串长度.html</id>
    <published>2019-10-12T06:52:59.000Z</published>
    <updated>2019-10-20T09:18:15.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br></p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h2><p>滑动窗口算法用于对给定的大缓冲区或数组的特定窗口大小执行所需的操作(即在遍历大缓存区或数组时, 对其特定的窗口大小执行特定操作)。目的是将很少出现问题的嵌套for循环转换为单个for循环，从而降低时间复杂度。例如: 找出某数组中和最大的子数组， 规定子数组元素个数为3， 即窗口大小为3， 当然窗口大小也可以是动态的。具体过程如下：<br><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动过程"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>实现一</strong></p><ul><li>时间复杂度: O(2n)=O(n)，最糟糕的情况下，每个字符要被i，j分别访问一次</li><li>空间复杂度: O(min(m, n))，滑动窗口法需要 O(k)的空间，其中 k表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int record = 0,i = 0,j = 0;  // record记录最长子串长度</span><br><span class="line">        int length = s.length(); </span><br><span class="line">        Set strSet = new HashSet();  // 使用HashSet作为滑动窗口</span><br><span class="line">        while(i &lt; length &amp;&amp; j &lt; length)&#123;</span><br><span class="line">            if(!strSet.contains(s.charAt(j)))&#123;  // s.charAt(j)不在strSet中</span><br><span class="line">                strSet.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                record = Math.max(record, j - i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                strSet.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现二</strong><br><br>该实现是对滑动窗口的优化，即在窗口中存在与当前元素相同的字符，直接把窗口左端移动到相同字符的后一位，而不是一步一步的移动左端窗口。</p><ul><li>时间复杂度: O(n)，单单j会遍历n次</li><li>空间复杂度: O(min(m, n))</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length(), record = 0;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0, j = 0; j &lt; length; j++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(j)))&#123;  // 包含了有相同字符</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)),i);  // 把i定位到存储在map中且与s.charAt(j)相同的字符的下一个索引位置</span><br><span class="line">            &#125;</span><br><span class="line">            record = Math.max(record,j - i + 1);  // + 1是因为前面已经排除了相同字符, 遂可把s.charAt(j)字符加入参与长度计算 </span><br><span class="line">            map.put(s.charAt(j), j + 1);  // 把s.charAt(j)索引+1是方便i的定位(定位到相同元素的后一位)</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例 1:&lt;br&gt;
输入: “abc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习课程练习代码实现(Octave版/Python版)</title>
    <link href="http://www.huangbin.fun/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html"/>
    <id>http://www.huangbin.fun/吴恩达机器学习课程练习代码实现-Octave版-Python版.html</id>
    <published>2019-10-09T11:35:21.000Z</published>
    <updated>2019-10-09T11:44:04.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习课程练习代码实现octave版python版"><a class="markdownIt-Anchor" href="#吴恩达机器学习课程练习代码实现octave版python版"></a> 吴恩达机器学习课程练习代码实现(Octave版/Python版)</h1><p> 吴恩达老师的机器学习课程成为了众多机器学习爱好者进入机器学习世界的敲门砖, 老师通俗易懂的授课方式让人能够快速的了解机器学习。 老师的课后练习使用Octave语言进行编写, 但是现在机器学习中使用更加普遍的是Python语言, 为了兼顾两者, 我就自己编写的两个版本的代码实现进行分享。对于每个作业PDF文档也进行了相应注释。</p><ul><li>Linear Regression</li><li>Logistic Regression</li><li>Neural Network</li><li>NN Back Propagation</li><li>Bias vs Variance</li><li>SVM</li><li>Kmeans and PCA</li><li>Anomaly Detection and Recommendation</li></ul><p>  <strong>具体代码文档下载链接:</strong> <a href="https://github.com/hbheyho/MachineLearningExam-Andrew-Ng" rel="external nofollow noopener noreferrer" target="_blank">MachineLearningExam-Andrew-Ng</a><br> ps: 若查看Python版本, 建议使用Jupyter Notebook进行阅读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;吴恩达机器学习课程练习代码实现octave版python版&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#吴恩达机器学习课程练习代码实现octave版python版&quot;&gt;&lt;/a&gt; 吴恩达机器学习课程练习代码实现(Octave版/Pytho
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://www.huangbin.fun/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://www.huangbin.fun/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务/脚本/命令自启动配置</title>
    <link href="http://www.huangbin.fun/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.huangbin.fun/Linux-服务-脚本-命令自启动配置.html</id>
    <published>2019-07-31T07:31:16.000Z</published>
    <updated>2019-07-31T07:37:22.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux服务自启动"><a class="markdownIt-Anchor" href="#linux服务自启动"></a> Linux服务自启动</h2><p> 若程序（脚本）已注册成服务，则可通过service serviceName start/stop/status来启动服务、停止服务和查看服务状态，也可通过/etc/init.d/serviceName start/stop来开启和停止服务。<br> 可通过/etc/rc.d/init.d或/etc/init.d查看linux全部服务。</p><h3 id="方法一修改配置文件"><a class="markdownIt-Anchor" href="#方法一修改配置文件"></a> 方法一：修改配置文件</h3><p> 修改 /etc/rc.d/rc.local或/etc/rc.local文件（该文件在系统启动时，在输入用户名和密码之前最后读取的文件），加入服务启动命令来实现服务自启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"># 系统启动时，tomcat6服务自启动</span><br><span class="line">/etc/rc.d/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><h3 id="方法二chkconfig命令"><a class="markdownIt-Anchor" href="#方法二chkconfig命令"></a> 方法二：chkconfig命令</h3><p> chkconfig命令格式：<em>chkconfig serviceName on/off</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自启动tomcat服务</span><br><span class="line">chkconfig tomcat on</span><br><span class="line">#关闭tomcat自启动</span><br><span class="line">chkconfig tomcat off</span><br></pre></td></tr></table></figure><h3 id="方法三通过ntsysv调用窗口模式来管理服务的自启动"><a class="markdownIt-Anchor" href="#方法三通过ntsysv调用窗口模式来管理服务的自启动"></a> 方法三：通过ntsysv调用窗口模式来管理服务的自启动</h3><p> ntsysv命令格式：<em>ntsysv [–level 运行级别]</em><br>          --level 运行级别：可以指定设定自启动的运行级别；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只设定2、3、5级别的服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv --level 235</span><br><span class="line">#按默认的运行级别设置服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv</span><br></pre></td></tr></table></figure><p>执行上述命令之后linux界面如下，使用空格键来选定/取消服务的自启动，其中*号代表该服务自启动。</p><img src="/Linux-服务-脚本-命令自启动配置/ntsysv设置自启动.png" title="ntsysv设置自启动"><p><strong>注意：ntsysv属于redhat系列linux的专有命令</strong></p><h2 id="linux脚本自启动"><a class="markdownIt-Anchor" href="#linux脚本自启动"></a> Linux脚本自启动</h2><h3 id="方法一把脚本放到etcrclocal"><a class="markdownIt-Anchor" href="#方法一把脚本放到etcrclocal"></a> 方法一：把脚本放到/etc/rc.local</h3><p>脚本文件start_tomcat.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#启动tomcat</span><br><span class="line">/etc/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><p>把需自启动的脚本文件放入/etc/rc.local</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#当系统启动时便执行start_tomcat.sh脚本</span><br><span class="line">/root/start_tomcat.sh        #脚本执行方式：绝对路径执行方式，path/脚本文件</span><br></pre></td></tr></table></figure><h3 id="方法二把sh脚本移动到etcprofiled"><a class="markdownIt-Anchor" href="#方法二把sh脚本移动到etcprofiled"></a> 方法二：把sh脚本移动到/etc/profile.d</h3><p> /etc/profile.d中的脚本文件执行情景：当一个用户登录Linux系统或使用切换到另一个用户时才会调用，所以不建议使用</p><h2 id="linux自启动命令"><a class="markdownIt-Anchor" href="#linux自启动命令"></a> Linux自启动命令</h2><p> 若要自启动命令，则把需要自启动的命令放在/etc/rc.local中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux服务自启动&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux服务自启动&quot;&gt;&lt;/a&gt; Linux服务自启动&lt;/h2&gt;
&lt;p&gt; 若程序（脚本）已注册成服务，则可通过service serviceName start/sto
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://www.huangbin.fun/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://www.huangbin.fun/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Shell提取文件名称和目录方法</title>
    <link href="http://www.huangbin.fun/Linux-Shell%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/Linux-Shell提取文件名称和目录方法.html</id>
    <published>2019-07-31T06:52:14.000Z</published>
    <updated>2019-07-31T06:55:47.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单路径提取"><a class="markdownIt-Anchor" href="#单路径提取"></a> 单路径提取</h2><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用${}</h3><p> ${}主要用来进行变量的提取和替换等等操作，它可以提取非常多的内容，<strong>提取文件路径知识它使用的一个特例</strong>。</p><ul><li>#：表示从左边算起第一个</li><li>%：表示从右边算起第一个</li><li>##：表示从左边算起最后一个</li><li>%%：表示从右边算起最后一个</li><li>＊：表示要删除的内容，对于#和##的情况，它位于指定的字符（例子中的’/‘和’.’）的左边，表于删除指定字符及其左边的内容；对于%和%%的情况，它位于指定的字符（例子中的’/‘和’.’）的右边，表示删除指定字符及其右边的内容。这里的’*'的位置不能互换，即不能把*号放在#或##的右边，反之亦然。</li></ul><h4 id="filepath"><a class="markdownIt-Anchor" href="#filepath"></a> ${filePath##*/}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’/‘字符及其左边的内容，返回从左边算起的最后一个’/’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo $&#123;filePath##*/&#125;</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><h4 id="filepath-2"><a class="markdownIt-Anchor" href="#filepath-2"></a> ${filePath##*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’.‘字符及其左边的内容，返回从左边算起的最后一个’.’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath##*.&#125;</span><br><span class="line">txt</span><br></pre></td></tr></table></figure><h4 id="filepath-3"><a class="markdownIt-Anchor" href="#filepath-3"></a> ${filePath#*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的第一个’.‘字符及其左边的内容，返回从左边算起第一个’.’（不含该字符）的右边部分的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.tar.zip&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath#*.&#125;</span><br><span class="line">tar.zip</span><br></pre></td></tr></table></figure><h4 id="filepath-4"><a class="markdownIt-Anchor" href="#filepath-4"></a> ${filePath%/*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的第一个’/‘字符及其右边的内容，返回从右边算起的第一个’/’（不含该字符）的左边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%/*&#125;</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h4 id="filepath-5"><a class="markdownIt-Anchor" href="#filepath-5"></a> ${filePath%%.*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的最后一个’.‘字符及其右边的内容，返回从右边算起的最后一个’.’（不含该字符）的左边的内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%%.*&#125;</span><br><span class="line">/tmp/test</span><br></pre></td></tr></table></figure><h3 id="使用basename-dirname"><a class="markdownIt-Anchor" href="#使用basename-dirname"></a> 使用basename、dirname</h3><p> basename和dirname命令就是专门为做这一件事而已准备的了。</p><h4 id="basename"><a class="markdownIt-Anchor" href="#basename"></a> basename</h4><p> 该命令的作用是从路径中提取出文件名，使用方法为basename NAME [SUFFIX]。</p><ul><li>从路径中提出文件名（带后缀）：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath)</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><ul><li>从上面命令的用法中可以看到，后缀（SUFFIX）是一个可选项。所以，若只想提取出文件名file，而不带有后缀，还可以在变量的后面加上后缀名：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath .txt)</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="dirname"><a class="markdownIt-Anchor" href="#dirname"></a> dirname</h4><p>  该命令的作用是从路径中提取出目录名，使用方法为 dirname NAME</p><ul><li>提取test.txt所在目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirname /tmp/test.txt</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><p>注：该命令不仅能提取出普通文件所的目录，它能提取出任何文件所在的目录，例如目录所在的目录，如下：</p><ul><li>提取目录的目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirPath=/tmp/testDir/</span><br><span class="line">[root@localhost tmp]# dirname $dirPath</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h2 id="提取目录中所有文件名称"><a class="markdownIt-Anchor" href="#提取目录中所有文件名称"></a> 提取目录中所有文件名称</h2><h3 id="get_filenamesh"><a class="markdownIt-Anchor" href="#get_filenamesh"></a> get_fileName.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">folderPath=&quot;/root&quot;</span><br><span class="line">files=$(ls $FloderPath)</span><br><span class="line">for filename in $files</span><br><span class="line">do</span><br><span class="line">echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# bash get_fileName.sh</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">start_tomcat.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单路径提取&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单路径提取&quot;&gt;&lt;/a&gt; 单路径提取&lt;/h2&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用&quot;&gt;&lt;/a&gt; 使用${}&lt;/h3
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://www.huangbin.fun/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://www.huangbin.fun/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[转]Linux中防火墙概述</title>
    <link href="http://www.huangbin.fun/%E8%BD%AC-Linux%E4%B8%AD%E9%98%B2%E7%81%AB%E5%A2%99%E6%A6%82%E8%BF%B0.html"/>
    <id>http://www.huangbin.fun/转-Linux中防火墙概述.html</id>
    <published>2019-07-15T06:17:25.000Z</published>
    <updated>2019-07-30T08:56:04.873Z</updated>
    
    <content type="html"><![CDATA[<p>Linux防火墙概述</p><p><strong>转载</strong>： <a href="http://www.zsythink.net/archives/1199" rel="external nofollow noopener noreferrer" target="_blank">http://www.zsythink.net/archives/1199</a></p><h3 id="防火墙相关概述"><a class="markdownIt-Anchor" href="#防火墙相关概述"></a> 防火墙相关概述</h3><p>  从逻辑上讲。防火墙可以大体分为主机防火墙和网络防火墙。</p><ul><li>主机防火墙：针对于单个主机进行防护。</li><li>网络防火墙：往往处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。</li></ul><p>  网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。<br>  从物理上讲，防火墙可以分为硬件防火墙和软件防火墙。</p><ul><li>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。</li><li>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。</li></ul><h3 id="iptables是什么"><a class="markdownIt-Anchor" href="#iptables是什么"></a> iptables是什么</h3><p>  iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的安全框架中，这个安全框架才是真正的防火墙，这个框架的名字叫netfilter。netfilter才是防火墙真正的安全框架（framework），netfilter位于内核空间。<br>  iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。<br>  netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。<br>  Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p><ul><li>网络地址转换(Network Address Translate)</li><li>数据包内容修改</li><li>数据包过滤的防火墙功能</li></ul><p>  所以说，虽然我们使用service iptables start启动iptables服务，但是其实准确的来说，iptables并没有一个守护进程，所以并不能算是真正意义上的服务，而应该算是内核提供的功能。</p><h3 id="规则的定义"><a class="markdownIt-Anchor" href="#规则的定义"></a> 规则的定义</h3><p>  <strong>规则</strong>：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。配置防火墙的主要工作就是添加、修改和删除这些规则。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。<br>  那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条链都是一个关卡，每个通过这个关卡的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个报文，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的规则，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合器宇轩昂的标准，所以把你放行了，而我不符合标准，所以没有被放行，其实，<strong>器宇轩昂就是一种匹配条件，放行就是一种动作，匹配条件与动作组成了规则</strong>。<br>  规则由匹配条件和处理动作组成。</p><ul><li><p>匹配条件分为基本匹配条件与扩展匹配条件</p><ul><li>基本匹配条件：源地址Source IP，目标地址 Destination IP</li><li>扩展匹配条件：除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。源端口Source Port, 目标端口Destination Port都可以作为扩展匹配条件。</li></ul></li><li><p>处理动作在iptables中被称为target，动作也可以分为基本动作和扩展动作。</p><ul><li>ACCEPT：允许数据包通过。</li><li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li><li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li><li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li><li>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li><li>DNAT：目标地址转换。</li><li>REDIRECT：在本机做端口映射。</li><li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li></ul></li></ul><h3 id="链的定义"><a class="markdownIt-Anchor" href="#链的定义"></a> 链的定义</h3><p>  我们知道，防火墙的作用就在于对经过的报文匹配规则，然后执行对应的动作 , 所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了链 , 每个经过这个关卡的报文，都要将这条链上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。</p><img src="/转-Linux中防火墙概述/链的定义.png" title="链的定义"><h3 id="表的定义"><a class="markdownIt-Anchor" href="#表的定义"></a> 表的定义</h3><p>  我们对每个链上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。<br>  我们把具有相同功能的规则的集合叫做表，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下表</p><ul><li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li><li>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</li><li>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</li><li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</li></ul><p>  也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张表中。</p><h3 id="链和表关系"><a class="markdownIt-Anchor" href="#链和表关系"></a> 链和表关系</h3><p>  但是我们需要注意的是，某些链中注定不会包含某类规则，就像某些关卡天生就不具备某些功能一样，比如，A关卡只负责打击陆地敌人，没有防空能力，B关卡只负责打击空中敌人，没有防御步兵的能力，C关卡可能比较NB，既能防空，也能防御陆地敌人，D关卡最屌，海陆空都能防。<br>  让我们看看每个链上的规则都存在于哪些表中。</p><ul><li>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</li><li>INPUT的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</li><li>FORWARD的规则可以存在于：mangle表，filter表。</li><li>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</li><li>POSTROUTING的规则可以存在于：mangle表，nat表。</li></ul><p>  但是，我们在实际的使用过程中，往往是通过表作为操作入口，对规则进行定义的，之所以按照上述过程介绍iptables，是因为从关卡的角度更容易从入门的角度理解，但是为了以便在实际使用的时候，更加顺畅的理解它们，此处我们还要将各表与链的关系罗列出来，<br>表（功能）-----------------------&gt; 链（钩子）：</p><ul><li>raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT</li><li>mangle表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li><li>nat表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）</li><li>filter表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</li></ul><img src="/转-Linux中防火墙概述/链与表关系.png" title="链与表关系"><p>  其实我们还需要注意一点，因为数据包经过一个链的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张表中，那么，哪些表中的规则会放在链的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting链做图示。</p><img src="/转-Linux中防火墙概述/preouting优先级.png" title="preouting优先级">   <p>  prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：raw --&gt; mangle --&gt; nat<br>  但是我们知道，iptables为我们定义了4张表,当他们处于同一条链时，执行的优先级如下。<br>优先级次序（由高而低）：raw --&gt; mangle --&gt; nat --&gt; filter<br>  4张表中的规则处于同一条链的目前只有output链，它就是传说中海陆空都能防守的关卡。<br>  为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较短的链子，这条短链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要焊接在iptables默认定义链子上，才能被IPtables使用。</p><h3 id="数据经过防火墙流程"><a class="markdownIt-Anchor" href="#数据经过防火墙流程"></a> 数据经过防火墙流程</h3><p>  所以，根据上图，我们能够想象出某些常用场景中，报文的流向：</p><img src="/转-Linux中防火墙概述/数据经过防火墙流程.png" title="数据经过防火墙流程"><ul><li>到本机某进程的报文：PREROUTING --&gt; INPUT</li><li>由本机转发的报文：PREROUTING --&gt; FORWARD --&gt; POSTROUTING</li><li>由本机的某进程发出报文（通常为响应报文）：OUTPUT --&gt; POSTROUTING</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux防火墙概述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载&lt;/strong&gt;： &lt;a href=&quot;http://www.zsythink.net/archives/1199&quot; rel=&quot;external nofollow noopener noreferrer&quot; target
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://www.huangbin.fun/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://www.huangbin.fun/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>为blog生成定制RSS</title>
    <link href="http://www.huangbin.fun/%E4%B8%BAblog%E7%94%9F%E6%88%90%E5%AE%9A%E5%88%B6RSS.html"/>
    <id>http://www.huangbin.fun/为blog生成定制RSS.html</id>
    <published>2019-07-02T09:48:44.000Z</published>
    <updated>2019-07-02T09:52:16.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是rss"><a class="markdownIt-Anchor" href="#什么是rss"></a> 什么是RSS？</h2><blockquote><p>RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。 你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。 它不会过时，信息越是过剩，它的意义也越加彰显。</p></blockquote><h2 id="怎么定制blogrss基于hexo"><a class="markdownIt-Anchor" href="#怎么定制blogrss基于hexo"></a> 怎么定制blogRSS（基于hexo）？</h2><p><strong>step1</strong>： 下载hexo plugin</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><strong>step2</strong>：修改_config配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  # Extensions</span><br><span class="line">plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br></pre></td></tr></table></figure><p> 属性解释：</p><ul><li>type: RSS的类型(atom/rss2)</li><li>path: 文件路径，默认是 atom.xml/rss2.xml</li><li>limit: 展示文章的数量,使用 0 或则 false 代表展示全部</li><li>hub:  PubSubHubbub hubs的URL (如果使用不到可以为空)</li><li>content: （可选）设置 true 可以在RSS文件中包含文章全部内容，默认：false</li><li>content_limit: （可选）摘要中使用的帖子内容的默认长度。 仅在content设置为false且未显示自定义帖子描述时才使用。</li><li>content_limit_delim: （可选，默认不使用）如果content_limit启用来缩短帖子内容,则在达到字符限制之前， 在分隔符最后出现时进行剪切。</li><li>order_by: 订阅内容的顺序. (默认: -date)</li><li>icon - (可选) 自定义的推送图标.默认为主配置中指定的电子邮件的gravatar。</li></ul><h2 id="生成rssatomxml"><a class="markdownIt-Anchor" href="#生成rssatomxml"></a> 生成RSS（atom.xml）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g  // 生成路径public-&gt;atom.xml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是rss&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是rss&quot;&gt;&lt;/a&gt; 什么是RSS？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://www.huangbin.fun/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>npm --save-dev与--save 的区别</title>
    <link href="http://www.huangbin.fun/npm-save-dev%E4%B8%8E-save-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://www.huangbin.fun/npm-save-dev与-save-的区别.html</id>
    <published>2019-07-02T09:08:11.000Z</published>
    <updated>2019-07-02T09:14:18.589Z</updated>
    
    <content type="html"><![CDATA[<p> npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install–save另一个是 npm install –save-dev，他们<strong>表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下</strong>，譬如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.2.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-latest"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"cross-env"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^0.25.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^11.1.4"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^2.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不过这只是它们的表面区别。它们真正的区别是：<br> <strong>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖</strong>。即devDependencies下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install–save另一个是 npm install –save-dev，他们&lt;strong&gt;表面上的区别是–save 会把依赖包名称添加到
      
    
    </summary>
    
      <category term="Node.js学习" scheme="http://www.huangbin.fun/categories/Node-js%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Node.js" scheme="http://www.huangbin.fun/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>记FTP学习的一个小坑</title>
    <link href="http://www.huangbin.fun/%E8%AE%B0FTP%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
    <id>http://www.huangbin.fun/记FTP学习的一个小坑.html</id>
    <published>2019-07-01T09:28:09.000Z</published>
    <updated>2019-07-30T08:50:37.089Z</updated>
    
    <content type="html"><![CDATA[<p> 在搭建好FTP服务器之后，用浏览器进行连接一直连接不上(<strong>在保证用户名和密码都正确的基础上</strong>)，Chrome完全没有提示信息，火狐提示如下：</p><img src="/记FTP学习的一个小坑/火狐提示信息.png" title="火狐提示信息"><p> 从提示可以看出<strong>Policy requires SSL 即SSL策略需要SSL的验证</strong>，我们只需修改自身的FTP服务器SSL配置，把需要SSL连接修改为允许SSL连接</p><img src="/记FTP学习的一个小坑/设置界面.png" title="设置界面"><p><strong>PS</strong>：需要注意的是，使用FTP客户端工具，类似于FileZilla是可以连接的，它会有相应的提示，提示说该连接不安全巴拉巴拉的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 在搭建好FTP服务器之后，用浏览器进行连接一直连接不上(&lt;strong&gt;在保证用户名和密码都正确的基础上&lt;/strong&gt;)，Chrome完全没有提示信息，火狐提示如下：&lt;/p&gt;
&lt;img src=&quot;/记FTP学习的一个小坑/火狐提示信息.png&quot; title=&quot;火狐提示
      
    
    </summary>
    
    
      <category term="FTP" scheme="http://www.huangbin.fun/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>关于Ajax异步请求的跨域以及Session问题</title>
    <link href="http://www.huangbin.fun/%E5%85%B3%E4%BA%8EAjax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8ASession%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangbin.fun/关于Ajax异步请求的跨域以及Session问题.html</id>
    <published>2019-07-01T09:16:21.000Z</published>
    <updated>2019-07-01T09:59:32.893Z</updated>
    
    <content type="html"><![CDATA[<p> 根据浏览器的保护规则，跨域时候的SeeionId是不会被保存下来，即我们的每次Ajax请求都会是一个新的请求，都会产生新的SeesionId，后台自然不能根据前台传过来的SeesionId判断你是否处于登录状态。<br> 我们可以对前台的Ajax以及后台进行相应的修改，就可以对上述问题进行完美解决：</p><h3 id="前端ajax请求"><a class="markdownIt-Anchor" href="#前端ajax请求"></a> 前端Ajax请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;    </span><br><span class="line">    url:url,</span><br><span class="line">    xhrFields: &#123;      </span><br><span class="line">         withCredentials: <span class="literal">true</span>   <span class="comment">// 加上此部分</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    crossDomain: <span class="literal">true</span>,     <span class="comment">// 加上此部分</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;, </span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="controller部分代码"><a class="markdownIt-Anchor" href="#controller部分代码"></a> Controller部分代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"XXXX.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">XXXXX</span><span class="params">( HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"><span class="comment">// 解决跨域</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>,request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line"><span class="comment">// 跨域的session 保证同一性</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Credentials"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">  somecode</span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure><p><strong>PS</strong>: withCredentials：默认情况下，跨源请求不提供凭据(cookie、HTTP认证及客户端SSL证明等)。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。<br> 如果服务器接收带凭据的请求，会用下面的HTTP头部来响应,Access-Control-Allow-Credentials: true。如果发送的是带凭据的请求，但服务器的相应中没有包含这个头部，那么浏览器就不会把相应内容交给Ajax(于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序)。<br> 支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 根据浏览器的保护规则，跨域时候的SeeionId是不会被保存下来，即我们的每次Ajax请求都会是一个新的请求，都会产生新的SeesionId，后台自然不能根据前台传过来的SeesionId判断你是否处于登录状态。&lt;br&gt;
 我们可以对前台的Ajax以及后台进行相应的修改，
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.huangbin.fun/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
