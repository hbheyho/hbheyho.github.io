<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HB&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangbin.fun/"/>
  <updated>2020-05-05T08:19:52.093Z</updated>
  <id>http://www.huangbin.fun/</id>
  
  <author>
    <name>HB</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小小String对象大大奥秘</title>
    <link href="http://www.huangbin.fun/%E5%B0%8F%E5%B0%8FString%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%A4%A7%E5%A5%A5%E7%A7%98.html"/>
    <id>http://www.huangbin.fun/小小String对象大大奥秘.html</id>
    <published>2020-05-05T07:40:48.000Z</published>
    <updated>2020-05-05T08:19:52.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串？</h2><p>字符串是由引号所括起来的一系列字符序列。例如&quot;String&quot;，&quot;Hello&quot;就为一个字符串</p><h2 id="string-的不可变性"><a class="markdownIt-Anchor" href="#string-的不可变性"></a> String 的不可变性</h2><p>&quot;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何操作都会生成新的对象“。</p><ol><li>固定不变 - 从String 对象的源码中可以看出，String 类声明为 final，且它的属性和方法都被 final 所修饰</li><li>任何操作都会生成新对象 - String:: subString()，String::concat() 等方法都会生成一个新的String对象，不会在原对象上进行操作<br>从下面String源码部分中很容易得到上面的结论：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** String 类源码 */</span><br><span class="line">public final class String </span><br><span class="line">     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line">     *</span><br><span class="line">     * A String instance is written into an ObjectOutputStream according to</span><br><span class="line">     * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line">     */</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用一段代码来揭示这个过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String start = &quot;Hello&quot;;  // 1</span><br><span class="line">        String end = start.concat(&quot; World!&quot;); // 2</span><br><span class="line">          //String end = start + &quot; World!&quot;  </span><br><span class="line">        System.out.println(end); // 3</span><br><span class="line">             System.out.println(start); // 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">Hello World!</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>在这段代码中，没有改变任何对象。首先在第一个代码中，会在堆内存中创建一个新的String 对象，并把它的引用赋值给 start，接着在第二个调用String:: concat()方法对字符串进行拼接，<strong>此时会创建一个新的String 对象，该对象是&quot;Hello&quot; 和 “World” 的串联</strong>。就如String:: concat() 源码所示，第三个/四个代码的输出结果分别为：“Hello World!”, “World”。并且操作符 &quot; + &quot;完成了和String:: concat() 类似的事 - &gt; 操作符 “+” 算是一个语法糖，查看编译之后的字节码可以知道最终会调用StringBuilder:: append() 来完成字符串的拼接。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** concat() 源码 */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length();  // 拼接的字符串参数长度为0, 返回本身</span><br><span class="line">        if (otherLen == 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length;</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true); // 创建一个新String对象来存储拼接之后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可变性设计的初衷"><a class="markdownIt-Anchor" href="#不可变性设计的初衷"></a> 不可变性设计的初衷</h2><ol><li>字符串常量池的需要。String对象的不可变性为字符串常量池的实现提供了基础，使得常量池便于管理和优化。</li><li>多线程安全。同一个字符串对象可以被多个线程共享。</li><li>安全性考虑。字符串应用场景众多，设计成不可变性可以有效防止字符串被有意篡改。</li><li>由于String对象的不可变性，可以对其HashCode进行缓存，可以作为HashMap，HashTable等集合的key 值。</li></ol><h2 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h2><p>很多文章都提及到字符串常量池是String对象的集合，这种说法很接近了，但是更准确来说，它是 <strong>String 对象引用的集合</strong> （网上关于这个众说纷纭，我更加倾向于存储的是引用的集合~ 若有错误了请指出! 谢谢~）。 虽说String 是不变的，但是它还是和Java中的其他对象一样，是分配在堆中的，所以说 <strong>String 对象存在于堆中，字符串常量池存放了它们的引用</strong>。因为 String 对象是不可变的，所以多个引用 “共享” 同一个String 对象是安全的，这种安全性就是 字符串常量池所带来的。</p><h3 id="字面量的形式创建字符串"><a class="markdownIt-Anchor" href="#字面量的形式创建字符串"></a> 字面量的形式创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;; // 1</span><br><span class="line">        String two = &quot;someString&quot;; // 2</span><br><span class="line"></span><br><span class="line">        System.out.println(one.equals(two));  // String 对象是否相同内容</span><br><span class="line">        System.out.println(one == two);  // String 对象是否相同的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>执行完上面的第一句代码之后，会在堆上创建一个String 对象，并把String 对象的引用存放到字符串常量池中，并把引用返回给 one，那当第二句代码执行时，字符串常量池已经有对应内容的引用了，直接返回对象引用给 two。one.equals(two) / one == two 都为true。 图形化如下所示：<img src="/小小String对象大大奥秘/stringLiterals1.jpg" title="stringLiterals1"></p><h3 id="new-创建字符串"><a class="markdownIt-Anchor" href="#new-创建字符串"></a> new 创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(one.equals(two));</span><br><span class="line">        System.out.println(one == two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>在使用 new关键字时的情况会有稍微不同，关于这两个字符串的引用任然会存放字符串常量池中，但是关键字 new使得虚拟机在运行时会创建一个新的String对象，而不是使用字符串常量池中已经存在的引用，此时 two 指向 堆中这个新创建的对象，而one 是常量池中的引用。 one.equals(two) 为 true，而 one == two 都为false。<img src="/小小String对象大大奥秘/stringLiterals2.jpg" title="stringLiterals2"></p><p>如果想要one，two都引用同一个对象，则可以使用 String:: intern()方法 - 当调用intern()方法时，如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中它的引用，如果没有，那就将它的引用保存一份到字符串常量池中，然后直接返回这个引用。这个方法是有返回值的，是返回引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String one = &quot;someString&quot;;</span><br><span class="line">String two = new String(&quot;someString&quot;); // 仍指向堆中new 出的新对象</span><br><span class="line">String three = two.intern(); </span><br><span class="line">System.out.println(one.equals(two)); // true</span><br><span class="line">System.out.println(one == two); // false </span><br><span class="line">System.out.println(one == three); // true</span><br><span class="line">System.out.println(two == three); // false</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a class="markdownIt-Anchor" href="#垃圾收集"></a> 垃圾收集</h3><p>当一个对象没有引用指向时，垃圾收集器便会对它进行收集操作。看下面的一个事例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        one = two = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 one = two = null时，只有一个对象会被回收，String 对象总是有来自字符串常量池的引用，所以不会被回收<img src="/小小String对象大大奥秘/stringLiterals3.jpg" title="stringLiterals3"></p><h2 id="string-对象的创建和字符串常量池的放入"><a class="markdownIt-Anchor" href="#string-对象的创建和字符串常量池的放入"></a> String 对象的创建和字符串常量池的放入</h2><p>上面嘀咕了那么久，那到底什么时候会创建String 对象？什么时候引用放入到字符串常量池中呢？先需要提出三个常量池的概念：</p><ol><li>静态常量池：常量池表（Constant Pool table，存放在Class文件中），也可称作为静态常量池，里面存放编译器生成的各种字面量和符号引用。其中有两个重要的常量类型为CONSTANT_String_info和CONSTANT_Utf8_info类型（具体描述可以看看《深入理解Java虚拟机》的p 219 啦~）</li><li>运行时常量池：运行时常量池属于方法区的一部分，常量池表中的内容会在类加载时存放在方法区的运行时常量池，运行时常量池相比于Class文件常量池一个重要特征是 动态性，运行期间也可以将新的常量放入到 运行时常量池中</li><li>字符串常量池：在HotSpot 虚拟机中，使用StringTable来存储 String 对象的引用，即来实现字符串常量池，StringTable 本质上是HashSet<string>，所以里面的内容是不可以重复的。一般来说，说一个字符串存储到了字符串常量池也就是说在StringTable中保存了对这个String 对象的引用</string></li></ol><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>有了上面的概念之后，便可来描述下述过程了<br>首先给出结论，<strong>“在类的解析阶段，虚拟机便会在创建String 对象，并把String对象的引用存储到字符串常量池中”。</strong></p><ol><li>当*.java 文件 编译为*.class 文件时，字符串会像其他常量一样存储到class 文件中的常量池表中，对应于CONSTANT_String_info和CONSTANT_Utf8_info类型；</li><li>类加载时，会把静态常量池中的内容存放到方法区中的运行时常量池中，其中CONSTANT_Utf8_info类型在类加载的时候就会全部被创建出来，即说明了加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，但是此时StringTable（字符串常量池）并没有相应的引用，在堆中也没有相应的对象产生；</li><li>遇到ldc字节码指令（该指令将int、float或String型常量值从常量池中推送至栈顶）之前会触发解析阶段，进入到解析阶段，若在解析的过程中发现StringTable已经有与CONSTANT_String_info一样的引用，则返回该引用，若没有，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；</li></ol><h3 id="具体示例"><a class="markdownIt-Anchor" href="#具体示例"></a> 具体示例</h3><p>下面给出几个具体实例，来说下这个过程：</p><ul><li><strong>字面量的形式创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    String name = &quot;HB&quot;;</span><br><span class="line">    String name2 = &quot;HB&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 = String  #14 </span><br><span class="line">#14 = utf8    HB</span><br><span class="line">……</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=3, args_size=1</span><br><span class="line">         0: ldc           #2  // String HB</span><br><span class="line">         2: astore_1     </span><br><span class="line">         3: ldc           #2  // String HB</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>当编译成字节码文件后，字面量&quot;HB&quot; 会存储到常量类型 CONSTANT_Utf8_info中，类加载时，其也会随之加载到方法区中的运行时常量池中，接下来可以用此来在StringTable查询是否有匹配的String 对象引用（当然只是简化的说法，具体CONSTANT_Utf8_info还指向一个Symbol对象~）；遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；astore_1指令把返回的引用存到本地变量name； 遇到二个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）已经有与CONSTANT_String_info一样的引用，则直接返回即可，并通过astore_2 指令将其返回的引用保存到本地变量 name2中</p><ul><li><strong>new 创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test2&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    String name = new String(&quot;HB&quot;);</span><br><span class="line">    String name2 = new String(&quot;HB&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: new           #2  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3 // String HB</span><br><span class="line">         6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #2 // class java/lang/String</span><br><span class="line">        13: dup</span><br><span class="line">        14: ldc           #3 // String HB</span><br><span class="line">        16: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure><p>使用了关键字new后，会有稍微不同，new 指令会在堆中创建一个新的String 对象，并将其引用值压入栈顶，通过dup指令 复制栈顶的新对象的引用值并把复制值压入栈顶，本地变量name 所保存的值就为该引用值；接下来在遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用, 所以在运行时，会创建两个String对象哦~接下来的过程和前面的差不多，就不一一叙述啦！</p><ul><li><strong>其他重要值得关注的示例</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;hb&quot;);</span><br><span class="line">String s2 = &quot;hb&quot;;</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line">String s3 = s1.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s2 == s3);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s5 = &quot;hb&quot; + &quot;haha&quot;;  // 虚拟机会优化进行优化, 当成一个整体 &quot;hbhaha&quot;成立, 而不会用StringBuild::append()处理</span><br><span class="line">String s6 = &quot;hbhaha&quot;;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String temp = &quot;hb&quot;;</span><br><span class="line">String s7 = temp + &quot;haha&quot;; // 采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s7 == s6);  // false</span><br><span class="line">String s8 = s7.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s8 == s6); // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s9 = new String(&quot;hb&quot;) + new String(&quot;haha&quot;);  //采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s9 == s6); // false</span><br><span class="line">String s10 = s9.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s10 == s6); // true</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>String 对象存在于堆中，字符串常量池存放了它们的引用</li><li>字符串常量池存储String对象的引用，且是全局共享的，相同的字符串都将指向同一个字符串对象</li><li>运行时创建的字符串（new）关键字 和 “” (字面量形式) 创建的字符串存在不同</li><li>检查字符串是否相同的最好方法是 equal()</li><li>可以通过String:: intern() 方法从常量池中得到String对象的引用，或 将String 对象的引用存入到 字符串常量池中</li><li>上述所有的实验都是在JDK 8 HotSpot虚拟机下进行的，在JDK 7 中HotSpot，字符串常量池移到了堆中哦~，所以不同JDK版本，不同虚拟机下可能存在差异</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html" rel="external nofollow noopener noreferrer" target="_blank">https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>[2] <a href="https://www.iteye.com/blog/rednaxelafx-774673#comments" rel="external nofollow noopener noreferrer" target="_blank">https://www.iteye.com/blog/rednaxelafx-774673#comments</a><br>[3] <a href="https://www.zhihu.com/question/55994121/answer/408891707" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/55994121/answer/408891707</a><br>[4] <a href="https://www.cnblogs.com/Kidezyq/p/8040338.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/Kidezyq/p/8040338.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是字符串&quot;&gt;&lt;/a&gt; 什么是字符串？&lt;/h2&gt;
&lt;p&gt;字符串是由引号所括起来的一系列字符序列。例如&amp;quot;String&amp;quot;，&amp;quot;Hello&amp;quot;就
      
    
    </summary>
    
      <category term="Java学习" scheme="http://www.huangbin.fun/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.huangbin.fun/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存设计 - 缓存穿透/雪崩/击穿</title>
    <link href="http://www.huangbin.fun/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF.html"/>
    <id>http://www.huangbin.fun/Redis-缓存设计-缓存穿透-雪崩-击穿.html</id>
    <published>2020-05-01T06:26:45.000Z</published>
    <updated>2020-05-01T06:49:51.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存收益和成本"><a class="markdownIt-Anchor" href="#缓存收益和成本"></a> 缓存收益和成本</h2><ol><li>缓存收益</li></ol><ul><li>加速读写</li><li>减低后端负载</li></ul><ol start="2"><li>缓存成本</li></ol><ul><li>数据不一致问题：缓冲层和数据层保存的数据可能不一致</li><li>代码维护成本变高，多了一层缓存逻辑</li><li>运维成本，例如 Redis cluster的维护</li></ul><ol start="3"><li>使用场景</li></ol><ul><li>减低后端负载：对高消耗的SQL结果进行缓存，例如join结果集/分组统计结果</li><li>加速请求响应</li><li>大量写合并为批量写，如计数器先Redis累加再批量写到DB</li></ul><h2 id="缓存更新策略"><a class="markdownIt-Anchor" href="#缓存更新策略"></a> 缓存更新策略</h2><ol><li>LRU(Least Recently Used)，根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，则延迟其淘汰时间” - <a href="https://blog.csdn.net/yunhua_lee/article/details/7599671" rel="external nofollow noopener noreferrer" target="_blank">LRU缓存更新</a></li><li>LFU(Least Frequently Used)根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”- <a href="https://blog.csdn.net/yunhua_lee/article/details/7648549" rel="external nofollow noopener noreferrer" target="_blank">LFU缓存更新</a></li><li>FIFO ，根据&quot;先进先出&quot; 思想来更新缓存数据</li><li>超时剔除 - expire</li><li>主动更新 - 开发控制生命周期</li><li>扩展：缓存污染 - 缓存污染降低了缓存的使用率，把不常用的数据读取到缓存，同时会把常用的数据移出缓存，这样会直接降低系统的数据命中率</li></ol><h2 id="缓存穿透问题"><a class="markdownIt-Anchor" href="#缓存穿透问题"></a> 缓存穿透问题</h2><ol><li><p>定义：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询），导致大量请求发到了数据库上。<img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/缓存穿透.png" title="缓存穿透"></p></li><li><p>解决方法</p></li></ol><ul><li>缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，不超过5分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库。<br><strong>存在的问题：</strong><br>（1）需要更多的键，所以通常设置较短过期时间<br>（2）缓存层和存储层数据&quot;短期&quot;不一致</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/设置NULL.jpg" title="设置NULL"><ul><li>布隆过滤器拦截：<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。例如Redis可以使用bitMap来实现布隆过滤器</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/布隆过滤器.jpg" title="布隆过滤器"><h2 id="缓存雪崩问题"><a class="markdownIt-Anchor" href="#缓存雪崩问题"></a> 缓存雪崩问题</h2><ol><li>定义：缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务（可能是机器宕机或大量的缓存(key)在同一时间失效 - 过期），于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</li><li>解决方法</li></ol><ul><li>保证缓存层服务高可用性：即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，比如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</li><li>依赖隔离组件为后端限流并降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>数据预热：可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul><h2 id="缓存击穿问题"><a class="markdownIt-Anchor" href="#缓存击穿问题"></a> 缓存击穿问题</h2><ol><li>定义：一个存在的热点key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到数据库，造成瞬时数据库请求量大压力骤增。</li><li>解决方法</li></ol><ul><li>互斥锁</li><li>永不过期</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a><br>[2] <a href="https://www.cnblogs.com/George1994/p/10668889.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/George1994/p/10668889.html</a><br>[3] <a href="https://www.jianshu.com/p/b57d0773ee96" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b57d0773ee96</a><br>[4] <a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存收益和成本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#缓存收益和成本&quot;&gt;&lt;/a&gt; 缓存收益和成本&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;缓存收益&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;加速读写&lt;/li&gt;
&lt;li&gt;减低后端负载&lt;/li&gt;

      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 故障转移</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-故障转移.html</id>
    <published>2020-04-30T06:25:11.000Z</published>
    <updated>2020-05-01T07:06:04.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障发现"><a class="markdownIt-Anchor" href="#故障发现"></a> 故障发现</h2><ol><li>通过ping/pong消息来实现故障发现：不需要sentinel</li><li>主观下线：某个节点认为另一个节点不可用，“偏见” <img src="/Redis-Cluster-故障转移/主观下线.png" title="主观下线"></li><li>客观下线：当半数以上持有槽的主节点都标记了某节点主观下线<img src="/Redis-Cluster-故障转移/客观下线.png" title="客观下线"></li></ol><ul><li>故障链表可以维护了每个节点对其他节点的&quot;看法&quot;，即认为主观下线与否</li><li>尝试客观下线流程如下：<img src="/Redis-Cluster-故障转移/客观下线流程.png" title="客观下线流程"></li></ul><h2 id="故障恢复"><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h2><ol><li>资格检查<br>检查每个从节点与故障主节点的断线时间。超过cluster-node-timeout * cluster-slave-validity-factor(默认10)则取消资格。</li><li>准备选举时间<br>准备选举时间，偏移量更大的从节点拥有延迟更小的选举时间，尽量保证从节点与主节点的数据一致性<img src="/Redis-Cluster-故障转移/选举时间.png" title="选举时间"></li><li>选举投票<img src="/Redis-Cluster-故障转移/选举投票.png" title="选举投票"></li><li>替换主节点</li></ol><ul><li>当前从节点取消复制变为主节点（slaveof no one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给新的主节点</li><li>向集群广播自己的pong消息，表明已经替换了故障主节点</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;故障发现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#故障发现&quot;&gt;&lt;/a&gt; 故障发现&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过ping/pong消息来实现故障发现：不需要sentinel&lt;/li&gt;
&lt;li&gt;主观下线：某个节点认为另一个节点不可
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 重定向问题 - Moved/Ask重定向</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98-Moved-Ask%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-重定向问题-Moved-Ask重定向.html</id>
    <published>2020-04-28T06:20:16.000Z</published>
    <updated>2020-05-01T07:05:54.788Z</updated>
    
    <content type="html"><![CDATA[<p>相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。</p><h2 id="moved-重定向"><a class="markdownIt-Anchor" href="#moved-重定向"></a> Moved 重定向</h2><img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved.png" title="Moved"><ol><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。<br>从下面可以看出 php 的槽位9244不在当前节点中，所以会重定向到节点 192.168.2.23:7001中。redis-cli会帮你自动重定向（如果没有集群方式启动，即没加参数 -c，redis-cli不会自动重定向），并且编写程序时，寻找目标节点的逻辑需要交予程序员手动完成。<br><em>cluster keyslot keyName</em>  # 得到keyName的槽<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved2.png" title="Moved2"></li></ol><h2 id="ask-重定向"><a class="markdownIt-Anchor" href="#ask-重定向"></a> ASK 重定向</h2><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/ASK.png" title="ASK"></p><h2 id="smart客户端"><a class="markdownIt-Anchor" href="#smart客户端"></a> smart客户端</h2><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来减低复杂性，追求更好的性能。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。<br>实现原理：</p><ol><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/映射关系.png" title="映射关系"></li><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/命令操作流程.png" title="命令操作流程"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。&lt;/p&gt;
&lt;h2 id=&quot;moved-重定向&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#move
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 集群伸缩</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-集群伸缩.html</id>
    <published>2020-04-26T06:05:21.000Z</published>
    <updated>2020-05-01T07:05:41.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群伸缩"><a class="markdownIt-Anchor" href="#集群伸缩"></a> 集群伸缩</h2><p>在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动</p><h2 id="集群扩容"><a class="markdownIt-Anchor" href="#集群扩容"></a> 集群扩容</h2><ol><li>准备新节点，把新节点配置为集群模式，相关配置信息和其他节点统一，启动后新节点是孤立节点，和集群之间还没有联系</li><li>使用 <em>cluster meet newNodeIP newNodePort</em> 把新节点加入到集群中，当然也可以使用官方的 redis-trib.rb的 相关命令来加入新节点（需要配置Ruby 环境~）。节点加入集群后，可以有两个作用：1. 为它迁移槽和数据实现扩容 ；2. 作为从节点负责故障转移</li><li>若新加入的节点大于一个，还可以进行主从分配， <em>cluster replicate nodeId</em></li><li>迁移槽和数据</li></ol><ul><li>制订迁移计划，每个节点要迁移多少个槽给新节点</li></ul><img src="/Redis-Cluster-集群伸缩/集群扩容.png" title="集群扩容"><ul><li>开始迁移操作<br> a. 对目标节点： <em>cluster setslot {slot} importing {sourceNodeId}</em>  让目标节点准备导入槽的数据<br> b. 对源节点： <em>cluster setslot {slot} migrating {targetNodeId}</em> 让源节点准备迁出槽的数据<br> c. 源节点循环执行  <em>cluster getkeysinslot {slot} {count}</em> 每次获取count个属于槽的键<br> d. 在源节点执行 <em>migrate {targetIp} {targetPort} key 0 {timeout}</em> 命令把指定key迁移，0 表示数据库0<br> e. 重复执行步骤 3 ~ 4直到槽下所有的键数据迁移到目标节点<br> f. 向集群内所有主节点发送  <em>cluster setslot {slot} node {targetNodeId}</em> 命令，告诉所有主节点 槽分配给了目标节点   <img src="/Redis-Cluster-集群伸缩/slot迁移.png" title="slot迁移"></li></ul><p>  上述的迁移操作很是繁琐，可以使用官方提供的redis-trib.rb的相关命令进行操作。使用 redis-trib.rb reshard IP:Port 进行交互模式来完成槽的移动  - <a href="https://www.jianshu.com/p/21f67bd739cc" rel="external nofollow noopener noreferrer" target="_blank">redis-trib工具使用</a></p><h2 id="集群收缩"><a class="markdownIt-Anchor" href="#集群收缩"></a> 集群收缩</h2><ol><li>下线集群节点之前，需要看节点是否持有槽，即是否有数据，若有，则需要迁移到其他节点<br><em>redis-trib.rb reshard --from {downNodeId} --to {migrateNodeId} --slots {slotNumber}  IP:Port</em>，其中的 IP:Port，任意一个节点的 IP:Port都行哦~<img src="/Redis-Cluster-集群伸缩/集群收缩.png" title="集群收缩"></li><li>通知其他所有节点忘记下线节点，<em>cluster forget {downNodeId}</em>_ 或者 <em>redis-trib.rb del-node IP:Port {forgetNodeId}</em> 。若有主从复制，要先下线从节点哦~ <img src="/Redis-Cluster-集群伸缩/集群收缩2.png" title="集群收缩2"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群伸缩&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集群伸缩&quot;&gt;&lt;/a&gt; 集群伸缩&lt;/h2&gt;
&lt;p&gt;在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动&lt;/p&gt;
&lt;h2 id=&quot;集群扩容&quot;&gt;&lt;a clas
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法 - 基于《算法》第四版</title>
    <link href="http://www.huangbin.fun/KMP%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.html"/>
    <id>http://www.huangbin.fun/KMP算法-基于《算法》第四版.html</id>
    <published>2020-04-20T13:01:18.000Z</published>
    <updated>2020-04-20T13:43:29.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2><ol><li>规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)</li><li>基本思想：当出现不匹配时，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配），根据这些已经知晓的内容决定  <strong>在出现不匹配时，模式应在处于哪个位置和文本的下一个字符比较 - 即找到已知晓内容和模式的最长公共前缀（利用模式去匹配已知晓的内容）</strong></li></ol><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><p>看《算法》的时候，有点部分真的太简洁了，看的晦涩难懂( 是我太菜了~ /(ㄒoㄒ)/~~） ，关注一下几个要点，要结合书中内容看可能会有新的理解</p><ol><li><p>指向文本的指针 i 永远不会回退，不会重复扫描文本，只有模式的指针 j 会进行回退。</p></li><li><p>有限状态机（DFA）只和 模式 有关，所以只要计算出了一个 模式的有限状态机（DFA），就可以匹配不同的文本。</p></li><li><p>DFA[txt.charAt(i)][j] = next， 表示 当前状态 j 时，遇到 文本字符 txt.charAt(i) （即 txt.charAt(i) 和 pat.charAt(j)进行比较）后的下一个状态是 next ( 即模式的指针 j 需要回退/前进到 next 处 和 文本字符 txt.charAt(i + 1)进行比较) 。</p></li><li><p>在一个状态中，要确定状态会进行何种转移，需要知道 <strong>当前状态</strong> 和 <strong>遇到的字符</strong>。</p></li><li><p>构造DFA：匹配成功时，即txt.charAt(i) == pat.charAt(j)，DFA[txt.charAt(i)][j] = j +1； 匹配失败时，模式指针 j 的回退也不是盲目回退， 它会根据 <strong>部分已经匹配成功的字符串与模式进行匹配后所处的状态（即书上所说的 X 重启状态）</strong> 以及 <strong>当前匹配失败的输入</strong> 来决定回退到哪个位置<img src="/KMP算法-基于《算法》第四版/匹配图.png" title="匹配图">在箭头处出现了不匹配，那此时pat 指针 j 应该回退到哪个地方在和 txt 的下一个字符 A 比较呢？<br>知道 状态 j 遇到了 字符D 发生了不匹配，意味着pat的前 j  个字符串 (0… j-1)和文本的 (i - j, i - 1)是相匹配的， 就像上述所示，但是我们不用理会 txt.charAt(i-j)，因为 i - j处已经不可能出现匹配，所以  <strong>部分已经匹配成功的字符串</strong> 就为 B A B A （pat[1… j - 1]）。<br>现我们考虑 B A B A 和 模式 进行匹配会到达什么状态（所到达的状态也是书中所提到的 <strong>重启状态 X</strong>），这个过程我们也可以看成是找 <strong>部分已经匹配成功的字符串</strong>  和 <strong>模式</strong> 的 <strong>最长公共前缀</strong> 的过程。<img src="/KMP算法-基于《算法》第四版/匹配图2.png" title="匹配图2">可以看到 B A B A 和 模式 进行匹配之后到达了 状态 3，即 X =3。则可以知道 DFA[D][5] = DFA[D][3]，即在状态 5 遇到 字符 D发生不匹配时应该回退的位置 就是在状态 3 遇到 字符 D 时 应该到达的位置。 这可以对应到书中代码 DFA[C][j] = DFA[C][X]。</p></li><li><p>困扰我很久的一个 X 如何进行求得，可以将其看成一个 X[] 数组，记录了模式与 部分匹配成功的字符串（pat[1…j -1]）所达到的所有状态（书本P765，图5.3.8很好的表达了此点）。它们之间关系是一个递推关系，X[i+1]为X[j]状态 遇到 pat.charAt(j)时所到达的状态，即 X[j + 1] = DFA[pat.charAt(j)][x[j]]，X[0]初始化状态为0。 这也便是书中代码中的 X = DFA[pat.charAt(j)][X]。理解了上述6,7之后，就可以写出构造DFA的过程（当然，我对于上述6，7的说明都是基于你已经看过了《算法》中字符串查找部分哦~）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] DFA;</span><br><span class="line">public void generateDFA(String pat)&#123;</span><br><span class="line">        int M = pat.length();</span><br><span class="line">        int R = 256;  // ASCII字符不会操过256种</span><br><span class="line">        DFA = new int[R][M];</span><br><span class="line">        // 初始化状态0, 在状态0只有遇到了pat.charAt(0)才会向前推进, 遇到其他为0(java默认初始化数组为0)</span><br><span class="line">        DFA[pat.charAt(0)][0] = 1;</span><br><span class="line">        int X = 0;  // 初始化重启状态为0</span><br><span class="line">        for (int j = 1; j &lt; M; j++)&#123;  // 构造DFA数组过程</span><br><span class="line">           for (int c = 0; c &lt; R; c++)</span><br><span class="line">          // 状态j遇到字符c不匹配时,把重启状态X遇到字符c到达哪个状态赋值DFA[c][j]</span><br><span class="line">                DFA[c][j] = DFA[c][X];</span><br><span class="line">           DFA[pat.charAt(j)][j] = j + 1;  // 匹配成功, 状态向前推进</span><br><span class="line">           X = DFA[pat.charAt(j)][X];  // 部分已经成功匹配字符串中增加了pat.charAt(i), 需要更新重启状态X,即它们的最长重叠字符会发生变化</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>我们已经计算出了DFA，下面是利用DFA来搜索文本的算法 - 结合书本P498 图5.3.7理解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int search(String txt) &#123;</span><br><span class="line">   int M = pat.length();</span><br><span class="line">   int N = txt.length();</span><br><span class="line">   int i,j;</span><br><span class="line">    // pat 的初始态为 0 - 模拟有限状态机运行</span><br><span class="line">   for (i = 0,j = 0; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">        // 当前是状态 j，遇到字符 txt[i]，</span><br><span class="line">        // pat 应该转移到哪个状态？</span><br><span class="line">        j = dp[txt.charAt(i)][j];</span><br><span class="line">        // 如果达到终止态，返回匹配开头的索引</span><br><span class="line">        if (j == M) return i - M;</span><br><span class="line">   &#125;</span><br><span class="line">   // 没到达终止态，匹配失败</span><br><span class="line">   return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>结合上面两部分就可以得到具体的KMP算法啦！ （ 具体参考书籍上的算法哦</p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>要使用KMP算法进行匹配，重要的是求出 DFA 数组，而要求出正确的得到DFA数组，格外需要关注（难理解）的是重启状态X和重启状态X的转移，即为每次发生匹配时，模式 和 pat[1…j]的最长公共前缀。只要得到了DFA数组之后，模拟有限状态机运行就可以进行匹配操作了。</li><li>对于长度为M的模式字符串和长度为N的文本，KMP查找算法访问字符串不会超过 N + M个。</li><li>就算书上所提的一样，KMP算法为最坏情况提供的线性级别运行时间保证的一个理论成果，在实际运用中，它比暴力算法的速度优势并不明显</li></ol><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="https://judes.me/tech/2016/04/10/kmp.html" rel="external nofollow noopener noreferrer" target="_blank">https://judes.me/tech/2016/04/10/kmp.html</a><br>[2] <a href="https://book.douban.com/subject/19952400/discussion/59623403/" rel="external nofollow noopener noreferrer" target="_blank">https://book.douban.com/subject/19952400/discussion/59623403/</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/83334559" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/83334559</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本思想&quot;&gt;&lt;/a&gt; 基本思想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)&lt;/li&gt;
&lt;li&gt;基本思想：当出现不匹配时，就能
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="KMP" scheme="http://www.huangbin.fun/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster学习</title>
    <link href="http://www.huangbin.fun/Redis-Cluster%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster学习.html</id>
    <published>2020-04-18T02:57:05.000Z</published>
    <updated>2020-04-18T03:29:21.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称当个Redis可以使用10万并发），高可用问题（部分节点不可达能继续处理命令）。 Redis 集群常常和主从复制结合使用。</p><h2 id="分布式数据库-数据分区"><a class="markdownIt-Anchor" href="#分布式数据库-数据分区"></a> 分布式数据库 - 数据分区</h2><img src="/Redis-Cluster学习/数据分区.png" title="数据分区"><h3 id="哈希分区"><a class="markdownIt-Anchor" href="#哈希分区"></a> 哈希分区</h3><p>假如有1~100条数据，按照哈希函数（例如 hash(key)%3），把数据分区到不同的三个数据库</p><ol><li>节点取余分区： hash(key) % nodes。若增加/减少节点，会进行大量数据迁移，例如当前有3个节点，增加了一个节点，按照新的hash(key) % 4进行计算时，很多数据需要进行移动。 建议进行 多倍扩容，例如当前有3个节点，可以扩容到6个节点，减少数据迁移量。节点取余也成为 不一致性哈希。比较适合缓存的场景</li><li>一致性哈希分区<br>能保证最小迁移数据，比较适合缓存的场景 - <a href="http://blog.codinglabs.org/articles/consistent-hashing.html" rel="external nofollow noopener noreferrer" target="_blank">一致性哈希分区</a></li><li>虚拟槽分区：Redis cluster采用此种分区方式，预设虚拟槽（slot），每个虚拟槽映射一个数据子集，每个节点管理一定数量的虚拟槽，redis 虚拟槽范围 0 ~ 16383。<br>使用分散函数（例如CRC16(keys) % slots ）计算出 keys 属于哪个槽，再根据节点所管理的槽的范围，从而确定数据属于哪个节点（节点中共享信息，若一个虚拟槽不属于当前节点，会告诉虚拟操去哪个节点去存储）</li></ol><img src="/Redis-Cluster学习/虚拟槽分区.png" title="虚拟槽分区"><h3 id="顺序分区"><a class="markdownIt-Anchor" href="#顺序分区"></a> 顺序分区</h3><p>假如有1 ~ 100条数据，按照顺序分区规则，可以把1 ~ 33，34 ~ 66，67 ~ 100分区到三个不同的三个数据库</p><h3 id="方式对比"><a class="markdownIt-Anchor" href="#方式对比"></a> 方式对比</h3><img src="/Redis-Cluster学习/分区比较.png" title="分区比较"><h2 id="cluster-架构"><a class="markdownIt-Anchor" href="#cluster-架构"></a> Cluster 架构</h2><img src="/Redis-Cluster学习/cluster架构.png" title="cluster架构"><ol><li>通过配置文件 cluster-enabled yes 将一个节点设置为一个集群节点</li><li>节点之间通过gossip协议进行通信，了解彼此的信息</li><li>将虚拟槽指派给上述节点</li><li>客户端通过 CRC16( key ) % 16383 并可知道对应的key应该到哪个虚拟槽的哪个节点进行处理</li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="配置集群节点"><a class="markdownIt-Anchor" href="#配置集群节点"></a> 配置集群节点</h3><ol><li><em>cluster-enabled yes</em>  # 配置当前节点为集群节点</li><li><em>cluster-config-file nodes-${port}.conf</em>  # 配置cluster节点自身配置文件</li><li><em>cluster-node-timeout 15000</em>  # 集群中各个节点相互通讯（ping）时，允许&quot;失联&quot;的最大毫秒数，如果超过这个时间没有得到响应，会认为该节点故障，若节点是主节点，则会进行故障转移</li><li><em>cluster-require-full-coverage yes</em>  # 若配置为 yes，则当集群中有节点不可用时，整个集群都不能提供服务，通常设置为 no</li></ol><h3 id="通过meet把每个集群节点组合成集群-集群发现"><a class="markdownIt-Anchor" href="#通过meet把每个集群节点组合成集群-集群发现"></a> 通过meet把每个集群节点组合成集群 - 集群发现</h3><ol><li><em>cluster meet ip port</em>  #当前节点去发现新的集群节点</li></ol><img src="/Redis-Cluster学习/发现集群.png" title="发现集群"><h3 id="分配槽"><a class="markdownIt-Anchor" href="#分配槽"></a> 分配槽</h3><ol><li><em>cluster addslots slot [slot…]</em>   # 为当前节点分配槽</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># addslots.sh</span><br><span class="line"># 开始槽</span><br><span class="line">start=$1</span><br><span class="line"># 结束槽</span><br><span class="line">end=$2</span><br><span class="line"># 分配端口</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">   echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">   redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 分配操作</span><br><span class="line">sh addslots 0 5461 7000</span><br><span class="line">sh addslots 5462 10923 7001</span><br><span class="line">sh addslots 10923 16383 7002</span><br></pre></td></tr></table></figure><p>在第二步中配置了6个集群节点，但是只为7000 ~ 7002分配槽，7000 ~ 7002作为master，其余作为slave节点</p><h3 id="配置主从关系"><a class="markdownIt-Anchor" href="#配置主从关系"></a> 配置主从关系</h3><ol><li><em>cluster replicate node-id</em>  # 对 node-id节点进行复制，node-id在集群启动时会进行分配。</li><li><em>cluster nodes</em>  # 查看node-id</li></ol><img src="/Redis-Cluster学习/配置主从关系.png" title="配置主从关系"><h3 id="ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"><a class="markdownIt-Anchor" href="#ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"></a> Ruby配置集群 -除了上述安装方式，官方提供了脚本进行快速集群配置</h3><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>Gossip 协议：所有节点都保存了一份元数据，当节点发生伸缩或更新时，会将最新的元数据信息传播给所有节点。 - <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">gossip协议</a><br>Redis 使用Gossip协议时采用了meet，ping，pong，fail消息进行通信</li></ol><img src="/Redis-Cluster学习/gossip协议.png" title="gossip协议"><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://blog.csdn.net/makyan/article/details/104798725" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/makyan/article/details/104798725</a><br>[2] <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/8279d6fd65bb</a><br>[3] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长回文子串</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长回文子串.html</id>
    <published>2020-04-13T10:40:48.000Z</published>
    <updated>2020-04-14T02:30:32.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;br&gt;
示例 1：&lt;br&gt;
输入: “ba
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.huangbin.fun/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>初探动态规划算法</title>
    <link href="http://www.huangbin.fun/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/初探动态规划算法.html</id>
    <published>2020-04-13T09:18:28.000Z</published>
    <updated>2020-04-14T02:30:30.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h1&gt;
&lt;p&gt;维基百科的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dynamic programming is a method for solvi
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="Gynamic Programming" scheme="http://www.huangbin.fun/tags/Gynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel学习</title>
    <link href="http://www.huangbin.fun/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Sentinel学习.html</id>
    <published>2020-04-10T14:10:33.000Z</published>
    <updated>2020-04-14T02:35:15.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sentinel生产可用。sentinel作为一个独立的进程，监控多个运行的Redis 数据库。<br>主要解决主从复制发生故障时，进行手动故障转移的复杂性问题，当主节点宕机后，需要手动选择一个从节点作为新的主数节点，其他作为从节点，而利用sentinel能自动完成故障转移过程。<br>sentinel也支持集群，因为使用单个sentinel进程了监控Redis是不可靠的，容易出现单点问题</p><ul><li>即使有一些sentinel进程宕掉了，依然可以进行Redis 集群的主从切换</li><li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现Redis 集群的主从切换</li><li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于Redis 集群中的信息</li></ul><h2 id="功能和架构"><a class="markdownIt-Anchor" href="#功能和架构"></a> 功能和架构</h2><ol><li>功能<ul><li>监控Redis的运行状况</li><li>当发生故障时实现主从切换。当一个master宕机之后，从它的多个slave中投票选举中一个新的master，剩余节点作为新的master的slave</li></ul></li><li>架构</li></ol><img src="/Redis-Sentinel学习/架构图.png" title="架构图"><p>在这个架构中，sentinel节点会监控master和slave的相关信息，主要值得关注的是client与sentinel之间的交互：</p><ol><li>client首先需要知道sentinel节点集合和mastername信息，通过遍历它所知道的sentinel集合，获取到一个可用的sentinel节点</li><li>找到可用的sentinel节点之后，client通过 sentinel get-master-addr-by-name masterName 命令的得到master节点的地址和端口</li><li>得到master相关信息之后，会进行一次role/role replication验证，master节点会返回验证信息，至此client可以对master进行写入和读取</li><li>sentine也会将redis数据节点的变化通知给客户端 - 使用发布订阅模式进行通知</li><li>上述过程不是通过代理模式实现的，即上述client和master建立关系的过程通常只需执行一次即可</li></ol><h2 id="故障转移过程"><a class="markdownIt-Anchor" href="#故障转移过程"></a> 故障转移过程</h2><ol><li>当一个sentinel检测master宕机并不会马上进行故障转移（主观下线），只有当后面的sentinel也都认为master不可用并达到一定数量时（客观下线），选举出一个领导者sentinel来进行故障转移操作</li><li>选出一个slave作为master，执行 slave of one 让其成为master节点</li><li>通知其余slave做为新的master的slave</li><li>等待老的master复活，若复活成功，成为新的master的slave</li><li>通知客户端发生了主从变化</li></ol><p>实现上述故障转移依靠三个定时任务：</p><ol><li>每10s每个sentinel对master和slave执行info操作<ul><li>发现slave操作</li><li>确认主从关系</li></ul></li><li>每2s每个sentinel通过master节点的channel交换信息<ul><li>发布订阅模式</li><li>通过_sentinel_:hello频道交互</li><li>交互对节点的&quot;看法&quot;和自身信息 - 可以知道其他sentinel的相关信息或投票来确定哪个sentinel来进行故障转移<img src="/Redis-Sentinel学习/sentinel发布订阅图.png" title="sentinel发布订阅图"></li></ul></li><li>每1s每个sentinel对其他sentinel和redis执行ping<ul><li>心跳检测，失败判定依据，比如可以作为客观下线的依据。</li></ul></li></ol><h2 id="sentinel配置和启动"><a class="markdownIt-Anchor" href="#sentinel配置和启动"></a> Sentinel配置和启动</h2><ol><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel运行端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 守护进程启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># sentinel工作目录</span><br><span class="line">dir &quot;/usr/local/share/redis/redis-3.0.5/backs&quot;</span><br><span class="line"></span><br><span class="line"># sentinel 日志文件</span><br><span class="line">logfile &quot;sentinel-26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master信息 master-name ip port quorum - 当quorm个数sentinel节点认为maste</span><br><span class="line"># r失联,则执行故障转移</span><br><span class="line">sentinel monitor mymaster 192.168.2.23 6379 2</span><br><span class="line"></span><br><span class="line"># 一定时间内,master没有应答哨兵sentinel, sentinel认为master主观下线 默认30秒(ping 30 次没有ping通)</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 在进行主从切换时(故障转移),最多可以几个slave对新的master进行同步。若设置的值很小, 则同</span><br><span class="line">步需要花费很长时间, 值很大,则有很多slave应为同步复制而不可用, 也会降低master节点的性能</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移超时时间, 应用于以下情况</span><br><span class="line"># 1. 同一个sentinel对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2. 当一个slave从一个错误的master那里同步数据开始计算时间,直到slave被纠正为向正确的mast</span><br><span class="line"># er那里同步数据时</span><br><span class="line"># 3.当想要取消一个正在进行的failover所需要的时间  </span><br><span class="line"># 4.当进行failover时,配置所有slaves指向新的master所需的最大时间。不过，即使过了这个时间,</span><br><span class="line"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则进行处理</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>注：可以看到sentinel.conf配置文件主要是对master节点进行监控，通过master节点使用 info replecation 进行slave的相关信息获取，会将获取的slave信息自动添加到 sentinel.conf配置文件之中，在配置文件中的标识为：Generated by CONFIG REWRITE，需要注意的是，redis在添加slave信息的同时，也会对一些配置信息进行更改，例如sentinel down-after-milliseconds，sentinel parallel-syncs，sentinel failover-timeout会被移除，添加sentinel config-epoch，sentinel leader-epoch等配置 。</p><ol start="2"><li>启动</li></ol><p>  <em>redis-sentinel sentinel.conf</em>  # 启动sentinel<br>  <em>redis-cli -p 26379</em>  # 连接sentinel, sentinel也当成一个普通的Redis 节点来对待</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>主观下线：每个sentinel节点对Redis 节点失败的&quot;偏见&quot;，可能由于网络问题，Redis 节点不能在规定的时间内回应sentinel节点</li><li>客观下线：所有sentin节点对Redis 节点失败达成&quot;共识&quot;，即sentinel节点中认为Redis 节点可以进行客观下线的个数超过quorum的个数，此时可以真正进行故障转移操作。其中达成共识通过sentinel is-master-down-by-addr命令询问其他sentinel节点的&quot;意见&quot;来完成的</li><li>领导者选举<ul><li>原因：只需要一个sentinel节点来进行故障转移</li><li>如何：1. 每个做主观下线的sentinel节点通过sentinel is-master-down-by-addr 来询问其他sentinel节点的&quot;意见&quot;是否要对master节点进行客观下线的时候，通过也会要求将其设置为领导者；2. 收到命令的sentinel节点如果没有同意其他sentinel节点成为领导者的请求，那就同意，否则拒绝；3. 如果该sentinel节点发现自己的票数超过了sentinel集合半数且超过了quorum，那么它将成为领导者来进行故障处理；4. 如果有多个sentin节点成为领导者，则过一段时间再进行选举</li></ul></li><li>如何选择合适的slave让其成为master<ul><li>选择 slave-priority优先级最高的slave节点</li><li>若全部优先级相同，则选择复制偏移量最大（与以前的master节点数据最接近）的slave节点</li><li>若上述都不成立，则选择runId最小的节点，即启动最早的slave</li></ul></li></ol><h2 id="运维问题"><a class="markdownIt-Anchor" href="#运维问题"></a> 运维问题</h2><ol><li>主节点手动下线，进行故障转移<br>  <em>sentinel failover masterName</em></li><li>高可用的读写分离<br>sentinel只会对master节点进行故障转移，对于slave节点只有进行主观下线，所以要实现高可用的读写分离，客户端要关注slave节点的变化，例如关注以下三个消息: +switch-master: 从节点晋升为主节点，+conver-to-slave:  原主节点降为从节点，+sdown: 主观下线</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://segmentfault.com/a/1190000002680804" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002680804</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sent
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.huangbin.fun/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://www.huangbin.fun/Redis主从复制.html</id>
    <published>2020-04-10T13:53:44.000Z</published>
    <updated>2020-04-14T02:33:00.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave）上，数据流向是单向的 - Master -&gt; Slave。通常主数据进行数据写入操作，从数据库进行读操作，实现数据的读写分离。</p><h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2><ol><li><p>命令方式</p><ul><li><em>slaveof  slavehost</em> # 将 slavehost 将复制为当前Redis数据库的从数据库，异步操作，会将数据库的数据进行清除。<br><em>e.g., 127.0.0.1: 6380 &gt; slaveof 127.0.0.1: 6379</em>  # 127.0.0.1: 6379将会成为127.0.0.1: 6380的主数据库</li><li><em>slaveof  no one</em> # 取消当前命令执行数据库的复制，以前主数据库已经同步的数据不会清除。</li><li><em>info replication</em>  # 当前数据库是主还是从数据库的相关信息</li></ul></li><li><p>配置 - redis.conf，配置之后需重启</p><ul><li><em>slaveof  masterip masterport</em></li><li><em>slave-read-only yes</em></li></ul></li></ol><h2 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h2><p>执行完全量复制之后，主从数据库之间数据库状态已经相同了。但这个状态并非一成不变，如果主数据库执行了写操作，那么主数据库的数据库状态就会修改，并导致主从数据库状态不再一致。所以为了让主从数据库再次回到一致状态，主数据库需要对从数据库执行命令传播操作：主数据库会将自己执行的写命令，也即是造成主从数据库不一致的那条写命令，发送给从数据库执行，当从数据库执行了相同的写命令之后，主从数据库将再次回到一致状态。</p><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><img src="/Redis主从复制/主从复制.png" title="全量复制"><ol><li>复制过程<ul><li>从数据库向主数据库发送PSYNC命令 - 从2.8开始，SYNC替换成PSYNC，提供了完整重同步和部分重同步</li><li>收到PSYNC命令后，主数据库将自身的runId和offset传给从数据库，之后主数据库执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主数据库的BGSAVE命令执行完毕时，主数据库会将BGSAVE命令生成的RDB文件发送给从数据库，从数据库接收并载入这个RDB文件，将自己的数据库状态更新至主数据库执行BGSAVE命令时的数据库状态</li><li>主数据库将记录在缓冲区里面的所有写命令发送给从数据库，从数据库执行这些写命令，将自己的数据库状态更新至主数据库数据库当前所处的状态</li></ul></li><li>开销<ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>清空从数据库花费时间</li><li>从数据库加载RBD文件花费的时间，并且载入期间，从数据库可能因为阻塞而无法处理客户端请求</li></ul></li></ol><h2 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h2><img src="/Redis主从复制/部分复制.png" title="部分复制"> <ol><li>解决问题：处理从数据库断线后的重连问题。当从数据库在断线后重新连接主数据库时，如果条件允许，主数据库可以将主从数据库连接断开期间执行的写命令发送给从数据库，从数据库只要接收并执行这些写命令，就可以将数据库更新至主数据库当前所处的状态。而2.8以前，断连之后还要进行一次SYNC操作。</li><li>复制过程<ul><li>当从数据库断线后，主数据库会继续把写命令放入到复制积压缓冲区（replication backlog）中</li><li>当从数据库重新连上主数据库时，从数据库会通过PSYNC命令将自己的复制偏移量（replication offset）和主数据库的运行ID（run id）发送给主数据库，主数据库会根据这个复制偏移量和运行ID来决定对从数据库执行何种同步操作</li><li>如果从数据库发送的运行ID和当前连接的主数据库的运行ID相同，那么说明从数据库断线之前复制的就是当前连接的这个主数据库，主数据库可以继续尝试执行部分复制操作</li><li>相反，如果从数据库发送的运行ID和当前连接的主数据库的运行ID并不相同，主数据库将对从数据库执行全量复制操作</li><li>如果从数据库的复制偏移量之后的数据（也即是offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主数据库将对从数据库执行部分复制操作</li><li>相反，如果offset之后的数据已经不存在于复制积压缓冲区，那么主数据库将对从数据库执行全量复制操作</li></ul></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>复制偏移量（replication offset）：主数据库和从数据库会分别维护一个复制偏移量：<ul><li>主数据库每次向从数据库传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从数据库每次收到主数据库传播来的N个字节的数据时，就将自己的复制偏移量的值加上N<br>对比主从数据库的复制偏移量，可知道主从数据库是否处于一致状态：</li><li>如果主从数据库处于一致状态，那么主从数据库两者的偏移量总是相同的</li><li>相反，如果主从数据库两者的偏移量并不相同，那么说明主从数据库并未处于一致状态</li></ul></li></ol><img src="/Redis主从复制/复制偏移量.png" title="复制偏移量"><ol start="2"><li><p>复制积压缓冲区（replication backlog）：复制积压缓冲区是由主数据库维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主数据库进行命令传播时，它不仅会将写命令发送给所有从数据库，还会将写命令入队到复制积压缓冲区里面。因此，主数据库的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量<img src="/Redis主从复制/复制积压缓冲区.png" title="复制积压缓冲区"><br>复制积压缓冲区默认大小为1MB，如果主数据库需要执行大量写命令，又或者主从数据库断线后重连接所需的时间比较长，那么Redis的部分复制功能可能会达不到想要的效果。复制积压缓冲区的最小大小可以根据公式 second*write_size_per_second 来估算：</p><ul><li>second为从数据库断线后重新连接上主数据库所需的平均时间（以秒计算）</li><li>write_size_per_second是主数据库平均每秒产生的写命令数据量。</li><li>例如，如果主数据库平均每秒产生1 MB的写数据，而从数据库断线之后平均要5秒才能重新连接上主数据库，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理，可以通过修改repl-backlog-size配置进行设置。</li></ul></li><li><p>数据库运行ID<br>每个Redis数据库，不论主数据库还是从服务，都会有自己的运行ID。运行ID在数据库启动时自动生成，由40个随机的十六进制字符组成，例53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。<br>当从数据库对主数据库进行初次复制时，主数据库会将自己的运行ID传送给从数据库，而从数据库则会将这个运行ID保存起来。当从数据库断线并重新连上一个主数据库时，从数据库将向当前连接的主数据库发送之前保存的运行ID。</p></li></ol><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li>读写分离<ul><li>数据复制延迟</li><li>读到过期数据</li><li>从数据库故障</li></ul></li><li>主从数据库配置不一致<ul><li>maxmemory不一致：丢失数据</li><li>数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致</li></ul></li><li>规避全量复制<ul><li>第一次全量复制不可避免 - 尽量低峰（夜间）进行</li><li>避免主数据库runId不匹配导致的全量复制</li><li>避免复制积压缓冲区不足导致的全量复制 - 修改rel_backlog_size配置</li></ul></li><li>规避复制风暴<ul><li>单主数据库复制风暴 - 主数据库重启，多从数据库复制</li><li>单机器复制风暴 - 机器有多个主数据库，机器宕机，大量全量复制。避免多个主数据库部署在一个机器上</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化常见问题</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangbin.fun/Redis持久化常见问题.html</id>
    <published>2020-04-10T13:45:43.000Z</published>
    <updated>2020-04-14T02:35:04.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fork操作"><a class="markdownIt-Anchor" href="#fork操作"></a> Fork操作</h2><ol><li>定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这是一种内核机制，在创建子进程并不发生复制，创建子进程后父子进程共用数据，只有在修改数据是才会创建新的空间。</li><li>Redis中需要用到fork操作的相关命令：bgsave，bgrewriteaof，查看上一次fork消耗时间：info stats</li><li>同步操作 - 会对父进程执行的业务造成影响</li><li>与内存量息息相关 - 内存越大，耗时越长，同时也与机器类型相关</li><li>改善fork：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存: maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1 。修改sysctl vm.overcommit_memory=1<br>  0  -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br> b1 -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>  2 -  表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>降低fork频率：例如放宽AOP重写的自动触发时机</li></ul></li></ol><h2 id="子进程的开销和优化"><a class="markdownIt-Anchor" href="#子进程的开销和优化"></a> 子进程的开销和优化</h2><ol><li>CPU<ul><li>开销: RDB和AOF文件的生成，属于CPU密集型</li><li>优化： 不做CPU绑定 ，不和CPU密集型一起部署</li></ul></li><li>内存<ul><li>开销: fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>硬盘<ul><li>开销：AOF和RDB文件写入，结合iostat，iotop分析</li><li>优化：不和高硬盘负载服务部署在一起，根据写入量决定磁盘类型。</li></ul></li><li>扩展：<ul><li>CPU绑定 - 进程和CPU的绑定是为了让应用获得更好的性能，进程的Affinity属性指明了进程调度器能够把这个进程调度到哪些CPU上。CPU Affinity分为2种，soft affinity和hard affinity。soft affinity仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的CPU上。hard affinity是调度器必须遵守的规则。</li><li>CPU密集型（CPU-bound），也叫计算密集型，系统运作时CPU的消耗接近100%，I/O读写可以在很短的时间完成，但是CPU的计算任务繁重。多重程序系统中，大部份时间用来做计算、逻辑判断等的程序称之CPU bound，一般而言，CPU bound的程序CPU占用率相当高。</li><li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，CPU消耗并不高。I/O bound的程序需要大量的I/O操作。</li><li>Transparent hugepage默认是被开启的以便去改善操作系统的内存管理，但是在某种情况下会造成不可预知的节点重启和性能问题</li></ul></li></ol><h2 id="aof追加阻塞"><a class="markdownIt-Anchor" href="#aof追加阻塞"></a> AOF追加阻塞</h2><ol><li><p>定义：如果AOF文件同步时间与上次同步时间相比大于2s，Redis主进程就会阻塞，等待同步完成；如果AOF文件同步时间与上次同步时间相比小于2s，Redis主进程就会返回。其实这样做的目的是为了保证文件安全性的一种策略。 <img src="/Redis持久化常见问题/AOF追加阻塞.png" title="AOF追加阻塞"></p></li><li><p>问题：</p><ul><li>主线程阻塞造成业务受影响</li><li>虽然每秒everysec刷盘策略，但是实际上不是丢失1s数据，实际有可能丢失2s数据</li></ul></li><li><p>问题定位</p><ul><li><p>Redis日志<img src="/Redis持久化常见问题/Redis日志.png" title="Redis日志"></p></li><li><p>Info Persistence中的aof_delayed_fsync,同步延迟历史总数</p></li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fork操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork操作&quot;&gt;&lt;/a&gt; Fork操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.huangbin.fun/Redis持久化.html</id>
    <published>2020-04-10T12:44:30.000Z</published>
    <updated>2020-04-14T02:35:09.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化</p><h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2><ol><li><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行了指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB生成的文件也可作为复制媒介使用。</p></li><li><p>触发方式</p><ul><li><em>save</em>  # 客户端发出命令后，redis会生成相应的dump.rdb文件（若存在老的RDB文件，则新替老）。该命令为同步命令，进行Save 命令时，其他命令不能执行，容易发生阻塞， O(n)</li><li><em>bgsave</em> #与Save 不同的是，该命令为异步命令，会开一个子进程进行处理， O(n)</li></ul> <img src="/Redis持久化/RDB持久化.png" title="RDB持久化"> <img src="/Redis持久化/RDB持久化2.png" title="RDB持久化2"> <ul><li>利用配置文件进行触发 - 采用 bgsave方式</li></ul> <img src="/Redis持久化/RDB持久化3.png" title="RDB持久化3"> <p>  <strong>重要配置项：</strong><br>   dbfilename dump.rdb  # 指定本地数据库名<br>   dir ./   # 指定本地数据库存放目录<br>   rdbcompression yes #默认开启数据压缩，redis采用LZF压缩方式，但占用了一点CPU的时间。<br>   stop-writes-on-bgsave-error yes #出现错误是否停止写入<br>   rdbchecksum yes #是否对RDB文件进行校验</p><ul><li>全量复制 - 主从复制时会自动生成RDB文件</li><li>debug reload - 也会生成RDB文件</li><li>shutdown - Redis也会RDB文件</li></ul></li><li><p>优缺点</p><ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li><li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了 - 不可控，丢失数据。</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件 - 耗时，耗性能</li></ul></li></ol><h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2><ol><li><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></li><li><p>配置文件</p><ul><li>appendonly yes  # 开启AOF</li><li>appendfilename “appendonly-6379.aof” # 指定本地数据库名</li><li>appendfsysnc always/everysec/no # 指定更新日志条件<br>  - always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但是数据完整性比较好（慢，安全）<br>  - everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>  - no ：不同步，由OS决定何时把命令写入到文件中</li></ul> <img src="/Redis持久化/AOF持久化.png" title="AOF持久化">  <img src="/Redis持久化/AOF持久化2.png" title="AOF持久化2">  <img src="/Redis持久化/AOF持久化3.png" title="AOF持久化3"> <ul><li>为了缩小AOF文件的大小，提供了AOP重写,目的减少磁盘占用量（减少冗余）,加速恢复速度</li></ul> <img src="/Redis持久化/AOF持久化4.png" title="AOF持久化4"> <p>  <strong>重写原理</strong><br>  Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中，并没有读取旧文件，最后替换旧的aof文件。<br>  <strong>重写方式</strong><br>  a. bgrewriteaof  #异步，会开启一个子进程来进行处理<br>  b. 配置文件 - 执行bgrewriteaof<br>    auto-aof-rewrite-min-size #AOF文件重写需要的尺寸<br>    auto-aof-rewrite-percentage #AOF文件增加率<br>    当AOF文件大小是上次rewrite后大小的一倍（增加率）且文件大于64M（尺寸）时触发</p><ul><li>no-appendfsync-on-rewrite yes # 在重写时是否可以进行AOF持久化操作</li><li>aof-load-truncated yes # 在AOF文件出现错误时，是否忽略错误，尽量加载更多的数据</li><li>在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复</li></ul></li><li><p>优缺点</p><ul><li>更高的数据完整性和一致性</li><li>随着时间的增加，AOF文件会越来越大，数据恢复速度会越来越慢，可以通过重写解决</li></ul></li></ol><h2 id="持久化策略对比"><a class="markdownIt-Anchor" href="#持久化策略对比"></a> 持久化策略对比</h2><img src="/Redis持久化/持久化对比.png" title="持久化对比"> <h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/itdragon/p/7906481.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/itdragon/p/7906481.html</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化&lt;/p&gt;
&lt;h2 id=&quot;rdb持久化&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis其他特性和功能</title>
    <link href="http://www.huangbin.fun/Redis%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%92%8C%E5%8A%9F%E8%83%BD.html"/>
    <id>http://www.huangbin.fun/Redis其他特性和功能.html</id>
    <published>2020-04-10T12:26:49.000Z</published>
    <updated>2020-04-14T02:34:59.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询"></a> 慢查询</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来，可将其持久化到磁盘中供开发人员分析。</p><h3 id="客户端请求生命周期"><a class="markdownIt-Anchor" href="#客户端请求生命周期"></a> 客户端请求生命周期</h3><img src="/Redis其他特性和功能/请求生命周期.png" title="请求生命周期"><p>慢查询是一个先进先出的队列，该队列固定长度，保存在内存中。若一条命令在第三阶段的执行过程中被判断为慢查询，则会进行该队列。</p><h3 id="慢查询配置"><a class="markdownIt-Anchor" href="#慢查询配置"></a> 慢查询配置</h3><img src="/Redis其他特性和功能/慢查询.png" title="慢查询"><ol><li>slowlog-log-slower-than: 命令是否是慢查询的界定条件（阈值），单位微秒，例如超过10毫秒就认为该命令是慢查询，= 0 是代表记录所有命令，&lt; 0 不记录任何命令，默认：10000。</li><li>slowlog-max-len: 慢查询列表的固定长度，默认：128</li><li>slowlog list:  指明有哪些慢查询</li><li>参数配置：<ul><li>修改配置文件</li><li>动态配置：config set slowlog-max-len 1000</li></ul></li></ol><h3 id="慢查询命令"><a class="markdownIt-Anchor" href="#慢查询命令"></a> 慢查询命令</h3><ol><li><em>slowlog get [n]</em> # 获取慢查询队列， n 指明获取几个慢查询记录</li><li><em>slowlog len</em>  # 获取慢查询队列长度</li><li><em>slowlog reset</em> # 清空慢查询队列</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>slowlog-max-len：线上环境建议调大慢查询日志的列表，记录慢查询日志时Redis会对长命令做截断操作，并不会占用大量内存。增大慢查询列表可以减缓慢查询被剔除出列表的可能性。例如线上可以设置为1000以上。</li><li>slowlog-log-lower-than：需要根据redis的并发量调整该值。由于redis采用单线程，对于高流量的场景，如果执行命令的时间在1毫秒以上，那么redis最多可支撑OPS（每秒操作次数）不到1000，因此高OPS场景的redis建议设置为1毫秒。</li><li>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行slow get命令将慢查询日志持久化到其他存储中，然后制作可视化界面查询。</li></ol><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> pipeline</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><p>利用pipeline可以一次从发送多条命令（打包），在服务端执行之后，在把结果一次性返回，节省了命令/结果在网络中的传输时间。若没有使用pipeline，n次命令的操作，要额外花费n-1网络时间，因为redis的命令执行都是微秒级别，所以网络时间通常是瓶颈所在。</p><img src="/Redis其他特性和功能/pipeline.png" title="pipeline"><img src="/Redis其他特性和功能/pipeline2.png" title="pipeline2"><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">pipeline.set(&quot;product&quot;,&quot;computer&quot;);</span><br><span class="line">pipeline.set(&quot;producttwo&quot;,&quot;microwave&quot;);</span><br><span class="line">pipeline.syncAndReturnAll();</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3><ol><li>注意每次pipeline携带数据量</li><li>pipeline每次只能作用在一个Redis节点上</li><li>M操作（mset）是原子操作，pipeline命令非原子操作。</li></ol><h2 id="发布订阅"><a class="markdownIt-Anchor" href="#发布订阅"></a> 发布订阅</h2><h3 id="发布订阅模型"><a class="markdownIt-Anchor" href="#发布订阅模型"></a> 发布订阅模型</h3><img src="/Redis其他特性和功能/发布订阅.png" title="发布订阅"><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><ol><li><em>publish channel message</em> # 发布者向对应频道发布消息, 返回订阅者数量<br><em>e.g., publish sohu:tv “hello!”</em></li><li><em>subscribe [channel]</em>  # 订阅一个或多个频道</li><li><em>unsubscribe [channel]</em>  # 取消订阅一个或多个频道</li><li><em>psubscribe [pattern…]</em>  # 订阅一个或多个符合给定模式的频道<br>e.g., psubscribe it*   # 将会订阅以it开头的频道</li><li><em>punsubscribe [pattern…]</em>  # 取消订阅一个或多个符合给定模式的频道</li><li><em>pubsub channels</em>  # 列出至少有一个订阅者的频道</li><li><em>pubsub numsub [channels…]</em>  # 列出给定频道的订阅者数量</li></ol><h3 id="与消息队列的区别"><a class="markdownIt-Anchor" href="#与消息队列的区别"></a> 与消息队列的区别</h3><p>发布订阅时，所以订阅者都可以收到发布者的信息，而消息队列是消息订阅者从消息队列中取消息，不保证每个消息订阅者都可以得到消息。</p><h2 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h2><h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3><p>位图（也称为位数组，位向量等）是紧凑存储位的数组数据结构。redis提供了对位的操作。</p><img src="/Redis其他特性和功能/位图.png" title="位图"><h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3><p>位数组是自动扩展的，如果超出现有内容范围，它会自动将位数组进行零扩充。</p><img src="/Redis其他特性和功能/位图特征.png" title="位图特征"><h3 id="api-2"><a class="markdownIt-Anchor" href="#api-2"></a> API</h3><ol><li><em>setbit key offset value</em> # 给位图指定偏移量设置值</li><li><em>getbit key offset</em> #  得到指定偏移量的值</li><li><em>bitcount  key [start end]</em> #  获取位图指定范围(start - end, 单位为字节， 不指定则代表获取全部)位值位1的个数</li><li><em>bitop  op destkey key[key…]</em>  #  对多个位图进行 and (交集)，or(并集)，not(非)，xor(异或)操作，并把结果保存在 destkey 中</li><li><em>bitpos  key targetBit [start] [end]</em>   #计算位图指定范围(start-end, 单位为字节, 不指定则代表获取全部)第一个值等于 targetBit 的偏移量</li></ol><h3 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h3><ol><li>Type = String, 最大512MB</li><li>注意setbit时的偏移量，可能损耗大</li><li>活跃用户统计/用户的签到等等应用都有奇效</li></ol><h2 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h2><h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3><p>基于HyperLogLog算法，极小空间完成独立数量（基数）统计。本质还是字符串。<br>基数统计：一个集合（注意：这里集合的含义是 Object 的聚合，可以包含重复元素）中不重复元素的个数。例如集合 {1,2,3,1,2}，它有5个元素，但它的基数/Distinct 数为3。</p><h3 id="api-3"><a class="markdownIt-Anchor" href="#api-3"></a> API</h3><ol><li><em>pfadd key element [element…</em> # 向hyperloglog添加元素</li><li><em>pfcount key [key…</em> # 计算hyperloglog的独立总数</li><li><em>pfmerge destkey  sourcekey[sourcekey…</em> # 合并多个hyperloglog</li></ol><h3 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h3><ol><li>存在错误率 - 0.81%</li><li>不能取出单条数据</li><li>鉴于 HyperLogLog 不保存数据内容的特性，所以，它只适用于一些特定的场景。例如计算日活、月活数据等等</li></ol><h2 id="geo-redis-32支持"><a class="markdownIt-Anchor" href="#geo-redis-32支持"></a> GEO - redis 3.2+支持</h2><h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3><p>GEO: 地理信息定位，存储经纬度，计算两地距离，范围计算等。redis的geo实现采用数据结构为zset</p><h3 id="api-4"><a class="markdownIt-Anchor" href="#api-4"></a> API</h3><ol><li>geoadd key longitude latitude member [longitude latitude member… # 增加地理位置信息<br>e.g., geoadd city:location 116.28 39.55 bejing</li><li>geopos key member [member… # 获取地理位置信息</li><li>geolist key member1 member2 [unit] # 获取两个地理位置的距离 unit: m, km, mi, ft</li><li>georadius<img src="/Redis其他特性和功能/GEO.png" title="GEO"></li><li>zrem key member # edis的geo实现采用数据结构为 zset，遂可以使用zset API进行删除</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;慢查询&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#慢查询&quot;&gt;&lt;/a&gt; 慢查询&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h3&gt;
&lt;p&gt;慢查询日
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和相应操作</title>
    <link href="http://www.huangbin.fun/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%9B%B8%E5%BA%94%E6%93%8D%E4%BD%9C.html"/>
    <id>http://www.huangbin.fun/Redis数据结构和相应操作.html</id>
    <published>2020-04-10T12:00:59.000Z</published>
    <updated>2020-04-14T02:34:47.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis通用操作"><a class="markdownIt-Anchor" href="#redis通用操作"></a> Redis通用操作</h2><ol><li><em>Keys [pattern]</em> # 遍历出指定模式的key，可使用 <em>, ?等通配符 - 一般不在生产环境中使用，O(n)<br>  _Keys</em>_  # 遍历出所有key<br>  <em>Keys he[h-l]*</em>   # 遍历以 he 开头，第三个字符在 h-l 期间的匹配key</li><li><em>dbsize</em> # 计算 key 的总数，O(1)</li><li><em>exists key</em> # 检查 key 是否存在，O(1)级别时间复杂度</li><li><em>del key</em> # 删除指定 key ，O(1)</li><li><em>expire key seconds</em> #  key在 seconds 秒后过期 ，O(1)</li><li><em>ttl key</em> #  查看 key 剩余过期时间  -1 表达无过期时间  -2表示已过期，O(1)</li><li><em>persist key</em> #  去掉 key 的过期时间 ，O(1)</li><li><em>type key</em> # 返回 key 的类型 ，O(1)</li></ol><h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> String类型</h2><h3 id="string键值结构"><a class="markdownIt-Anchor" href="#string键值结构"></a> String键值结构</h3><img src="/Redis数据结构和相应操作/String数据结构.png" title="String数据结构"><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><em>get key</em> # 获取 key 对应value ，O(1)</li><li><em>set key value</em> # 设置 key-value ，已有相同 key 值，则进行覆盖，O(1)</li><li><em>setnx key value</em> # 设置 key-value ，key 不存在，才进行设置，O(1)</li><li><em>set key value</em> xx # 设置 key-value ，key 存在，才进行设置，O(1)</li><li><em>del key</em> # 删除 key-value ，O(1)</li><li><em>incr key</em> # key 自增1, 如果key不存在，自增都get(key)=1 ，O(1)</li><li><em>decr key</em> # key 自减1, 如果key不存在，自减都get(key)=-1 ，O(1)</li><li><em>incrby key k</em> # key 自增k, 如果key不存在，自增都get(key)=k ，O(1)</li><li><em>decrby key k</em> # key 自减k, 如果key不存在，自减都get(key)=-k，O(1)</li><li><em>mget key1 key2  key3…</em> # 批量获取key，原子操作，O(n)</li><li><em>mset key1 value1 key2 value2 key3 value3…</em> # 批量设置key-value，原子操作，O(n)</li><li><em>getset key newvalue</em>   #  set key newvalue并返回 oldvalue，O(1)</li><li><em>append key value</em>   #  将 value 将追加到  oldvalue，O(1)</li><li><em>strlen key</em>   #  返回字符串长度（注意中文） ，O(1)</li><li><em>incrbyfloat key floatValue</em>   #  增加key 对应的值 ，O(1)</li><li><em>getrange key start end</em>   #  获取字符串指定下标的所有值 ，O(1)</li><li><em>setrange key index value</em>   #  设置指定下标对应的值 ，O(1)</li></ol><h2 id="hash类型"><a class="markdownIt-Anchor" href="#hash类型"></a> Hash类型</h2><h3 id="hash键值结构"><a class="markdownIt-Anchor" href="#hash键值结构"></a> Hash键值结构</h3><img src="/Redis数据结构和相应操作/Hash数据结构.png" title="Hash数据结构"><p>注： field不能相同，value可以相同</p><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><ol><li><em>hget key field</em> # 获取 hash key 对应field 的 value ，O(1)</li><li><em>hset key field value</em> # 设置 hash key 对应field 的 value ，O(1)</li><li><em>hdel key field</em> # 删除 hash key 对应field 的 value ，O(1)</li><li><em>hexists key field</em> # 判断 hash key 是否有对应 field ，O(1)</li><li><em>hlen key</em> # 获取 hash key 的 field 数量，O(1)</li><li><em>hmget key field1 field2…</em>  # 批量获取hash-key的一批 field 对应值，O(n)</li><li><em>hmset key  field1 value1 field2 value2…</em> # 批量设置 hash-key的一批 field 对应值，O(n)</li><li><em>hgetall key</em>   # 返回 hash-key 对应所有的 field-value 值，O(n)</li><li><em>hvals key</em>   # 返回 hash-key 对应所有 field 的 value 值，O(n)</li><li><em>hkeys key</em>   # 返回 hash-key 对应所有 field ，O(n)</li><li><em>hincrby key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hincrbyfloat key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hsetnx key field value</em> # 设置 hash key对应 field的 value ，field 不存在，才进行设置，O(1)</li></ol><h2 id="list类型"><a class="markdownIt-Anchor" href="#list类型"></a> List类型</h2><h3 id="list键值结构"><a class="markdownIt-Anchor" href="#list键值结构"></a> List键值结构</h3><img src="/Redis数据结构和相应操作/List数据结构.png" title="List数据结构"><p>注: 有序（由插入顺序决定遍历顺序），可以重复，左右两边插入弹出</p><h3 id="操作-3"><a class="markdownIt-Anchor" href="#操作-3"></a> 操作</h3><ol><li><em>rpush key value1 value2…</em> # 从列表的右端插入值 ，O(1~n)</li><li><em>lpush key value1 value2…</em> # 从列表的左端插入值 ，O(1~n)</li><li>linsert key before/after value newvalue # 在list指定的值前|后插入新值，O(n)</li><li><em>lpop key</em>  # 从列表的左端弹出一个值（删除） ，O(1)</li><li><em>rpop key</em>  # 从列表的右端弹出一个值（删除） ，O(1)</li><li><em>lrem key count value</em>  # 根据 count  值，从列表中删除所有 value  相等的项 ，O(n)<ul><li>count  &gt; 0 , 从左到右，删除最多 count  个 value  相等的项目</li><li>count  &lt; 0 , 从右到左，删除最多 Math.abs(count)  个 value  相等的项目</li><li>count  = 0 , 删除所有 value  相等的项目</li></ul></li><li><em>ltrim key start end</em>  # 按照索引范围(索引从 0 开始 ，-1 表示最后一个元素)修剪列表 ，O(n)</li><li><em>lrange key start end</em>  # 获取列表指定索引范围(索引从 0 开始，-1 表示最后一个元素，包括 end )的值 ，O(n)<ul><li>lrange list 0 5 = lrange list -6 -1 = lrange list 0 -1</li></ul></li><li><em>lindex key index</em>  # 获取列表指定索引的值 ，O(n)</li><li><em>llen key</em>  # 获取列表长度 ，O(1)</li><li><em>lset key index newValue</em>  # 设置列表指定索引的值 ，O(n)</li><li><em>blpop key timeout</em>  # lpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li><li><em>rlpop key timeout</em>  # rpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li></ol><h2 id="set类型"><a class="markdownIt-Anchor" href="#set类型"></a> Set类型</h2><h3 id="set键值结构"><a class="markdownIt-Anchor" href="#set键值结构"></a> Set键值结构</h3><img src="/Redis数据结构和相应操作/Set数据结构.png" title="Set数据结构"><p>注: 无序（顺序不由插入顺序决定），不可重复，支持集合间的操作</p><h2 id="操作-4"><a class="markdownIt-Anchor" href="#操作-4"></a> 操作</h2><ol><li><em>sadd key value1 value2…</em>.  # 向集合 key 中添加元素，若已有重复元素，则添加失败 ，O(n)</li><li><em>srem key value1 value2…</em>. # 移除集合 key 中元素，O(n)</li><li><em>scard key</em>   # 计算集合元素个数，O(1)</li><li><em>sismember key value</em> # 判断集合 key 中 value 元素是否存在，O(n)</li><li><em>srandmember key count</em>  # 随机从集合 key 中挑选 count  个元素，O(n)</li><li><em>spop key</em>  # 随机从集合 key 中挑选 1 个元素，O(1)</li><li><em>smembers key</em>  # 获取集合 key 中所有元素，O(n)</li><li><em>sdiff key1 key2</em>  # 两个集合的差集，O(n)</li><li><em>sinter key1 key2</em>  # 两个集合的交集，O(n)</li><li><em>sunion key1 key2</em>  # 两个集合的并集，O(n)</li><li><em>sunionstore/sdiffstore/sinterstore destkey key1 key2</em>   # 并集/差集/交集结果存到 destkey  中，O(n)</li></ol><h2 id="sorted-set类型"><a class="markdownIt-Anchor" href="#sorted-set类型"></a> Sorted Set类型</h2><h3 id="sorted-set键值结构"><a class="markdownIt-Anchor" href="#sorted-set键值结构"></a> Sorted Set键值结构</h3><img src="/Redis数据结构和相应操作/SortedSet数据结构.png" title="SortedSet数据结构"><p>注: 有序，不可重复，支持集合间的操作</p><h2 id="操作-5"><a class="markdownIt-Anchor" href="#操作-5"></a> 操作</h2><ol><li><em>zadd key score value score2 value2…</em>.  # 向有序集合 key 中添加score value对，value不可重复元素，否则添加失败 ，O(logN)</li><li><em>zrem key  value  value2…</em>.  # 删除有序集合 key 中添加元素 ，O(1)</li><li><em>zscore key  value</em>   # 获取有序集合 key 中 value 对应的 score ，O(1)</li><li><em>zincrby key increScore value</em>   # 增加有序集合 key 中 value 对应的 score 值，O(1)</li><li><em>zcard key</em>   # 获取有序集合 key 中 value 个数，O(1)</li><li><em>zrank key value</em>   # 获取有序集合 key 中 value 的排名(从低到高)，O(1)</li><li><em>zrevrank key value</em>   # 获取有序集合 key 中 value 的排名(从高到低)，O(1)</li><li><em>zrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 降序，O(logn + m)</li><li><em>zrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 降序，O(logn + m)</li><li><em>zcount key minScore maxScore</em>    #  获取有序集合指定分数范围的值的个数 ，O(logn + m)</li><li><em>zremrangebyrank key start end</em> #  删除指定排名内的升序元素，O(logn + m)</li><li><em>zremrangebyscore key minScore maxScore</em> #  删除指定分数范围的升序元素，O(logn + m)</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="http://redisdoc.com/" rel="external nofollow noopener noreferrer" target="_blank">http://redisdoc.com/</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis通用操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis通用操作&quot;&gt;&lt;/a&gt; Redis通用操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Keys [pattern]&lt;/em&gt; # 遍历出指定模式的key，可使用 &lt;em
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis是什么?</title>
    <link href="http://www.huangbin.fun/Redis%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
    <id>http://www.huangbin.fun/Redis是什么.html</id>
    <published>2020-04-10T11:51:51.000Z</published>
    <updated>2020-04-14T02:34:53.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted set），哈希（Hash）。</p><h2 id="数据结构和内部编码"><a class="markdownIt-Anchor" href="#数据结构和内部编码"></a> 数据结构和内部编码</h2><img src="/Redis是什么/数据结构图.png" title="数据结构图"><p>Redis 源码中设置了一个redisObject数据结构，描述了此种关系。</p><img src="/Redis是什么/内部编码图.png" title="内部编码图"><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ol><li>速度快 - 基于内存，C语言编写，单线程 - 纯内存，非阻塞IO（实时性好，但是占用大量CPU资源），避免线程切换和竞态消耗。</li><li>持久化 - Rdis所有数据保持在内存中，可对数据进行持久化在磁盘中。</li><li>多种数据结构，在新的版本中，还提供了位图（Bitmaps），超小内存唯一值计数（HyperLogLog），地理信息定位（GEO）数据结构。但是其数据结构内部还是基于上述五种基本的数据结构实现的，Bitmaps，HyperLogLog都是String数据类型。</li><li>支持多种客户端语言 - Java, PHP, Python等。</li><li>功能丰富 - 发布订阅, 事务, Lua脚本, pipeline。</li><li>“简单” - 不依赖外部库，单线程模型。</li><li>主从复制</li><li>高可用 - Redis-Sentinel(V2.8)，分布式 - Redis-Cluster(V3.0)</li><li>多数据库 - 一个redis实例包括了15个数据库，可以选择连接哪个数据据进行操作。选择数据据命令为select 1。 同时可以选择move somekey 1把当前数据库的key移动到数据库1。</li><li>事务 - multi：开始事务，后面的命令都会被认为是事务的一部分操作；exec：提交事务；discard：事务回滚。</li><li>注意: Redis是单线程，一次执行一条命令，所以拒绝长（慢命令） - keys，flushall，flushdb，slow，lua script，mutil/exec，operate big value(collection)。对于fysnc file descriptor，close file descriptor会开启另外一个独立线程进行操作。</li></ol><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li>缓存系统</li><li>消息队列 - 秒杀，抢购等。<a href="https://www.zhihu.com/question/54152397" rel="external nofollow noopener noreferrer" target="_blank">什么是消息队列？</a></li><li>计数器 - 网站访问统计，微博转发评论，视频播放</li><li>排行榜</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted se
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长公共前缀</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长公共前缀.html</id>
    <published>2019-10-20T09:11:56.000Z</published>
    <updated>2019-10-20T09:17:44.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br></p><ul><li><p>示例 1:<br>输入: [“flower”,“flow”,“flight”]<br>输出: “fl”<br></p></li><li><p>示例 2:<br>输入: [“dog”,“racecar”,“car”]&lt;<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="垂直扫描法"><a class="markdownIt-Anchor" href="#垂直扫描法"></a> 垂直扫描法</h2><p><img src="https://pic.leetcode-cn.com/b647cab7c3d2bd157cecae10917e0b9b671756b92c9cfcefec1a2bdae299c11c-file_1555694071243" alt="水平扫描法"></p><ol><li>取出第一个字符串暂时作为最长公共前缀（prefixStr）；</li><li>依次遍历字符串数组中的其他字符串，分别与prefixStr比较；</li><li>若当前字符不包含prefixStr，则对prefixStr进行裁取（长度减一），再次与当前字符进行比较；</li><li>若当前字符包含prefixStr，则取出字符串数组的下一个字符串与prefixStr进行比较；</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><ul><li>时间复杂度：O(S)，S是所有字符串中字符数量的总和，最坏情况时n个字符串全部相同，则indexOf要比较S次字符比较</li><li>空间复杂度：O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) return &quot;&quot;;</span><br><span class="line">        String prefixStr = strs[0];  </span><br><span class="line">        for(int i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">            while(strs[i].indexOf(prefixStr) != 0)&#123;  </span><br><span class="line">                prefixStr = prefixStr.substring(0,prefixStr.length() - 1); </span><br><span class="line">                if(prefixStr.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefixStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平扫描法"><a class="markdownIt-Anchor" href="#水平扫描法"></a> 水平扫描法</h2><ol><li>取出字符串数组中的第一个字符串，遍历该字符串中的字符，依次与数组中的其他字符串的同列字符比较；</li><li>若出现不同的字符，则对第一个字符串进行相应位置截取，便得最长公共前缀；</li><li>若某字符串长度等于当前所比较字符位置（i = strs[j].length()），则也进行第2步的截取操作；</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><ul><li>时间复杂度: O(S)，S 是所有字符串中字符数量的总和</li><li>空间复杂度: O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for(int i = 0; i &lt; strs[0].length(); i++)&#123;</span><br><span class="line">            char a = strs[0].charAt(i);</span><br><span class="line">            for(int j = 1; j &lt; strs.length; j++)&#123;</span><br><span class="line">                if( i == strs[j].length() || a != strs[j].charAt(i))&#123;    // 先执行||, 然后执行后面, 且i == strs[j].length()表示存在字符串已经遍历完</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt; 无重复字符的最长子串长度</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html"/>
    <id>http://www.huangbin.fun/LeetCode-无重复字符的最长子串长度.html</id>
    <published>2019-10-12T06:52:59.000Z</published>
    <updated>2019-10-20T09:18:15.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br></p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h2><p>滑动窗口算法用于对给定的大缓冲区或数组的特定窗口大小执行所需的操作(即在遍历大缓存区或数组时, 对其特定的窗口大小执行特定操作)。目的是将很少出现问题的嵌套for循环转换为单个for循环，从而降低时间复杂度。例如: 找出某数组中和最大的子数组， 规定子数组元素个数为3， 即窗口大小为3， 当然窗口大小也可以是动态的。具体过程如下：<br><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动过程"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>实现一</strong></p><ul><li>时间复杂度: O(2n)=O(n)，最糟糕的情况下，每个字符要被i，j分别访问一次</li><li>空间复杂度: O(min(m, n))，滑动窗口法需要 O(k)的空间，其中 k表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int record = 0,i = 0,j = 0;  // record记录最长子串长度</span><br><span class="line">        int length = s.length(); </span><br><span class="line">        Set strSet = new HashSet();  // 使用HashSet作为滑动窗口</span><br><span class="line">        while(i &lt; length &amp;&amp; j &lt; length)&#123;</span><br><span class="line">            if(!strSet.contains(s.charAt(j)))&#123;  // s.charAt(j)不在strSet中</span><br><span class="line">                strSet.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                record = Math.max(record, j - i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                strSet.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现二</strong><br><br>该实现是对滑动窗口的优化，即在窗口中存在与当前元素相同的字符，直接把窗口左端移动到相同字符的后一位，而不是一步一步的移动左端窗口。</p><ul><li>时间复杂度: O(n)，单单j会遍历n次</li><li>空间复杂度: O(min(m, n))</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length(), record = 0;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0, j = 0; j &lt; length; j++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(j)))&#123;  // 包含了有相同字符</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)),i);  // 把i定位到存储在map中且与s.charAt(j)相同的字符的下一个索引位置</span><br><span class="line">            &#125;</span><br><span class="line">            record = Math.max(record,j - i + 1);  // + 1是因为前面已经排除了相同字符, 遂可把s.charAt(j)字符加入参与长度计算 </span><br><span class="line">            map.put(s.charAt(j), j + 1);  // 把s.charAt(j)索引+1是方便i的定位(定位到相同元素的后一位)</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例 1:&lt;br&gt;
输入: “abc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习课程练习代码实现(Octave版/Python版)</title>
    <link href="http://www.huangbin.fun/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html"/>
    <id>http://www.huangbin.fun/吴恩达机器学习课程练习代码实现-Octave版-Python版.html</id>
    <published>2019-10-09T11:35:21.000Z</published>
    <updated>2019-10-09T11:44:04.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习课程练习代码实现octave版python版"><a class="markdownIt-Anchor" href="#吴恩达机器学习课程练习代码实现octave版python版"></a> 吴恩达机器学习课程练习代码实现(Octave版/Python版)</h1><p> 吴恩达老师的机器学习课程成为了众多机器学习爱好者进入机器学习世界的敲门砖, 老师通俗易懂的授课方式让人能够快速的了解机器学习。 老师的课后练习使用Octave语言进行编写, 但是现在机器学习中使用更加普遍的是Python语言, 为了兼顾两者, 我就自己编写的两个版本的代码实现进行分享。对于每个作业PDF文档也进行了相应注释。</p><ul><li>Linear Regression</li><li>Logistic Regression</li><li>Neural Network</li><li>NN Back Propagation</li><li>Bias vs Variance</li><li>SVM</li><li>Kmeans and PCA</li><li>Anomaly Detection and Recommendation</li></ul><p>  <strong>具体代码文档下载链接:</strong> <a href="https://github.com/hbheyho/MachineLearningExam-Andrew-Ng" rel="external nofollow noopener noreferrer" target="_blank">MachineLearningExam-Andrew-Ng</a><br> ps: 若查看Python版本, 建议使用Jupyter Notebook进行阅读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;吴恩达机器学习课程练习代码实现octave版python版&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#吴恩达机器学习课程练习代码实现octave版python版&quot;&gt;&lt;/a&gt; 吴恩达机器学习课程练习代码实现(Octave版/Pytho
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://www.huangbin.fun/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://www.huangbin.fun/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务/脚本/命令自启动配置</title>
    <link href="http://www.huangbin.fun/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.huangbin.fun/Linux-服务-脚本-命令自启动配置.html</id>
    <published>2019-07-31T07:31:16.000Z</published>
    <updated>2019-07-31T07:37:22.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux服务自启动"><a class="markdownIt-Anchor" href="#linux服务自启动"></a> Linux服务自启动</h2><p> 若程序（脚本）已注册成服务，则可通过service serviceName start/stop/status来启动服务、停止服务和查看服务状态，也可通过/etc/init.d/serviceName start/stop来开启和停止服务。<br> 可通过/etc/rc.d/init.d或/etc/init.d查看linux全部服务。</p><h3 id="方法一修改配置文件"><a class="markdownIt-Anchor" href="#方法一修改配置文件"></a> 方法一：修改配置文件</h3><p> 修改 /etc/rc.d/rc.local或/etc/rc.local文件（该文件在系统启动时，在输入用户名和密码之前最后读取的文件），加入服务启动命令来实现服务自启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"># 系统启动时，tomcat6服务自启动</span><br><span class="line">/etc/rc.d/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><h3 id="方法二chkconfig命令"><a class="markdownIt-Anchor" href="#方法二chkconfig命令"></a> 方法二：chkconfig命令</h3><p> chkconfig命令格式：<em>chkconfig serviceName on/off</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自启动tomcat服务</span><br><span class="line">chkconfig tomcat on</span><br><span class="line">#关闭tomcat自启动</span><br><span class="line">chkconfig tomcat off</span><br></pre></td></tr></table></figure><h3 id="方法三通过ntsysv调用窗口模式来管理服务的自启动"><a class="markdownIt-Anchor" href="#方法三通过ntsysv调用窗口模式来管理服务的自启动"></a> 方法三：通过ntsysv调用窗口模式来管理服务的自启动</h3><p> ntsysv命令格式：<em>ntsysv [–level 运行级别]</em><br>          --level 运行级别：可以指定设定自启动的运行级别；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只设定2、3、5级别的服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv --level 235</span><br><span class="line">#按默认的运行级别设置服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv</span><br></pre></td></tr></table></figure><p>执行上述命令之后linux界面如下，使用空格键来选定/取消服务的自启动，其中*号代表该服务自启动。</p><img src="/Linux-服务-脚本-命令自启动配置/ntsysv设置自启动.png" title="ntsysv设置自启动"><p><strong>注意：ntsysv属于redhat系列linux的专有命令</strong></p><h2 id="linux脚本自启动"><a class="markdownIt-Anchor" href="#linux脚本自启动"></a> Linux脚本自启动</h2><h3 id="方法一把脚本放到etcrclocal"><a class="markdownIt-Anchor" href="#方法一把脚本放到etcrclocal"></a> 方法一：把脚本放到/etc/rc.local</h3><p>脚本文件start_tomcat.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#启动tomcat</span><br><span class="line">/etc/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><p>把需自启动的脚本文件放入/etc/rc.local</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#当系统启动时便执行start_tomcat.sh脚本</span><br><span class="line">/root/start_tomcat.sh        #脚本执行方式：绝对路径执行方式，path/脚本文件</span><br></pre></td></tr></table></figure><h3 id="方法二把sh脚本移动到etcprofiled"><a class="markdownIt-Anchor" href="#方法二把sh脚本移动到etcprofiled"></a> 方法二：把sh脚本移动到/etc/profile.d</h3><p> /etc/profile.d中的脚本文件执行情景：当一个用户登录Linux系统或使用切换到另一个用户时才会调用，所以不建议使用</p><h2 id="linux自启动命令"><a class="markdownIt-Anchor" href="#linux自启动命令"></a> Linux自启动命令</h2><p> 若要自启动命令，则把需要自启动的命令放在/etc/rc.local中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux服务自启动&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux服务自启动&quot;&gt;&lt;/a&gt; Linux服务自启动&lt;/h2&gt;
&lt;p&gt; 若程序（脚本）已注册成服务，则可通过service serviceName start/sto
      
    
    </summary>
    
      <category term="Linux学习" scheme="http://www.huangbin.fun/categories/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://www.huangbin.fun/tags/Linux/"/>
    
  </entry>
  
</feed>
