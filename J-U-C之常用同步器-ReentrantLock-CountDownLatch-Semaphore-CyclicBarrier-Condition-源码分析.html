<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析"><meta name="keywords" content="J.U.C"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析 | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用同步器"><span class="toc-number">1.</span> <span class="toc-text"> 常用同步器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantlock"><span class="toc-number">2.</span> <span class="toc-text"> ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">2.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">2.2.</span> <span class="toc-text"> 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取锁操作"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 获取锁操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放锁操作"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 释放锁操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用实例"><span class="toc-number">2.3.</span> <span class="toc-text"> 应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展"><span class="toc-number">2.4.</span> <span class="toc-text"> 扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition"><span class="toc-number">3.</span> <span class="toc-text"> Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-2"><span class="toc-number">3.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#condition-interface"><span class="toc-number">3.2.1.</span> <span class="toc-text"> Condition interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程挂起操作"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 线程挂起操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程唤醒操作"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 线程唤醒操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用实例"><span class="toc-number">3.3.</span> <span class="toc-text"> 使用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">3.4.</span> <span class="toc-text"> 参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore"><span class="toc-number">4.</span> <span class="toc-text"> Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-3"><span class="toc-number">4.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-3"><span class="toc-number">4.2.</span> <span class="toc-text"> 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取许可操作"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 获取许可操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放许可操作"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 释放许可操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用实例-2"><span class="toc-number">4.3.</span> <span class="toc-text"> 应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料-2"><span class="toc-number">4.4.</span> <span class="toc-text"> 参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch"><span class="toc-number">5.</span> <span class="toc-text"> CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-4"><span class="toc-number">5.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现原理"><span class="toc-number">5.2.</span> <span class="toc-text"> 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-4"><span class="toc-number">5.3.</span> <span class="toc-text"> 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取闭锁操作"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 获取闭锁操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放闭锁操作"><span class="toc-number">5.4.</span> <span class="toc-text"> 释放闭锁操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#应用实例-3"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 应用实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-number">5.5.</span> <span class="toc-text"> 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文档"><span class="toc-number">5.6.</span> <span class="toc-text"> 参考文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdownlatch和semaphore结合实例"><span class="toc-number">5.7.</span> <span class="toc-text"> CountDownLatch和Semaphore结合实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyclicbarrier"><span class="toc-number">6.</span> <span class="toc-text"> CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-5"><span class="toc-number">6.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现原理-2"><span class="toc-number">6.2.</span> <span class="toc-text"> 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-5"><span class="toc-number">6.3.</span> <span class="toc-text"> 源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用实例-2"><span class="toc-number">6.4.</span> <span class="toc-text"> 使用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景"><span class="toc-number">6.5.</span> <span class="toc-text"> 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料-3"><span class="toc-number">6.6.</span> <span class="toc-text"> 参考资料</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Concurrency/">Concurrency</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.4k</span><span class="post-meta__separator">|</span><span>Reading time: 27 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="常用同步器"><a class="markdownIt-Anchor" href="#常用同步器"></a> 常用同步器</h2>
<p>J.U.C中许多常用同步器都是基于AQS实现，主要有以下：CountDownLatch，Semaphore，CyclicBarrier，ReentrantLock，Condition。<br>
下面对上述同步器进行源码分析, 源码分析下基于JDK 8。</p>
<h2 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h2>
<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3>
<p>ReentrantLock是在JDK 1.5 引入的一个显示锁，可以实现多线程的互斥访问，可以实现和synchronized关键字同样的功能。ReentrantLock只支持独占方式的获取操作，是对lock接口的实现。<br>
ReentrantLock将同步状态用于保存锁获取操作的次数（0 - 锁可被获取；整数i - 锁已被其他线程获取，因为ReentrantLock可重入，所以状态为整数i(i &gt;= 1)），并且还维护了一个owner变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。并且在tryRelease中检查owner域，从而确保当前线程在执行unlock操作之前已经获取了锁；在tryAcquire中使用这个域来区分获取操作是重入的还是竞争的。</p>
<h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3>
<p>下面的源码分析都是基于非公平的ReentrantLock实现。</p>
<h4 id="获取锁操作"><a class="markdownIt-Anchor" href="#获取锁操作"></a> 获取锁操作</h4>
<ol>
<li>
<p>lock()<br>
ReentrantLock对外提供lock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的获取操作。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>acquire(int arg)<br>
lock会调用acquire方法完成获取操作。若tryAcquire方法返回true，即成功获取到锁，就直接返回，线程继续往下运行；若获取失败则调用acquireQueud方法阻塞当前线程，等待锁的释放。<br>
tryAcquire方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算获取锁成功。<br>
阻塞一个线程由acquireQueued来实现。关于如何阻塞一个线程和如何唤醒线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryAcquire(int arg)<br>
ReentrantLock 实现 tryAcquire方法来获取资源。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 得到当前资源状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 当前同步状态 == 0, 表示锁未被获取</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 获取锁, 原子性修改同步状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置为独占模式的线程, 即owner状态</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若是重复获取, 即重入获取, 则修改同步状态为c+acquires</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="释放锁操作"><a class="markdownIt-Anchor" href="#释放锁操作"></a> 释放锁操作</h4>
<ol>
<li>
<p>unlock()<br>
ReentrantLock对外提供unlock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的释放操作。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>release(int arg)<br>
unlock方法会调用tryRelease方法去释放锁。若释放锁成功，则代表下一个等待锁的线程可以来获取锁，此时调用用unparkSuccesor方法唤醒；若释放锁失败，则直接返回。<br>
tryRelease方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算释放锁成功。<br>
关于如何唤醒下一个线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // tryRelease(arg)返回true, 则表示释放锁成功, </span><br><span class="line">    // 可以去唤醒下一个等待线程了</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        // 唤醒下一个等待线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryRelease(int releases)<br>
ReentrantLock 实现 tryRelease方法来释放资源。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 当前线程不是获取锁的线程, 抛出错误</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 若c == 0, 当前锁没有进行重入</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置锁状态, 因为是可重入的, 可能需要多次释放操作</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用实例"><a class="markdownIt-Anchor" href="#应用实例"></a> 应用实例</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();    </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void insert(Thread thread) &#123;</span><br><span class="line">        // 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3>
<ol>
<li>公平锁与非公平锁：<br>
公平锁尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁；<br>
非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</li>
<li>ReentrantLock 与 synchronized对比
<ol>
<li>ReentrantLock 是对lock接口的实现，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而ReentrantLock 在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用ReentrantLock 时需要在finally块中释放锁；</li>
<li>ReentrantLock 可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过ReentrantLock 可以知道有没有成功获取锁，而synchronized却无法办到； ReentrantLock 可以提高多个线程进行读操作的效率；</li>
<li>可以通过 ReentrantLock lock = new ReentrantLock(true) 来实现公平锁。</li>
</ol>
</li>
</ol>
<h2 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h2>
<h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h3>
<p>JUC提供了Lock可以方便的进行锁操作，但是有时候我们也需要对线程进行条件性的阻塞和唤醒，以此来模拟线程间的相互协助，这时我们就需要condition条件变量，它就像是在线程上加了多个开关，可以方便的对持有锁的线程进行阻塞和唤醒。<br>
官方解释如下：</p>
<blockquote>
<p>条件（也称为条件队列或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其&quot;等待&quot;）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式释放相关的锁，并挂起当前线程，就像Object.wait 做的那样</p>
</blockquote>
<p>Condition主要是为了在J.U.C框架中提供和Java传统的监视器风格的wait，notify和notifyAll方法类似的功能。wait，notify等需要和synchronized结合适用，Condition则绑定在一个锁（Lock）上，一般作Lock的内部实现。<br>
两者的主要区别见下图：</p>
<img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/compare.png" title="compare">
<h3 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h3>
<h4 id="condition-interface"><a class="markdownIt-Anchor" href="#condition-interface"></a> Condition interface</h4>
<p>Condition接口提供了如下方法以供实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*============阻塞=============*/</span><br><span class="line">// 当前线程在接到信号或被中断之前一直处于等待状态.=</span><br><span class="line">void await() throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号之前一直处于等待状态 [注意：该方法对中断不敏感]</span><br><span class="line">void awaitUninterruptibly(); </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">// 返回值表示剩余时间, 如果在&apos;nanosTimeout&apos;之前唤醒,那么返回值 </span><br><span class="line">=&apos;nanosTimeout - 消耗时间&apos;,</span><br><span class="line">// 如果返回值&apos;&lt;= 0&apos; ,则可以认定它已经超时了</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span><br><span class="line">// 如果没有到指定时间就被通知, 则返回 true ,否则表示到了指定时间,返回返回 false</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException; </span><br><span class="line"></span><br><span class="line">/*===========唤醒==============*/</span><br><span class="line">// 唤醒一个等待线程, 将线程从条件队列移到AQS同步队列中</span><br><span class="line">// 该线程从等待方法返回前必须获得与Condition相关的锁</span><br><span class="line">void signal(); </span><br><span class="line">// 唤醒所有等待线程, 将所有等待线程从条件队列中移到AQS步队列中</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure>
<p>Condition接口仅有一个实现类为ConditionObject，该类定义为AQS的内部类。</p>
<h4 id="线程挂起操作"><a class="markdownIt-Anchor" href="#线程挂起操作"></a> 线程挂起操作</h4>
<ol>
<li>
<p>await()<br>
线程在调用await方法后将执行挂起操作，即新建 Condition 节点加入到 Condition 的队列尾部，并阻塞当前线程在条件队列中，直到线程等待的某个条件为真时才会被唤醒。在当前线程持有锁的基础上释放锁资源，以便其他线程获取锁资源。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    // 线程被中断,则抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 将节点加入到条件队列(Condition Queue)中</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放当前线程的锁,因为锁可重入, 所以是完全释放</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 当前节点是否在AQS同步队列中</span><br><span class="line">    // 如果不在同步队列中, 则park当前线程, 说明该线程还未满足竞争锁资源的</span><br><span class="line">    // 条件；如果在或者被中断过, 则退出循环</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当走到这步时, 代表已经调用了signal/signalAll方法, 重新竞争锁资源</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 清理取消等待的节点</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>addConditionWaiter()<br>
addConditionWaiter会将新建一个状态为Condition状态的节点并加入到条件队列的末尾。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // Node的节点状态如果不为CONDITION,</span><br><span class="line">    // 则表示该节点不处于等待状态,需要清除节点</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程新建节点,状态 CONDITION</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fullyRelease()<br>
fullyRelease方法负责完成释放该线程持有的锁，因为例如 ReentrantLock 是可以重入的。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 持有锁的数量 </span><br><span class="line">        int savedState = getState();</span><br><span class="line">        // 完全释放锁, 因为ReentrantLock可重入</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed = false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁失败, 将节点状态置为CANCELLED</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>isOnSyncQueue()<br>
isOnSyncQueue方法判断一个节点是否在AQS的同步队列上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">    // 状态为 Condition或者前驱节点为 null, 返回 false</span><br><span class="line">    if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">        return false;</span><br><span class="line">    // 后继节点不为 null，肯定在同步队列中</span><br><span class="line">    if (node.next != null) </span><br><span class="line">        return true;</span><br><span class="line">    // 从同步队列尾部开始向前查找, 判断是否在同步队列上</span><br><span class="line">    return findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>unlinkCancelledWaiters()<br>
unlinkCancelledWaiters方法负责将条件队列中状态不为Condition的节点删除。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    // 记录上一个Node节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        // 节点状态不为CONDITION, 将其删除</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="线程唤醒操作"><a class="markdownIt-Anchor" href="#线程唤醒操作"></a> 线程唤醒操作</h4>
<ol>
<li>
<p>signal()<br>
signal方法会将Condition 的头节点移动到AQS同步队列尾部，让其等待再次获取锁资源。会首先唤醒条件队列中第一个节点，即等待时间最长的节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //检测当前线程是否拥有锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //头节点，唤醒条件队列中的第一个节点</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>doSignal()<br>
doSignal方法会依次移除条件队列的节点，并调用transferForSignal方法将节点移动到AQS同步队列中。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //修改头结点，完成旧头结点的移出工作</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    // 将条件队列中的节点移动到同步队列中</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">    (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>transferForSignal()<br>
transferForSignal会将条件队列的节点移动到AQS同步队列中。并修改当前节点的前一个结点状态为SIGNAL。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //将该节点从状态CONDITION改变为初始状态0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //将节点加入到同步队列中去,返回的是同步队列中node节点前面的一个节点</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //如果结点p的状态为cancel 或者修改waitStatus失败,则直接唤醒</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h3>
<p>使用Condition实现生产者消费者模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConditionExample &#123;</span><br><span class="line">    // 缓冲区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer;</span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line">    private Lock lock;</span><br><span class="line">    // 定义两个Condition, 即两个条件队列</span><br><span class="line">    private Condition fullCondition;</span><br><span class="line">    private Condition notFullCondition;</span><br><span class="line"></span><br><span class="line">    ConditionExample(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">        lock = new ReentrantLock();</span><br><span class="line">        fullCondition = lock.newCondition();</span><br><span class="line">        notFullCondition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        //获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                //缓冲区已经满了,不能再进行添加, </span><br><span class="line">                // 调用await方法将添加的线程设置为等待状态,并且释放锁</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加数据到缓存区</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            // 告知可以从缓冲区获取数据了 ,将fullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            fullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 记得释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (buffer.size() == 0)&#123;</span><br><span class="line">                // 缓冲区为空,不能进行获取, </span><br><span class="line">                // 调用await方法将获取的线程设置为等待状态,并且释放锁</span><br><span class="line">                fullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 从缓存区取数据</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            // 告知可以添加数据到缓存区了,将notFullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Object::wait，notify实现生产者消费者模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line"></span><br><span class="line">    ConditionTest(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p>[1] <a href="http://www.iocoder.cn/JUC/sike/Condition/" rel="external nofollow noopener noreferrer" target="_blank">http://www.iocoder.cn/JUC/sike/Condition/</a><br>
[2] <a href="https://www.cnblogs.com/dolphin0520/p/3920385.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3920385.html</a></p>
<h2 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h2>
<h3 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h3>
<p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源，或者说是同时执行某个特定操作的数量。<br>
Semaphore将AQS同步状态用来保存当前可用许可的数量，许可的数量可以通过构造函数的参数指定。</p>
<ol>
<li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可；</li>
<li>访问资源后，使用release释放许可。<br>
Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</li>
</ol>
<h3 id="源码分析-3"><a class="markdownIt-Anchor" href="#源码分析-3"></a> 源码分析</h3>
<h4 id="获取许可操作"><a class="markdownIt-Anchor" href="#获取许可操作"></a> 获取许可操作</h4>
<ol>
<li>
<p>acquire()<br>
Semaphore对外提供acquire方法，用户不需要了解其他详细的获取细节，线程通过调用该方法来获取许可，以完成对特定资源的访问。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>acquireSharedInterruptibly()<br>
acquireSharedInterruptibly方法会调用tryAcquireShared方法来获取许可。若返回正整数（大于等于0），表示获取许可成功，线程继续向前执行；否则将调用doAcquireSharedInterruptibly方法将线程加入到同步队列，等待许可的释放。<br>
tryAcquireShared方法交由Semaphore来实现，它自己来实现判断逻辑 - 怎么才算获取许可成功。<br>
xxxxShared表示该获取操作是非独占操作（Shared）。<br>
关于如何阻塞一个线程，将线程加入到同步队列中，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    // 线程中断</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 若返回整数, 则表示获取需求成功, 线程继续向后执行</span><br><span class="line">    // 否则, 获取失败, 将线程加入到同步队列, 等待许可的释放</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryAcquireShared()<br>
Semaphore实现tryAcquireShared方法来完成具体的许可获取逻辑。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到可用许可</span><br><span class="line">        int available = getState();</span><br><span class="line">        // 计算剩余许可</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        // 原子更新可用许可, 并返回剩余许可数</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="释放许可操作"><a class="markdownIt-Anchor" href="#释放许可操作"></a> 释放许可操作</h4>
<ol>
<li>
<p>release()<br>
Semaphore对外提供release方法，用户不需要了解其他详细的许可释放细节就可以完成许可释放操作。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>releaseShared()<br>
release方法会调用releaseShared方法去释放许可。若释放许可成功，则调用doReleaseShared方法来唤醒同步队列中的等待线程来尝试重新获取需求；若释放许可失败，则直接返回。<br>
tryReleaseShared方法交由Semaphore来实现，它自己来实现释放许可逻辑。<br>
关于如何释放同步队列中的一个等待线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 许可释放成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 唤醒等待获取许可的线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryReleaseShared()<br>
Semaphore通过tryReleaseShared方法来实现许可的释放逻辑。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到当前许可数量</span><br><span class="line">        int current = getState();</span><br><span class="line">        // 修改许可数量</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        // 原子更新许可数量</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用实例-2"><a class="markdownIt-Anchor" href="#应用实例-2"></a> 应用实例</h3>
<p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。<br>
读取数据到数据库中，可以启动几十个线程并发读取来进行读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreTest&#123;</span><br><span class="line">    private static final int COUNT = 40;</span><br><span class="line">    private static Executor executor = Executors.newFixedThreadPool(COUNT);</span><br><span class="line">    private static Semaphore semaphore = new Semaphore(10);</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        for(inti=0;i&lt;COUNT;i++)&#123;</span><br><span class="line">            executor.execute(newThreadTest.Task());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override </span><br><span class="line">        public void run()&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">            // 获取许可, 因为许可数量只有十个, 所有最多只能有10个线程进行操作</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            //todo 存数据过程</span><br><span class="line">            semaphore.release();</span><br><span class="line">            &#125;catch(InterruptedExceptione)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3>
<p>[1] <a href="https://www.jianshu.com/p/0090341c6b80" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0090341c6b80</a></p>
<h2 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h2>
<h3 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h3>
<p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<p>CountDownLatch是通过一个计数器来实现的，通过同步状态保存当前计数值，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/countDownLatch.png" title="countDownLatch">
<h3 id="源码分析-4"><a class="markdownIt-Anchor" href="#源码分析-4"></a> 源码分析</h3>
<h4 id="获取闭锁操作"><a class="markdownIt-Anchor" href="#获取闭锁操作"></a> 获取闭锁操作</h4>
<ol>
<li>
<p>await()<br>
CountDownLatch对外部提供await方法，用户不需要了解闭锁获取的细节，线程通过调用该方法来获取闭锁。<br>
在await() 方法中会调用与Semaphore相同的acquireShared方法来获取锁，并且获取失败之后的处理也一致，都是AQS提供了公共方法。主要不同体现在tryAcquireShared 方法的实现上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryAcquireShared(int acquires)<br>
当同步状态等于0时，表示其他线程已经全部执行完毕，获取闭锁成功，线程继续往下执行；若失败，则将线程放入到同步队列中，并阻塞线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    // 同步状态等于0时,代表其他线程已经执行完毕, 获取闭锁成功</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="释放闭锁操作"><a class="markdownIt-Anchor" href="#释放闭锁操作"></a> 释放闭锁操作</h3>
<ol>
<li>
<p>countDown()<br>
CountDownLatch对外部提供countDown方法，其他线程调用该方法来释放资源。<br>
在countDown() 方法中会调用与Semaphore相同的releaseShared方法来释放资源，并且释放成功之后的处理也一致，都会尝试唤醒同步队列上的等待线程，都是AQS提供了公共方法。主要不同体现在tryReleaseShared 方法的实现上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 释放资源成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 尝试唤醒同步队列的等待线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>tryReleaseShared(int args)<br>
tryReleaseShared方法将会减少同步状态，当同步状态等于0时，返回true，会调用doReleaseShared 方法唤醒同步队列的等待线程。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 减少同步状态直到为0</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="应用实例-3"><a class="markdownIt-Anchor" href="#应用实例-3"></a> 应用实例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchExample &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建一个线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; catch (Exception e)&#123;</span><br><span class="line">                    log.info(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 只有当threadCount 为0时, 即200个线程执行完毕之后, 才会执行后面的语句</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        // 等待10ms, 若200个线程没有执行完毕, 则当前线程会继续执行</span><br><span class="line">        // countDownLatch.await(10, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(&quot;finish&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test (int threadNum) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3>
<ol>
<li>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数器为1的CountDownLatch，并让其他所有线程都在这个锁上等待，只需要调用一次countDown()方法就可以让其他所有等待的线程同时恢复执行。</li>
<li>开始执行前等待N个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统都已经启动和运行了。</li>
<li>死锁检测：一个非常方便的使用场景是你用N个线程去访问共享资源，在每个测试阶段线程数量不同，并尝试产生死锁。</li>
</ol>
<h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3>
<p>[1] <a href="https://www.jianshu.com/p/4b6fbdf5a08f" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4b6fbdf5a08f</a></p>
<h3 id="countdownlatch和semaphore结合实例"><a class="markdownIt-Anchor" href="#countdownlatch和semaphore结合实例"></a> CountDownLatch和Semaphore结合实例</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcurrencyTest&#123;</span><br><span class="line">    //请求数</span><br><span class="line">    public static intc lientTotal=1000;</span><br><span class="line">    //并发请求数</span><br><span class="line">    public static int threadTotal=50;</span><br><span class="line">    //共享计数量</span><br><span class="line">    public static int count=0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)throws InterruptedException&#123;</span><br><span class="line">        //定义线程池</span><br><span class="line">        ExecutorService executorService=Executors.new CachedThreadPool();</span><br><span class="line">        //定义信号量,并设置运行并发数</span><br><span class="line">        final Semaphore semaphore=new Semaphore(threadTotal);</span><br><span class="line">        //定义CountDownLatch,在所有的请求完成之后输出结果</span><br><span class="line">        final CountDownLatch countDownLatch=new CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        //线程执行</span><br><span class="line">        for(inti=0;i&lt;clientTotal;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    //获取信号量-最大并发数为50</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    count();</span><br><span class="line">                    //释放信号量</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                    log.info(&quot;InterruptedException&quot;,e);</span><br><span class="line">                &#125;</span><br><span class="line">                //进行count--</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //只有countDown到0的时候,才会唤起线程继续执行,不然会挂起继续等待</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        //关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        //在所有子线程执行完之后,打印count值</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void count()&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h2>
<h3 id="概述-5"><a class="markdownIt-Anchor" href="#概述-5"></a> 概述</h3>
<p>CycliBarrier也称为循环屏障，它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，循环是指因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p>
<h3 id="实现原理-2"><a class="markdownIt-Anchor" href="#实现原理-2"></a> 实现原理</h3>
<p>CyclicBarrier将同步状态设置为到达屏障的线程数量。当某一个线程到达屏障之后，将当前线程加入到同步队列中并阻塞，并且数量减一，当数量为0时，唤醒被阻塞的所有线程，让它们继续执行。</p>
<img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/cyclicBarrier.png" title="cyclicBarrier">
<h3 id="源码分析-5"><a class="markdownIt-Anchor" href="#源码分析-5"></a> 源码分析</h3>
<ol>
<li>
<p>CyclicBarrier(int parties) / CyclicBarrier(int parties, Runnable barrierAction)<br>
CyclicBarrier提供了两种构造方法，提供了参数有：需要到达屏障的线程数，到达指定屏障后优先执行的动作。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    // 屏障数量</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    // 当前还有多少线程没有到达屏障</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>await()<br>
CyclicBarrier对外提供await方法。用户不需要了解循环屏障的具体实现细节就可使用其提供的功能。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // dowait(timed, nanos)</span><br><span class="line">        // 当timed = true时, 表示设置等待超时时间, nanos为时才</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dowait(boolean timed, long nanos)<br>
await通过调用dowait方法来实现线程的阻塞和唤醒。若还有剩余线程未到达屏障，线程通过调用该方法来完成阻塞操作，将线程阻塞在屏障前；若所有线程已到达屏障前，则唤醒所有被阻塞的线程，让它们继续向前执行。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">throws InterruptedException, BrokenBarrierException,</span><br><span class="line">TimeoutException &#123;</span><br><span class="line">    // 定义一个可重入锁, 保证多线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 构建一个&quot;代&quot;(Generation)对象</span><br><span class="line">        // 同一个Generation表示同一代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        // 如果broken=true表示当前屏障被损坏了,抛出异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        // 如果线程被中断过, 设置屏障为损坏状态    </span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 需要到达屏障的线程数减 - 1</span><br><span class="line">        int index = --count;</span><br><span class="line">        // 若数量为0, 表示所有线程都到达了屏障</span><br><span class="line">        if (index == 0) &#123;</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                // 表示到达屏障之后,如果我们有设置barrierCommand, 则优先执行</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                 //执行到这里的时候，说明所有线程都执行await()方法(到达了屏障)</span><br><span class="line">                // 且设置的barrierCommand也已经执行完了</span><br><span class="line">                //接下来要做的事情就是换代(所以CyclicBarrier是通过换代的方式</span><br><span class="line">                // 实现重新计数的)</span><br><span class="line">                //换代之后相当于进入一个新的周期,所有线程在后续中又可以通过</span><br><span class="line">                // await()阻塞一次</span><br><span class="line">                ranAction = true;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 如果ranAction = false说明当前屏障还有流程没执行完,</span><br><span class="line">                // 所以需要屏障设置会损坏状态</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 进行自旋操作直到count=0,调用breakBarrier方法(表示屏障有问题的场景),</span><br><span class="line">        // 中断或者超时</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            // 没有设置超时时间,</span><br><span class="line">            // 调用Condition的await()阻塞,相当于把线程加入</span><br><span class="line">            // 到Condition队列中阻塞, 等到调用signalAll方法唤醒</span><br><span class="line">            if (!timed)</span><br><span class="line">                trip.await();</span><br><span class="line">            // 设置阻塞超时时间</span><br><span class="line">            else if (nanos &gt; 0L)</span><br><span class="line">                nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                // 如果当前屏障没有换代,也没有损坏,</span><br><span class="line">                // 那么就设置为损坏状态之后再抛出中断异常</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 中断线程等待</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果屏障已经被损坏了</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line">                                        </span><br><span class="line">            // 如果发现已经换代了, 就不继续循环了,</span><br><span class="line">            // 直接返回剩余屏障数</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            // 表示超时时间到了</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>nextGeneration()<br>
若所有线程都到达了屏障，将条件队列中的线程切换到AQS同步队列中，并唤醒所有等待线程。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 条件队列中的等待线程切换AQS同步队列中, AQS同步队列中等待线程依次被唤醒获取锁</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // 开始一个循环屏障</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用实例-2"><a class="markdownIt-Anchor" href="#使用实例-2"></a> 使用实例</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line"></span><br><span class="line">    // 设置屏障数量为5</span><br><span class="line">    // private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span><br><span class="line">    // 到达指定屏障之后, 优先执行barrierAction中的动作</span><br><span class="line">    private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&gt; &#123;</span><br><span class="line">        log.info(&quot;Priority Action!!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    doSomething(threadNum);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void doSomething(int threadNum) throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am ready!&quot;, threadNum);</span><br><span class="line">        // 某个线程初始化完毕, 则阻塞等待, 若阻塞数量达到5个, 则一起执行每个线程后面的方法</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am done!&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3>
<p>CyclicBarrier适用多线程计算数据，最后合并计算结果的场景。<br>
相比于CountDownLatch，CyclicBarrier能适用于更多场景，例如，如果计算发生错误，可以重置计数 器，并让线程重新执行一次。因为CountDownLatch计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</p>
<h3 id="参考资料-3"><a class="markdownIt-Anchor" href="#参考资料-3"></a> 参考资料</h3>
<p>[1] <a href="http://blog.sikacode.com/article/40#CyclicBarrier_68" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sikacode.com/article/40#CyclicBarrier_68</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析.html">http://www.huangbin.fun/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J-U-C/">J.U.C</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/J-U-C之Callable-Future-FutureTask.html"><i class="fa fa-chevron-left">  </i><span>J.U.C之Callable, Future, FutureTask</span></a></div><div class="next-post pull-right"><a href="/J-U-C之AQS源码学习.html"><span>J.U.C之AQS源码学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>