<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>&lt;LeetCode&gt;最长回文子串</title>
      <link href="/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
      <url>/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探动态规划算法</title>
      <link href="/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
      <url>/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;LeetCode&gt;最长公共前缀</title>
      <link href="/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"/>
      <url>/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br></p><ul><li><p>示例 1:<br>输入: [“flower”,“flow”,“flight”]<br>输出: “fl”<br></p></li><li><p>示例 2:<br>输入: [“dog”,“racecar”,“car”]&lt;<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="垂直扫描法"><a class="markdownIt-Anchor" href="#垂直扫描法"></a> 垂直扫描法</h2><p><img src="https://pic.leetcode-cn.com/b647cab7c3d2bd157cecae10917e0b9b671756b92c9cfcefec1a2bdae299c11c-file_1555694071243" alt="水平扫描法"></p><ol><li>取出第一个字符串暂时作为最长公共前缀（prefixStr）；</li><li>依次遍历字符串数组中的其他字符串，分别与prefixStr比较；</li><li>若当前字符不包含prefixStr，则对prefixStr进行裁取（长度减一），再次与当前字符进行比较；</li><li>若当前字符包含prefixStr，则取出字符串数组的下一个字符串与prefixStr进行比较；</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><ul><li>时间复杂度：O(S)，S是所有字符串中字符数量的总和，最坏情况时n个字符串全部相同，则indexOf要比较S次字符比较</li><li>空间复杂度：O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) return &quot;&quot;;</span><br><span class="line">        String prefixStr = strs[0];  </span><br><span class="line">        for(int i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">            while(strs[i].indexOf(prefixStr) != 0)&#123;  </span><br><span class="line">                prefixStr = prefixStr.substring(0,prefixStr.length() - 1); </span><br><span class="line">                if(prefixStr.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefixStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平扫描法"><a class="markdownIt-Anchor" href="#水平扫描法"></a> 水平扫描法</h2><ol><li>取出字符串数组中的第一个字符串，遍历该字符串中的字符，依次与数组中的其他字符串的同列字符比较；</li><li>若出现不同的字符，则对第一个字符串进行相应位置截取，便得最长公共前缀；</li><li>若某字符串长度等于当前所比较字符位置（i = strs[j].length()），则也进行第2步的截取操作；</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><ul><li>时间复杂度: O(S)，S 是所有字符串中字符数量的总和</li><li>空间复杂度: O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for(int i = 0; i &lt; strs[0].length(); i++)&#123;</span><br><span class="line">            char a = strs[0].charAt(i);</span><br><span class="line">            for(int j = 1; j &lt; strs.length; j++)&#123;</span><br><span class="line">                if( i == strs[j].length() || a != strs[j].charAt(i))&#123;    // 先执行||, 然后执行后面, 且i == strs[j].length()表示存在字符串已经遍历完</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;LeetCode&gt; 无重复字符的最长子串长度</title>
      <link href="/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html"/>
      <url>/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br></p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h2><p>滑动窗口算法用于对给定的大缓冲区或数组的特定窗口大小执行所需的操作(即在遍历大缓存区或数组时, 对其特定的窗口大小执行特定操作)。目的是将很少出现问题的嵌套for循环转换为单个for循环，从而降低时间复杂度。例如: 找出某数组中和最大的子数组， 规定子数组元素个数为3， 即窗口大小为3， 当然窗口大小也可以是动态的。具体过程如下：<br><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动过程"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>实现一</strong></p><ul><li>时间复杂度: O(2n)=O(n)，最糟糕的情况下，每个字符要被i，j分别访问一次</li><li>空间复杂度: O(min(m, n))，滑动窗口法需要 O(k)的空间，其中 k表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int record = 0,i = 0,j = 0;  // record记录最长子串长度</span><br><span class="line">        int length = s.length(); </span><br><span class="line">        Set strSet = new HashSet();  // 使用HashSet作为滑动窗口</span><br><span class="line">        while(i &lt; length &amp;&amp; j &lt; length)&#123;</span><br><span class="line">            if(!strSet.contains(s.charAt(j)))&#123;  // s.charAt(j)不在strSet中</span><br><span class="line">                strSet.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                record = Math.max(record, j - i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                strSet.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现二</strong><br><br>该实现是对滑动窗口的优化，即在窗口中存在与当前元素相同的字符，直接把窗口左端移动到相同字符的后一位，而不是一步一步的移动左端窗口。</p><ul><li>时间复杂度: O(n)，单单j会遍历n次</li><li>空间复杂度: O(min(m, n))</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length(), record = 0;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0, j = 0; j &lt; length; j++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(j)))&#123;  // 包含了有相同字符</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)),i);  // 把i定位到存储在map中且与s.charAt(j)相同的字符的下一个索引位置</span><br><span class="line">            &#125;</span><br><span class="line">            record = Math.max(record,j - i + 1);  // + 1是因为前面已经排除了相同字符, 遂可把s.charAt(j)字符加入参与长度计算 </span><br><span class="line">            map.put(s.charAt(j), j + 1);  // 把s.charAt(j)索引+1是方便i的定位(定位到相同元素的后一位)</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习课程练习代码实现(Octave版/Python版)</title>
      <link href="/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html"/>
      <url>/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-Octave%E7%89%88-Python%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习课程练习代码实现octave版python版"><a class="markdownIt-Anchor" href="#吴恩达机器学习课程练习代码实现octave版python版"></a> 吴恩达机器学习课程练习代码实现(Octave版/Python版)</h1><p> 吴恩达老师的机器学习课程成为了众多机器学习爱好者进入机器学习世界的敲门砖, 老师通俗易懂的授课方式让人能够快速的了解机器学习。 老师的课后练习使用Octave语言进行编写, 但是现在机器学习中使用更加普遍的是Python语言, 为了兼顾两者, 我就自己编写的两个版本的代码实现进行分享。对于每个作业PDF文档也进行了相应注释。</p><ul><li>Linear Regression</li><li>Logistic Regression</li><li>Neural Network</li><li>NN Back Propagation</li><li>Bias vs Variance</li><li>SVM</li><li>Kmeans and PCA</li><li>Anomaly Detection and Recommendation</li></ul><p>  <strong>具体代码文档下载链接:</strong> <a href="https://github.com/hbheyho/MachineLearningExam-Andrew-Ng" rel="external nofollow noopener noreferrer" target="_blank">MachineLearningExam-Andrew-Ng</a><br> ps: 若查看Python版本, 建议使用Jupyter Notebook进行阅读</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 服务/脚本/命令自启动配置</title>
      <link href="/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html"/>
      <url>/Linux-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h2 id="linux服务自启动"><a class="markdownIt-Anchor" href="#linux服务自启动"></a> Linux服务自启动</h2><p> 若程序（脚本）已注册成服务，则可通过service serviceName start/stop/status来启动服务、停止服务和查看服务状态，也可通过/etc/init.d/serviceName start/stop来开启和停止服务。<br> 可通过/etc/rc.d/init.d或/etc/init.d查看linux全部服务。</p><h3 id="方法一修改配置文件"><a class="markdownIt-Anchor" href="#方法一修改配置文件"></a> 方法一：修改配置文件</h3><p> 修改 /etc/rc.d/rc.local或/etc/rc.local文件（该文件在系统启动时，在输入用户名和密码之前最后读取的文件），加入服务启动命令来实现服务自启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"># 系统启动时，tomcat6服务自启动</span><br><span class="line">/etc/rc.d/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><h3 id="方法二chkconfig命令"><a class="markdownIt-Anchor" href="#方法二chkconfig命令"></a> 方法二：chkconfig命令</h3><p> chkconfig命令格式：<em>chkconfig serviceName on/off</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自启动tomcat服务</span><br><span class="line">chkconfig tomcat on</span><br><span class="line">#关闭tomcat自启动</span><br><span class="line">chkconfig tomcat off</span><br></pre></td></tr></table></figure><h3 id="方法三通过ntsysv调用窗口模式来管理服务的自启动"><a class="markdownIt-Anchor" href="#方法三通过ntsysv调用窗口模式来管理服务的自启动"></a> 方法三：通过ntsysv调用窗口模式来管理服务的自启动</h3><p> ntsysv命令格式：<em>ntsysv [–level 运行级别]</em><br>          --level 运行级别：可以指定设定自启动的运行级别；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只设定2、3、5级别的服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv --level 235</span><br><span class="line">#按默认的运行级别设置服务自启动</span><br><span class="line">[root@localhost ~]# ntsysv</span><br></pre></td></tr></table></figure><p>执行上述命令之后linux界面如下，使用空格键来选定/取消服务的自启动，其中*号代表该服务自启动。</p><img src="/Linux-服务-脚本-命令自启动配置/ntsysv设置自启动.png" title="ntsysv设置自启动"><p><strong>注意：ntsysv属于redhat系列linux的专有命令</strong></p><h2 id="linux脚本自启动"><a class="markdownIt-Anchor" href="#linux脚本自启动"></a> Linux脚本自启动</h2><h3 id="方法一把脚本放到etcrclocal"><a class="markdownIt-Anchor" href="#方法一把脚本放到etcrclocal"></a> 方法一：把脚本放到/etc/rc.local</h3><p>脚本文件start_tomcat.sh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#启动tomcat</span><br><span class="line">/etc/init.d/tomcat6 start</span><br></pre></td></tr></table></figure><p>把需自启动的脚本文件放入/etc/rc.local</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#当系统启动时便执行start_tomcat.sh脚本</span><br><span class="line">/root/start_tomcat.sh        #脚本执行方式：绝对路径执行方式，path/脚本文件</span><br></pre></td></tr></table></figure><h3 id="方法二把sh脚本移动到etcprofiled"><a class="markdownIt-Anchor" href="#方法二把sh脚本移动到etcprofiled"></a> 方法二：把sh脚本移动到/etc/profile.d</h3><p> /etc/profile.d中的脚本文件执行情景：当一个用户登录Linux系统或使用切换到另一个用户时才会调用，所以不建议使用</p><h2 id="linux自启动命令"><a class="markdownIt-Anchor" href="#linux自启动命令"></a> Linux自启动命令</h2><p> 若要自启动命令，则把需要自启动的命令放在/etc/rc.local中。</p>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Shell提取文件名称和目录方法</title>
      <link href="/Linux-Shell%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95.html"/>
      <url>/Linux-Shell%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="单路径提取"><a class="markdownIt-Anchor" href="#单路径提取"></a> 单路径提取</h2><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用${}</h3><p> ${}主要用来进行变量的提取和替换等等操作，它可以提取非常多的内容，<strong>提取文件路径知识它使用的一个特例</strong>。</p><ul><li>#：表示从左边算起第一个</li><li>%：表示从右边算起第一个</li><li>##：表示从左边算起最后一个</li><li>%%：表示从右边算起最后一个</li><li>＊：表示要删除的内容，对于#和##的情况，它位于指定的字符（例子中的’/‘和’.’）的左边，表于删除指定字符及其左边的内容；对于%和%%的情况，它位于指定的字符（例子中的’/‘和’.’）的右边，表示删除指定字符及其右边的内容。这里的’*'的位置不能互换，即不能把*号放在#或##的右边，反之亦然。</li></ul><h4 id="filepath"><a class="markdownIt-Anchor" href="#filepath"></a> ${filePath##*/}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’/‘字符及其左边的内容，返回从左边算起的最后一个’/’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo $&#123;filePath##*/&#125;</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><h4 id="filepath-2"><a class="markdownIt-Anchor" href="#filepath-2"></a> ${filePath##*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的最后一个’.‘字符及其左边的内容，返回从左边算起的最后一个’.’（不含该字符）的右边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath##*.&#125;</span><br><span class="line">txt</span><br></pre></td></tr></table></figure><h4 id="filepath-3"><a class="markdownIt-Anchor" href="#filepath-3"></a> ${filePath#*.}</h4><p> 该命令的作用是去掉变量filePath从左边算起的第一个’.‘字符及其左边的内容，返回从左边算起第一个’.’（不含该字符）的右边部分的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.tar.zip&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath#*.&#125;</span><br><span class="line">tar.zip</span><br></pre></td></tr></table></figure><h4 id="filepath-4"><a class="markdownIt-Anchor" href="#filepath-4"></a> ${filePath%/*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的第一个’/‘字符及其右边的内容，返回从右边算起的第一个’/’（不含该字符）的左边的内容。使用例子及结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%/*&#125;</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h4 id="filepath-5"><a class="markdownIt-Anchor" href="#filepath-5"></a> ${filePath%%.*}</h4><p> 该命令的使用是去掉变量filePath从右边算起的最后一个’.‘字符及其右边的内容，返回从右边算起的最后一个’.’（不含该字符）的左边的内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $&#123;filePath%%.*&#125;</span><br><span class="line">/tmp/test</span><br></pre></td></tr></table></figure><h3 id="使用basename-dirname"><a class="markdownIt-Anchor" href="#使用basename-dirname"></a> 使用basename、dirname</h3><p> basename和dirname命令就是专门为做这一件事而已准备的了。</p><h4 id="basename"><a class="markdownIt-Anchor" href="#basename"></a> basename</h4><p> 该命令的作用是从路径中提取出文件名，使用方法为basename NAME [SUFFIX]。</p><ul><li>从路径中提出文件名（带后缀）：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath)</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><ul><li>从上面命令的用法中可以看到，后缀（SUFFIX）是一个可选项。所以，若只想提取出文件名file，而不带有后缀，还可以在变量的后面加上后缀名：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# filePath=&quot;/tmp/test.txt&quot;</span><br><span class="line">[root@localhost tmp]# echo  $(basename $filePath .txt)</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="dirname"><a class="markdownIt-Anchor" href="#dirname"></a> dirname</h4><p>  该命令的作用是从路径中提取出目录名，使用方法为 dirname NAME</p><ul><li>提取test.txt所在目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirname /tmp/test.txt</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><p>注：该命令不仅能提取出普通文件所的目录，它能提取出任何文件所在的目录，例如目录所在的目录，如下：</p><ul><li>提取目录的目录</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# dirPath=/tmp/testDir/</span><br><span class="line">[root@localhost tmp]# dirname $dirPath</span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure><h2 id="提取目录中所有文件名称"><a class="markdownIt-Anchor" href="#提取目录中所有文件名称"></a> 提取目录中所有文件名称</h2><h3 id="get_filenamesh"><a class="markdownIt-Anchor" href="#get_filenamesh"></a> get_fileName.sh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">folderPath=&quot;/root&quot;</span><br><span class="line">files=$(ls $FloderPath)</span><br><span class="line">for filename in $files</span><br><span class="line">do</span><br><span class="line">echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# bash get_fileName.sh</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">start_tomcat.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]Linux中防火墙概述</title>
      <link href="/%E8%BD%AC-Linux%E4%B8%AD%E9%98%B2%E7%81%AB%E5%A2%99%E6%A6%82%E8%BF%B0.html"/>
      <url>/%E8%BD%AC-Linux%E4%B8%AD%E9%98%B2%E7%81%AB%E5%A2%99%E6%A6%82%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<p>Linux防火墙概述</p><p><strong>转载</strong>： <a href="http://www.zsythink.net/archives/1199" rel="external nofollow noopener noreferrer" target="_blank">http://www.zsythink.net/archives/1199</a></p><h3 id="防火墙相关概述"><a class="markdownIt-Anchor" href="#防火墙相关概述"></a> 防火墙相关概述</h3><p>  从逻辑上讲。防火墙可以大体分为主机防火墙和网络防火墙。</p><ul><li>主机防火墙：针对于单个主机进行防护。</li><li>网络防火墙：往往处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。</li></ul><p>  网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。<br>  从物理上讲，防火墙可以分为硬件防火墙和软件防火墙。</p><ul><li>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。</li><li>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。</li></ul><h3 id="iptables是什么"><a class="markdownIt-Anchor" href="#iptables是什么"></a> iptables是什么</h3><p>  iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的安全框架中，这个安全框架才是真正的防火墙，这个框架的名字叫netfilter。netfilter才是防火墙真正的安全框架（framework），netfilter位于内核空间。<br>  iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。<br>  netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。<br>  Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p><ul><li>网络地址转换(Network Address Translate)</li><li>数据包内容修改</li><li>数据包过滤的防火墙功能</li></ul><p>  所以说，虽然我们使用service iptables start启动iptables服务，但是其实准确的来说，iptables并没有一个守护进程，所以并不能算是真正意义上的服务，而应该算是内核提供的功能。</p><h3 id="规则的定义"><a class="markdownIt-Anchor" href="#规则的定义"></a> 规则的定义</h3><p>  <strong>规则</strong>：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。配置防火墙的主要工作就是添加、修改和删除这些规则。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。<br>  那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条链都是一个关卡，每个通过这个关卡的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个报文，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的规则，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合器宇轩昂的标准，所以把你放行了，而我不符合标准，所以没有被放行，其实，<strong>器宇轩昂就是一种匹配条件，放行就是一种动作，匹配条件与动作组成了规则</strong>。<br>  规则由匹配条件和处理动作组成。</p><ul><li><p>匹配条件分为基本匹配条件与扩展匹配条件</p><ul><li>基本匹配条件：源地址Source IP，目标地址 Destination IP</li><li>扩展匹配条件：除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。源端口Source Port, 目标端口Destination Port都可以作为扩展匹配条件。</li></ul></li><li><p>处理动作在iptables中被称为target，动作也可以分为基本动作和扩展动作。</p><ul><li>ACCEPT：允许数据包通过。</li><li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li><li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li><li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li><li>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li><li>DNAT：目标地址转换。</li><li>REDIRECT：在本机做端口映射。</li><li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li></ul></li></ul><h3 id="链的定义"><a class="markdownIt-Anchor" href="#链的定义"></a> 链的定义</h3><p>  我们知道，防火墙的作用就在于对经过的报文匹配规则，然后执行对应的动作 , 所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了链 , 每个经过这个关卡的报文，都要将这条链上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。</p><img src="/转-Linux中防火墙概述/链的定义.png" title="链的定义"><h3 id="表的定义"><a class="markdownIt-Anchor" href="#表的定义"></a> 表的定义</h3><p>  我们对每个链上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。<br>  我们把具有相同功能的规则的集合叫做表，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下表</p><ul><li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li><li>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</li><li>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</li><li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</li></ul><p>  也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张表中。</p><h3 id="链和表关系"><a class="markdownIt-Anchor" href="#链和表关系"></a> 链和表关系</h3><p>  但是我们需要注意的是，某些链中注定不会包含某类规则，就像某些关卡天生就不具备某些功能一样，比如，A关卡只负责打击陆地敌人，没有防空能力，B关卡只负责打击空中敌人，没有防御步兵的能力，C关卡可能比较NB，既能防空，也能防御陆地敌人，D关卡最屌，海陆空都能防。<br>  让我们看看每个链上的规则都存在于哪些表中。</p><ul><li>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</li><li>INPUT的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</li><li>FORWARD的规则可以存在于：mangle表，filter表。</li><li>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</li><li>POSTROUTING的规则可以存在于：mangle表，nat表。</li></ul><p>  但是，我们在实际的使用过程中，往往是通过表作为操作入口，对规则进行定义的，之所以按照上述过程介绍iptables，是因为从关卡的角度更容易从入门的角度理解，但是为了以便在实际使用的时候，更加顺畅的理解它们，此处我们还要将各表与链的关系罗列出来，<br>表（功能）-----------------------&gt; 链（钩子）：</p><ul><li>raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT</li><li>mangle表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li><li>nat表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）</li><li>filter表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</li></ul><img src="/转-Linux中防火墙概述/链与表关系.png" title="链与表关系"><p>  其实我们还需要注意一点，因为数据包经过一个链的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张表中，那么，哪些表中的规则会放在链的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting链做图示。</p><img src="/转-Linux中防火墙概述/preouting优先级.png" title="preouting优先级">   <p>  prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：raw --&gt; mangle --&gt; nat<br>  但是我们知道，iptables为我们定义了4张表,当他们处于同一条链时，执行的优先级如下。<br>优先级次序（由高而低）：raw --&gt; mangle --&gt; nat --&gt; filter<br>  4张表中的规则处于同一条链的目前只有output链，它就是传说中海陆空都能防守的关卡。<br>  为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较短的链子，这条短链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要焊接在iptables默认定义链子上，才能被IPtables使用。</p><h3 id="数据经过防火墙流程"><a class="markdownIt-Anchor" href="#数据经过防火墙流程"></a> 数据经过防火墙流程</h3><p>  所以，根据上图，我们能够想象出某些常用场景中，报文的流向：</p><img src="/转-Linux中防火墙概述/数据经过防火墙流程.png" title="数据经过防火墙流程"><ul><li>到本机某进程的报文：PREROUTING --&gt; INPUT</li><li>由本机转发的报文：PREROUTING --&gt; FORWARD --&gt; POSTROUTING</li><li>由本机的某进程发出报文（通常为响应报文）：OUTPUT --&gt; POSTROUTING</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为blog生成定制RSS</title>
      <link href="/%E4%B8%BAblog%E7%94%9F%E6%88%90%E5%AE%9A%E5%88%B6RSS.html"/>
      <url>/%E4%B8%BAblog%E7%94%9F%E6%88%90%E5%AE%9A%E5%88%B6RSS.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是rss"><a class="markdownIt-Anchor" href="#什么是rss"></a> 什么是RSS？</h2><blockquote><p>RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。 你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。 它不会过时，信息越是过剩，它的意义也越加彰显。</p></blockquote><h2 id="怎么定制blogrss基于hexo"><a class="markdownIt-Anchor" href="#怎么定制blogrss基于hexo"></a> 怎么定制blogRSS（基于hexo）？</h2><p><strong>step1</strong>： 下载hexo plugin</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><strong>step2</strong>：修改_config配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  # Extensions</span><br><span class="line">plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br></pre></td></tr></table></figure><p> 属性解释：</p><ul><li>type: RSS的类型(atom/rss2)</li><li>path: 文件路径，默认是 atom.xml/rss2.xml</li><li>limit: 展示文章的数量,使用 0 或则 false 代表展示全部</li><li>hub:  PubSubHubbub hubs的URL (如果使用不到可以为空)</li><li>content: （可选）设置 true 可以在RSS文件中包含文章全部内容，默认：false</li><li>content_limit: （可选）摘要中使用的帖子内容的默认长度。 仅在content设置为false且未显示自定义帖子描述时才使用。</li><li>content_limit_delim: （可选，默认不使用）如果content_limit启用来缩短帖子内容,则在达到字符限制之前， 在分隔符最后出现时进行剪切。</li><li>order_by: 订阅内容的顺序. (默认: -date)</li><li>icon - (可选) 自定义的推送图标.默认为主配置中指定的电子邮件的gravatar。</li></ul><h2 id="生成rssatomxml"><a class="markdownIt-Anchor" href="#生成rssatomxml"></a> 生成RSS（atom.xml）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g  // 生成路径public-&gt;atom.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm --save-dev与--save 的区别</title>
      <link href="/npm-save-dev%E4%B8%8E-save-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/npm-save-dev%E4%B8%8E-save-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p> npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install–save另一个是 npm install –save-dev，他们<strong>表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下</strong>，譬如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.2.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-latest"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"cross-env"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^0.25.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^11.1.4"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^2.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不过这只是它们的表面区别。它们真正的区别是：<br> <strong>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖</strong>。即devDependencies下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记FTP学习的一个小坑</title>
      <link href="/%E8%AE%B0FTP%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
      <url>/%E8%AE%B0FTP%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p> 在搭建好FTP服务器之后，用浏览器进行连接一直连接不上(<strong>在保证用户名和密码都正确的基础上</strong>)，Chrome完全没有提示信息，火狐提示如下：</p><img src="/记FTP学习的一个小坑/火狐提示信息.png" title="火狐提示信息"><p> 从提示可以看出<strong>Policy requires SSL 即SSL策略需要SSL的验证</strong>，我们只需修改自身的FTP服务器SSL配置，把需要SSL连接修改为允许SSL连接</p><img src="/记FTP学习的一个小坑/设置界面.png" title="设置界面"><p><strong>PS</strong>：需要注意的是，使用FTP客户端工具，类似于FileZilla是可以连接的，它会有相应的提示，提示说该连接不安全巴拉巴拉的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Ajax异步请求的跨域以及Session问题</title>
      <link href="/%E5%85%B3%E4%BA%8EAjax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8ASession%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%85%B3%E4%BA%8EAjax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8ASession%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p> 根据浏览器的保护规则，跨域时候的SeeionId是不会被保存下来，即我们的每次Ajax请求都会是一个新的请求，都会产生新的SeesionId，后台自然不能根据前台传过来的SeesionId判断你是否处于登录状态。<br> 我们可以对前台的Ajax以及后台进行相应的修改，就可以对上述问题进行完美解决：</p><h3 id="前端ajax请求"><a class="markdownIt-Anchor" href="#前端ajax请求"></a> 前端Ajax请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;    </span><br><span class="line">    url:url,</span><br><span class="line">    xhrFields: &#123;      </span><br><span class="line">         withCredentials: <span class="literal">true</span>   <span class="comment">// 加上此部分</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    crossDomain: <span class="literal">true</span>,     <span class="comment">// 加上此部分</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;, </span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="controller部分代码"><a class="markdownIt-Anchor" href="#controller部分代码"></a> Controller部分代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"XXXX.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">XXXXX</span><span class="params">( HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"><span class="comment">// 解决跨域</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>,request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line"><span class="comment">// 跨域的session 保证同一性</span></span><br><span class="line">response.addHeader(<span class="string">"Access-Control-Allow-Credentials"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">  somecode</span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure><p><strong>PS</strong>: withCredentials：默认情况下，跨源请求不提供凭据(cookie、HTTP认证及客户端SSL证明等)。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。<br> 如果服务器接收带凭据的请求，会用下面的HTTP头部来响应,Access-Control-Allow-Credentials: true。如果发送的是带凭据的请求，但服务器的相应中没有包含这个头部，那么浏览器就不会把相应内容交给Ajax(于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序)。<br> 支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解各种推荐机制原理</title>
      <link href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8E%A8%E8%8D%90%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html"/>
      <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8E%A8%E8%8D%90%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于人口统计学的推荐"><a class="markdownIt-Anchor" href="#基于人口统计学的推荐"></a> 基于人口统计学的推荐</h2><p> 基于人口统计学的推荐机制（Demographic-based Recommendation）是一种最易于实现的推荐方法，它只是简单的根据系统用户的基本信息发现用户的相关程度，然后将相似用户喜爱的其他物品推荐给当前用户。</p><img src="/深入理解各种推荐机制原理/基于人口统计学的推荐机制.png" title="基于人口统计学的推荐机制"><h3 id="基于人口统计学的推荐机制工作原理"><a class="markdownIt-Anchor" href="#基于人口统计学的推荐机制工作原理"></a> 基于人口统计学的推荐机制工作原理</h3><p> 从图中可以很清楚的看到，首先，系统对每个用户都有一个用户 Profile 的建模，其中包括用户的基本信息，例如用户的年龄，性别等等；然后，系统会根据用户的 Profile 计算用户的相似度，可以看到用户 A 的 Profile 和用户 C 一样，那么系统会认为用户 A 和 C 是相似用户，在推荐引擎中，可以称他们是“邻居”；最后，基于“邻居”用户群的喜好推荐给当前用户一些物品，图中将用户 A 喜欢的物品 A 推荐给用户 C。</p><h3 id="好处"><a class="markdownIt-Anchor" href="#好处"></a> 好处</h3><p>  1. 因为不使用当前用户对物品的喜好历史数据，所以对于新用户来讲没有“冷启动（Cold Start）”的问题。<br>  2. 这个方法不依赖于物品本身的数据，所以这个方法在不同物品的领域都可以使用，它是领域独立的（domain-independent）。</p><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><p> 这种基于用户的基本信息对用户进行分类的方法过于粗糙，尤其是对品味要求较高的领域，比如图书，电影和音乐等领域，无法得到很好的推荐效果。可能在一些电子商务的网站中，这个方法可以给出一些简单的推荐。另外一个局限是，这个方法可能涉及到一些与信息发现问题本身无关却比较敏感的信息，比如用户的年龄等，这些用户信息不是很好获取。</p><h2 id="基于内容的推荐"><a class="markdownIt-Anchor" href="#基于内容的推荐"></a> 基于内容的推荐</h2><p> 基于内容的推荐是在推荐引擎出现之初应用最为广泛的推荐机制，它的核心思想是根据推荐物品或内容的元数据，发现物品或者内容的相关性，然后基于用户以往的喜好记录，推荐给用户相似的物品。</p><img src="/深入理解各种推荐机制原理/基于内容的推荐机制.png" title="基于内容的推荐机制"><h3 id="基于内容的推荐工作原理"><a class="markdownIt-Anchor" href="#基于内容的推荐工作原理"></a> 基于内容的推荐工作原理</h3><p> 电影推荐系统，首先我们需要对电影的元数据有一个建模，这里只简单的描述了一下电影的类型；然后通过电影的元数据发现电影间的相似度，因为类型都是“爱情，浪漫”电影 A 和 C 被认为是相似的电影（当然，只根据类型是不够的，要得到更好的推荐，我们还可以考虑电影的导演，演员等等）；最后实现推荐，对于用户 A，他喜欢看电影 A，那么系统就可以给他推荐类似的电影 C。</p><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><p> 这种基于内容的推荐机制的好处在于它能很好的建模用户的口味，能提供更加精确的推荐。但它也存在以下几个问题：<br>  1. 需要对物品进行分析和建模，推荐的质量依赖于对物品模型的完整和全面程度。在现在的应用中我们可以观察到关键词和标签（Tag）被认为是描述物品元数据的一种简单有效的方法。<br>  2. 物品相似度的分析仅仅依赖于物品本身的特征，这里没有考虑人对物品的态度。<br>  3. 因为需要基于用户以往的喜好历史做出推荐，所以对于新用户有“冷启动”的问题。</p><p> 虽然这个方法有很多不足和问题，但他还是成功的应用在一些电影，音乐，图书的社交站点，有些站点还请专业的人员对物品进行基因编码，比如潘多拉，在一份报告中说道，在潘多拉的推荐引擎中，每首歌有超过 100 个元数据特征，包括歌曲的风格，年份，演唱者等等。</p><h2 id="基于协同过滤的推荐"><a class="markdownIt-Anchor" href="#基于协同过滤的推荐"></a> 基于协同过滤的推荐</h2><p> 随着 Web2.0 的发展，Web站点更加提倡用户参与和用户贡献，因此基于协同过滤的推荐机制因运而生。它的原理很简单，就是根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，然后再基于这些关联性进行推荐。基于协同过滤的推荐可以分为三个子类：基于用户的推荐（User-based Recommendation），基于项目的推荐（Item-based Recommendation）和基于模型的推荐（Model-based Recommendation）。下面我们一个一个详细的介绍着三种协同过滤的推荐机制。</p><h3 id="基于用户的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于用户的协同过滤推荐"></a> 基于用户的协同过滤推荐</h3><p> 基于用户的协同过滤推荐的基本原理是，根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。</p><img src="/深入理解各种推荐机制原理/基于用户的协同过滤工作原理.png" title="基于用户的协同过滤工作原理"><p> 上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A，物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A ，物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。<br> 基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。</p><h3 id="基于项目的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于项目的协同过滤推荐"></a> 基于项目的协同过滤推荐</h3><p> 基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，然后根据用户的历史偏好信息，将类似的物品推荐给用户。</p><img src="/深入理解各种推荐机制原理/基于项目的协同过滤工作原理.png" title="基于项目的协同过滤工作原理"><p> 假设用户 A 喜欢物品 A 和物品 C，用户 B 喜欢物品 A，物品 B 和物品 C，用户 C 喜欢物品 A，从这些用户的历史喜好可以分析出物品 A 和物品 C 时比较类似的，喜欢物品 A 的人都喜欢物品 C，基于这个数据可以推断用户 C 很有可能也喜欢物品 C，所以系统会将物品 C 推荐给用户 C。<br> 与上面讲的类似，基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。<br> 同时协同过滤，在基于用户和基于项目两个策略中应该如何选择呢？其实基于项目的协同过滤推荐机制是 Amazon 在基于用户的机制上改良的一种策略，因为在大部分的 Web 站点中，物品的个数是远远小于用户的数量的，而且物品的个数和相似度相对比较稳定，同时基于项目的机制比基于用户的实时性更好一些。但也不是所有的场景都是这样的情况，可以设想一下在一些新闻推荐系统中，也许物品，也就是新闻的个数可能大于用户的个数，而且新闻的更新程度也有很快，所以它的形似度依然不稳定。所以，其实可以看出，推荐策略的选择其实和具体的应用场景有很大的关系。</p><h3 id="基于模型的协同过滤推荐"><a class="markdownIt-Anchor" href="#基于模型的协同过滤推荐"></a> 基于模型的协同过滤推荐</h3><p> 基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。<br> 基于协同过滤的推荐机制是现今应用最为广泛的推荐机制，它有以下几个显著的<strong>优点</strong>：<br>  1. 它不需要对物品或者用户进行严格的建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。<br>  2. 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好</p><p>存在的<strong>问题</strong>：</p><p>  1. 方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。<br>  2. 推荐的效果依赖于用户历史偏好数据的多少和准确性。<br>  3. 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。<br>  4. 对于一些特殊品味的用户不能给予很好的推荐。<br>  5. 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。</p><h2 id="混合的推荐机制"><a class="markdownIt-Anchor" href="#混合的推荐机制"></a> 混合的推荐机制</h2><p> 在现行的 Web 站点上的推荐往往都不是单纯只采用了某一种推荐的机制和策略，他们往往是将多个方法混合在一起，从而达到更好的推荐效果。关于如何组合各个推荐机制，这里讲几种比较流行的组合方法。</p><p>  <strong>（1）加权的混合（Weighted Hybridization）</strong>: 用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最 好的推荐效果。<br>  <strong>（2）切换的混合（Switching Hybridization）</strong>：前面也讲到，其实对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，那么切换的混合方式，就是允许在不同的情况下，选择最为合适的推荐机制计算推荐。<br>  <strong>（3）分区的混合（Mixed Hybridization）</strong>：采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户。其实，Amazon，当当网等很多电子商务网站都是采用这样的方式，用户可以得到很全面的推荐，也更容易找到他们想要的东西。<br>  <strong>（4）分层的混合（Meta-Level Hybridization）</strong>: 采用多种推荐机制，并将一个推荐机制的结果作为另一个的输入，从而综合各个推荐机制的优缺点，得到更加准确的推荐。</p><p><strong>转载</strong>：<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html?ca=drs-" rel="external nofollow noopener noreferrer" target="_blank">IBM Developer 推荐引擎初探</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell无法连接虚拟机的几个原因</title>
      <link href="/Xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%9B%A0.html"/>
      <url>/Xshell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%9B%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机没有设置相应ip地址"><a class="markdownIt-Anchor" href="#虚拟机没有设置相应ip地址"></a> 虚拟机没有设置相应IP地址</h2><p> 具体设置IP地址可参考： <a href="https://www.cnblogs.com/fuly550871915/p/4949513.html" title="桥接模式下设置IP地址" rel="external nofollow noopener noreferrer" target="_blank">桥接模式下设置IP地址</a></p><h2 id="ssh服务没有启动"><a class="markdownIt-Anchor" href="#ssh服务没有启动"></a> SSH服务没有启动</h2><blockquote><p>Secure Shell（缩写为 SSH），由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为一项创建在应用层和传输层基础上的安全协议，为计算机上的 Shell（壳层）提供安全的传输和使用环境。</p></blockquote><h3 id="查看ssh状态"><a class="markdownIt-Anchor" href="#查看ssh状态"></a> 查看SSH状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo service sshd status</span><br></pre></td></tr></table></figure><h3 id="安装ssh服务"><a class="markdownIt-Anchor" href="#安装ssh服务"></a> 安装SSH服务</h3><p> 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ sudo yum install sshd</span><br><span class="line">或者</span><br><span class="line"> $ sudo yum install openssh-server（由osc网友 火耳提供）</span><br></pre></td></tr></table></figure><p> 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ sudo apt-get install sshd</span><br><span class="line">或者</span><br><span class="line"> $ sudo apt-get install openssh-server（由osc网友 火耳提供）</span><br></pre></td></tr></table></figure><h3 id="开启ssh服务"><a class="markdownIt-Anchor" href="#开启ssh服务"></a> 开启SSH服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo service sshd start</span><br></pre></td></tr></table></figure><p> 执行完命令后，用第一步：查看ssh服务状态的命令，如果出现以下提示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active: active (running) since Sun 2013-04-07 13:43:11 CST; 15s ago</span><br></pre></td></tr></table></figure><h3 id="卸载ssh服务"><a class="markdownIt-Anchor" href="#卸载ssh服务"></a> 卸载SSH服务</h3><p> 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove sshd</span><br></pre></td></tr></table></figure><p> 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get –purge remove sshd</span><br></pre></td></tr></table></figure><h2 id="20端口被暂用"><a class="markdownIt-Anchor" href="#20端口被暂用"></a> 20端口被暂用</h2><h3 id="查看端口情况"><a class="markdownIt-Anchor" href="#查看端口情况"></a> 查看端口情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -anp|grep 80</span><br></pre></td></tr></table></figure><h3 id="打开端口号"><a class="markdownIt-Anchor" href="#打开端口号"></a> 打开端口号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT -ptcp --dport 端口号-j ACCEPT</span><br><span class="line">$ service iptables save   // 保存设置</span><br></pre></td></tr></table></figure><h2 id="防火墙未关闭"><a class="markdownIt-Anchor" href="#防火墙未关闭"></a> 防火墙未关闭</h2><h3 id="关闭虚拟机防火墙"><a class="markdownIt-Anchor" href="#关闭虚拟机防火墙"></a> 关闭虚拟机防火墙</h3><pre class="highlight"><code class>    永久性生效：       开启： $ chkconfig iptables on       关闭： $ chkconfig iptables off    即时生效，重启后失效：       开启： $ service iptables start       关闭： $ service iptables stop</code></pre><h3 id="关闭宿主机防火墙"><a class="markdownIt-Anchor" href="#关闭宿主机防火墙"></a> 关闭宿主机防火墙</h3><p> 没有必要因小失大去关闭整个防火墙，可设置相应的入栈和出栈规则即可。即入站规则和出站规则内的 “文件和打印共享（回显请求 – ICMPv4-In）”允许连接，在出站规则中为 “文件和打印共享（回显请求 – ICMPv4-Out）”允许连接。</p><hr><p> <strong>ps</strong>：我主要面临的问题是虚拟机可以ping通宿主机，宿主机无法ping通虚拟机，就是被防火墙问题困扰，关闭之后需要重启一下电脑便生效。</p>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
