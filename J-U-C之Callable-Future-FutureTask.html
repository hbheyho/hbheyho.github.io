<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="J.U.C之Callable, Future, FutureTask"><meta name="keywords" content="J.U.C"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>J.U.C之Callable, Future, FutureTask | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#callable接口"><span class="toc-number">2.</span> <span class="toc-text"> Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#future接口"><span class="toc-number">3.</span> <span class="toc-text"> Future接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#futuretask类"><span class="toc-number">4.</span> <span class="toc-text"> FutureTask类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">4.1.</span> <span class="toc-text"> 源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用实例"><span class="toc-number">5.</span> <span class="toc-text"> 使用实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">J.U.C之Callable, Future, FutureTask</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Concurrency/">Concurrency</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>创建线程通过有两者方式：一种是继承Thread，一种是实现Runnable接口。但是着两种方式都存在着一个不足，即执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果。<br>
自从Java1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h2 id="callable接口"><a class="markdownIt-Anchor" href="#callable接口"></a> Callable接口</h2>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，这个方法叫做call()。该接口还是一个泛型接口，返回的结果类型就为传过来的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    // 返回计算结果或者抛出一个错误</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Callable需要结合ExecutorService来使用，在ExecutorService接口中声明了若干个submit方法的重载版本。从下面的方法可以知道，Runnable任务也可以进行提交执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// task表示需要执行的任务</span><br><span class="line">// &lt;T&gt; 返回结果的类型</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<h2 id="future接口"><a class="markdownIt-Anchor" href="#future接口"></a> Future接口</h2>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果或者被取消。<br>
Future类位于java.util.concurrent包下，它是一个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">// 取消任务,参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务</span><br><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">// 任务是否取消</span><br><span class="line">boolean isCancelled();</span><br><span class="line">// 任务是否完成</span><br><span class="line">boolean isDone();</span><br><span class="line">// 这个方法会产生阻塞，会一直等到任务执行完毕才返回</span><br><span class="line">V get() throws InterruptedException, ExecutionException;</span><br><span class="line">// 获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span><br><span class="line">V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException</span><br></pre></td></tr></table></figure>
<p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p>
<ol>
<li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true；</li>
<li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true；</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。<br>
也就是说Future提供了三种功能：1. 判断任务是否完成；2. 能够中断任务；3. 能够获取任务执行结果。</li>
</ol>
<h2 id="futuretask类"><a class="markdownIt-Anchor" href="#futuretask类"></a> FutureTask类</h2>
<img src="/J-U-C之Callable-Future-FutureTask/extend.png" title="extend">
<p>上图中是FutureTack继承关系图，最上层的FuctionalInterface是一个注解，标识了拥有该注解的接口支持函数式编程。FutureTask类实现了RunnableFuture接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p>我们看一下RunnableFuture接口的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>
事实上，FutureTask是Future接口的一个唯一实现类。</p>
<p>下面对FutureTask的源码进行具体分析：</p>
<h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3>
<ol>
<li>
<p>属性</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 状态机：存在以下7中状态</span><br><span class="line">private volatile int state;</span><br><span class="line">// 任务新建</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">// 任务完成中</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">// 任务正常完成</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">// 任务异常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">// 任务取消</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">// 任务中断中</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">// 任务已中断</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br><span class="line"></span><br><span class="line">// 可能状态转换：</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">// NEW -&gt; CANCELLED</span><br><span class="line">// NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"></span><br><span class="line">// 支持结果返回的任务</span><br><span class="line">private Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">// 任务执行结果：包含正常和异常的结果，通过get方法获取</span><br><span class="line">private Object outcome; </span><br><span class="line"></span><br><span class="line">// 任务执行线程</span><br><span class="line">private volatile Thread runner;</span><br><span class="line"></span><br><span class="line">// 栈结构的等待队列，该节点是栈中的最顶层节点</span><br><span class="line">private volatile WaitNode waiters;</span><br></pre></td></tr></table></figure>
<p>上述的WaitNode 结构定义如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用一个简单的链表节点来记录等待结果的线程 </span><br><span class="line">// 链表的具体实现为 Treiber Stack</span><br><span class="line">// 注: Treiber Stack 为一个无锁并发栈, 这意味着先进来的等待线程</span><br><span class="line">// 会最后获得结果.</span><br><span class="line">// Treiber Stack 实现思路为CAS+不断重试. </span><br><span class="line">// 参考：https://www.cnblogs.com/micrari/p/7719408.html</span><br><span class="line">static final class WaitNode &#123;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    volatile WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造器</p>
<p>FutureTask提供了2个构造器：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接传入callable任务</span><br><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    // 初始状态为NEW</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入runnable任务及结果变量</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">        // 将Runnable 任务转换为Callable任务</span><br><span class="line">        this.callable = Executors.callable(runnable, result);</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask提供了两个构造方法，支持runnable和callable两种任务，但其实最终都是转换为callable任务。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 利用适配器模式进行转换</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunnableAdapter实现了Callable接口, 以实现适配器模式</span><br><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runnable转为callable的方法,其实就是通过RunnableAdapter适配器，RunnableAdapter本身是实现了callable接口，然后在call方法中，实际执行的是runnable的run方法，另外将传入的结果参数原封不动的作为结果返回。</p>
</li>
<li>
<p>run方法<br>
run方法是FutureTask任务实际执行体，它主要完成包装的callable的call方法执行，并将执行结果保存到outcome中，同时捕获了call方法执行出现的异常，并保存异常信息，而不是直接抛出。另外，run方法存在的另一个意义就是通过它对状态机进行了维护，比如NEW-COMPLETEING-NORMAL 或 NEW-COMPLETEING-EXCEPTIONAL，保证了任务的处理流程。run方法一开始通过CAS更新runner为当前线程，从而避免了多线程下run被执行多次的调用，若runner线程不为null，则CAS失败。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    // 状态机不为NEW表示执行完成或任务被取消了，直接返回</span><br><span class="line">    // 状态机为NEW,同时将runner设置为当前线程，保证同一时刻只有一个线程执行run方法，如果设置失败也直接返回</span><br><span class="line">    // 只有runnner 为null时才会进行设置</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">    !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        // 取出任务检测不为空 且 再次检查状态为NEW</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行任务</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                // 任务执行抛出异常时，保存异常信息，而不直接抛出</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                // 执行成功则保存结果</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 在此之前执行器必须不能null,</span><br><span class="line">        // 与上面的CAS配合以此避免多线程并发调用run()的情况</span><br><span class="line">        runner = null;</span><br><span class="line">        // 任务取消之后必须重新获取state的状态，防止错过处理中断请求</span><br><span class="line">        int s = state;</span><br><span class="line">        // 如果被置为了中断状态则进行中断的处理</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">        handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>get方法<br>
get方法有两种，分别是一直阻塞和超时阻塞获取；get方法本意是直接获取任务执行结果，但是任务没执行完成时，会将当前线程进行阻塞等待，直到任务执行完成时才会唤醒。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 阻塞获取</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    // 任务非最终完成状态前通过awaitDone方法进行阻塞等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 超时阻塞获取</span><br><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    if (unit == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int s = state;</span><br><span class="line">    // 阻塞获取并达到阻塞超时时间后抛出超时异常</span><br><span class="line">    if (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">    (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        throw new TimeoutException();</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>awaitDone方法<br>
调用awaitDone方法将请求线程进行阻塞。请求线程阻塞时，会创建一个waiter节点，然后加入到阻塞等待的栈中。当任务执行完成时或设置了阻塞超时时间的线程超时时，会将该线程从阻塞栈中移除，移除的方法很复杂，充分考虑了多线程并发的情况。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 线程阻塞等待方法</span><br><span class="line">private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123;</span><br><span class="line">    // 若timed 为true,则计算阻塞超时时间</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    // 默认不阻塞</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 如果阻塞线程被中断则将当前线程从阻塞队列中移除</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt; COMPLETING) &#123; </span><br><span class="line">            // 任务已经完成时直接返回结果</span><br><span class="line">            if (q != null)</span><br><span class="line">                q.thread = null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s == COMPLETING) </span><br><span class="line">            //如果任务执行完成，但还差最后一步最终完成，则让出CPU给任务执行线程继续执行</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (q == null)</span><br><span class="line">            // 新进来的线程添加等待节点</span><br><span class="line">            q = new WaitNode();</span><br><span class="line">        else if (!queued)</span><br><span class="line">            // 上一步节点创建完，还没将其添加到waiters栈中,</span><br><span class="line">            // 因此在下一个循环就会执行此处进行入栈操作，并将当前线程的等待节点置于栈顶</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q);</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            // 如果设置了阻塞超时时间，则进行检查是否达到阻塞超时时间，</span><br><span class="line">            // 达到了则删除当前线程的等待节点并退出循环返回，否则继续阻塞</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            // 阻塞线程</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;else</span><br><span class="line">            // 非超时阻塞</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>report方法<br>
report方法会根据任务状返回结果。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取任务结果方法：正常执行则直接返回结果，否则抛出异常</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>cancel方法<br>
任务取消时会先检查是否允许取消，当任务已经完成或者正在完成（正常执行并继续处理结果 或 执行异常处理异常结果）时不允许取消。<br>
cancel方法有个boolean入参，若为false，则只唤醒所有等待的线程，不中断正在执行的任务线程。若为true则直接中断任务执行线程，同时修改状态机为INTERRUPTED。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    // 不允许取消的情况：状态机不是NEW 或CAS更新状态机失败</span><br><span class="line">    if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        return false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果要求中断执行中的任务，则直接中断任务执行线程，并更新状态机为最终状态INTERRUPTED</span><br><span class="line">        if (mayInterruptIfRunning) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                if (t != null)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; finally &#123; </span><br><span class="line">                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 移除和唤醒所有线程, 并调用done方法,并设置cableable为null</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其他方法<br>
setException方法主要用于任务执行异常对处理，主要完成异常信息保存到outcom结果、状态机从NEW到EXCEPTIONAL的变化更新，以及唤醒阻塞在waiters队列中请求get的所有线程。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 任务执行异常处理</span><br><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    // 将状态机由NEW更新为COMPLETING</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        // 将异常信息保存到输出结果中</span><br><span class="line">        outcome = t;</span><br><span class="line">        // 更新状态机为处理异常的最终状态-EXCEPTIONAL</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">        // 通用的完成操作，主要作用就是唤醒阻塞在waiters队列中请求get的线程</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set方法任务正常处理和异常处理流程基本一样，不一样的是状态的变化为NEW-COMPLETEING-NORMAL。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handlePossibleCancellationInterrupt()方法处理可能的取消中断，其实它的作用就是—当发起中断的线程A将状态机更新为INTERRUPTING，还没继续中断任务线程前，CPU切换到任务执行线程B了，此时线程B执行本方法让出CPU，让发起中断的线程A能继续处理中断B的操作。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void handlePossibleCancellationInterrupt(int s) &#123;</span><br><span class="line">if (s == INTERRUPTING)</span><br><span class="line">    while (state == INTERRUPTING)</span><br><span class="line">        Thread.yield(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeWaiter方法主要的功能就是移除等待节点，当线程被中断或超时时会调用该方法来移除等待节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void removeWaiter(WaitNode node) &#123;</span><br><span class="line">    if (node != null) &#123;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        retry:</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                for (WaitNode pred = null, q = waiters, s; q != null; q = s) &#123;</span><br><span class="line">                    s = q.next;</span><br><span class="line">                    if (q.thread != null)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    else if (pred != null) &#123;</span><br><span class="line">                        red.next = s;</span><br><span class="line">                    if (pred.thread == null) </span><br><span class="line">                        continue retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s))</span><br><span class="line">                        continue retry;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishCompletion方法会移除和唤醒所有等待线程，并调用done方法，并将callable设置为null。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 移除和唤醒所有等待线程, 并调用done方法, 并将callable设置为null</span><br><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    // assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    q.thread = null;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next = null; // unlink to help gc</span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">    callable = null;        // to reduce footprint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2>
<ol>
<li>
<p>使用Callable + Future获取执行结果</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureExample &#123;</span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        // Future 对执行结果进行操作, submit方法底层也会将task包装成一个FutureTask对象</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(task);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2. 使用Callable + FutureTask获取执行结果</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 方式一</span><br><span class="line">        /*ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        executorService.shutdown();*/</span><br><span class="line"></span><br><span class="line">        //  方式二</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        // 因为futureTask实现了RunnableFuture接口, 而</span><br><span class="line">        RunnableFuture接口继承了Runnable</span><br><span class="line">        Thread thread = new Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>FutureTask实现了Runnable接口，因此可以作为一个线程执行任务处理，比如在线程池中submit方法就是用FutureTask类包装了一个runnable或callable任务；</li>
<li>FutureTask内部有个状态机，用于记录任务的处理状态，比如有三种最终状态：正常完成、执行异常、任务取消；</li>
<li>通过get方法阻塞获取任务执行结果，同时内部维护了一个阻塞等待栈，用于多线程并发调用get方法时，同时将这些线程阻塞并保存它们的阻塞信息，以便在任务执行完成后进行唤醒；</li>
<li>支持任务的取消操作，但是前提是任务还没完全执行成功的情况下才允许取消，取消分为两种：只唤醒阻塞等待结果的线程、唤醒线程同时强制中断任务执行线程。</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3949310.html</a><br>
[2] <a href="https://juejin.im/post/6844904181824749582" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/6844904181824749582</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/J-U-C之Callable-Future-FutureTask.html">http://www.huangbin.fun/J-U-C之Callable-Future-FutureTask.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J-U-C/">J.U.C</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/J-U-C-之阻塞队列.html"><i class="fa fa-chevron-left">  </i><span>J.U.C 之阻塞队列</span></a></div><div class="next-post pull-right"><a href="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析.html"><span>J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>