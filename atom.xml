<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HB&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangbin.fun/"/>
  <updated>2020-11-29T13:28:06.737Z</updated>
  <id>http://www.huangbin.fun/</id>
  
  <author>
    <name>HB</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J.U.C 之阻塞队列</title>
    <link href="http://www.huangbin.fun/J-U-C-%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html"/>
    <id>http://www.huangbin.fun/J-U-C-之阻塞队列.html</id>
    <published>2020-07-02T13:10:05.000Z</published>
    <updated>2020-11-29T13:28:06.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>在编程中接触的队列更多的为非阻塞队列，例如PriorityQueue，LinkedList。这些队列不会对当前线程进行阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略（例如使用Object::wait，Object::notify来实现线程阻塞）。阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p><h2 id="常用阻塞队列"><a class="markdownIt-Anchor" href="#常用阻塞队列"></a> 常用阻塞队列</h2><ol><li>ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列；</li><li>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE；</li><li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列；</li><li>DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li></ol><h2 id="阻塞队列方法"><a class="markdownIt-Anchor" href="#阻塞队列方法"></a> 阻塞队列方法</h2><h3 id="非阻塞队列方法"><a class="markdownIt-Anchor" href="#非阻塞队列方法"></a> 非阻塞队列方法</h3><ol><li>add(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</li><li>remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</li><li>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</li><li>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</li><li>peek()：获取队首元素，若成功，则返回队首元素；否则返回null。</li></ol><p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。<br>上述5个方法都没有采用同步策略。</p><h3 id="阻塞队列方法-2"><a class="markdownIt-Anchor" href="#阻塞队列方法-2"></a> 阻塞队列方法</h3><p>阻塞队列中也提供了add(E e)，remove()，offer(E e)，poll()，peek()方法，不同的是，阻塞队列对上述方法都采用了同步策略。</p><ol><li>put(E e)：put方法用来向队尾存入元素，如果队列满，则等待；</li><li>take()：take方法用来从队首取元素，如果队列为空，则等待；</li><li>offer(E e,long timeout, TimeUnit unit)：offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</li><li>poll(long timeout, TimeUnit unit)：poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素。</li></ol><h2 id="阻塞队列源码分析"><a class="markdownIt-Anchor" href="#阻塞队列源码分析"></a> 阻塞队列源码分析</h2><p>以ArrayBlockingQueue为例分析具体实现原理，基于JDK 8。</p><h3 id="主要变量"><a class="markdownIt-Anchor" href="#主要变量"></a> 主要变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现了BlockingQueue接口, 继承了AbstractQueue类</span><br><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    private static final long serialVersionUID = -817911632652898426L;</span><br><span class="line"></span><br><span class="line">    // 使用一个数组来存储队列中的元素</span><br><span class="line">    private final E[] items;</span><br><span class="line">    // 队列头指针, take, poll, remove方法使用</span><br><span class="line">    private int takeIndex;</span><br><span class="line">    // 队列尾指针, put, offer, add方法使用</span><br><span class="line">    private int putIndex;</span><br><span class="line">    // 队列中元素个数</span><br><span class="line">    private int count;</span><br><span class="line">     </span><br><span class="line">    // 可重入锁来控制所有的访问</span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    // 等待获取元素的条件变量</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    // 等待放置元素的条件变量</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// capacity参数指定容量</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量以及公平性</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量, 公平性以及初始化集合</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                                                  Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a class="markdownIt-Anchor" href="#put方法"></a> put方法</h3><p>put方法用来向队尾存入元素，如果队列满，则等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    // 判断传入元素是否为空</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    // 获得可一个重入锁, 保证线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">    // 若阻塞队列已满, 则将线程加入到同步队列中</span><br><span class="line">    while (count == items.length)</span><br><span class="line">        // 阻塞当前线程,将其加入到同步队列</span><br><span class="line">        notFull.await();</span><br><span class="line">        // 进行入队操作</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enqueue方法"><a class="markdownIt-Anchor" href="#enqueue方法"></a> enqueue方法</h3><p>enqueue方法完成具体的入队操作，并且唤醒等待获取元素的线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    // 元素入队</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 入队之后队列已满</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    // 队列元素 + 1</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒等待获取元素的线程</span><br><span class="line">    // 从等待队列中移除, 移到AQS同步队列中, 等待获取锁</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take方法"><a class="markdownIt-Anchor" href="#take方法"></a> take方法</h3><p>take方法用来从队首取元素，如果队列为空，则等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    // 获取可重入锁, 支持中断</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 若阻塞队列为空, 则将线程加入到同步队列中</span><br><span class="line">        // 等待获取资源</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        // 进行出队操作</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dequeue方法"><a class="markdownIt-Anchor" href="#dequeue方法"></a> dequeue方法</h3><p>dequeue方法完成具体的出队操作，并且唤醒等待入队元素的线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 获取队列中元素</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    // 获取之后元素置为null</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 出队之后队列为空</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">    t   akeIndex = 0;</span><br><span class="line">    // 队列元素 - 1</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒等待放置元素的线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2><p>使用Object::wait和Object::notify方法实现生产者-消费者模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line">     </span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用阻塞队列实现生产者-消费者模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">// 缓存区</span><br><span class="line">private ArrayBlockingQueue&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line"></span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new ArrayBlockingQueue&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        try&#123;</span><br><span class="line">            buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        String str = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            str = buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3932906.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3932906.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;在编程中接触的队列更多的为非阻塞队列，例如PriorityQueue，LinkedList。这些队列不会对当前线程进行阻塞，那么在面对类似消费者
      
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.huangbin.fun/categories/Concurrency/"/>
    
    
      <category term="J.U.C" scheme="http://www.huangbin.fun/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之Callable, Future, FutureTask</title>
    <link href="http://www.huangbin.fun/J-U-C%E4%B9%8BCallable-Future-FutureTask.html"/>
    <id>http://www.huangbin.fun/J-U-C之Callable-Future-FutureTask.html</id>
    <published>2020-06-26T06:07:00.000Z</published>
    <updated>2020-11-26T11:55:53.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>创建线程通过有两者方式：一种是继承Thread，一种是实现Runnable接口。但是着两种方式都存在着一个不足，即执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果。<br>自从Java1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><h2 id="callable接口"><a class="markdownIt-Anchor" href="#callable接口"></a> Callable接口</h2><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，这个方法叫做call()。该接口还是一个泛型接口，返回的结果类型就为传过来的类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    // 返回计算结果或者抛出一个错误</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable需要结合ExecutorService来使用，在ExecutorService接口中声明了若干个submit方法的重载版本。从下面的方法可以知道，Runnable任务也可以进行提交执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// task表示需要执行的任务</span><br><span class="line">// &lt;T&gt; 返回结果的类型</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><h2 id="future接口"><a class="markdownIt-Anchor" href="#future接口"></a> Future接口</h2><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果或者被取消。<br>Future类位于java.util.concurrent包下，它是一个接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">// 取消任务,参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务</span><br><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">// 任务是否取消</span><br><span class="line">boolean isCancelled();</span><br><span class="line">// 任务是否完成</span><br><span class="line">boolean isDone();</span><br><span class="line">// 这个方法会产生阻塞，会一直等到任务执行完毕才返回</span><br><span class="line">V get() throws InterruptedException, ExecutionException;</span><br><span class="line">// 获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span><br><span class="line">V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ol><li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true；</li><li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true；</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。<br>也就是说Future提供了三种功能：1. 判断任务是否完成；2. 能够中断任务；3. 能够获取任务执行结果。</li></ol><h2 id="futuretask类"><a class="markdownIt-Anchor" href="#futuretask类"></a> FutureTask类</h2><img src="/J-U-C之Callable-Future-FutureTask/extend.png" title="extend"><p>上图中是FutureTack继承关系图，最上层的FuctionalInterface是一个注解，标识了拥有该注解的接口支持函数式编程。FutureTask类实现了RunnableFuture接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure><p>我们看一下RunnableFuture接口的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>事实上，FutureTask是Future接口的一个唯一实现类。</p><p>下面对FutureTask的源码进行具体分析：</p><h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3><ol><li><p>属性</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 状态机：存在以下7中状态</span><br><span class="line">private volatile int state;</span><br><span class="line">// 任务新建</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">// 任务完成中</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">// 任务正常完成</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">// 任务异常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">// 任务取消</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">// 任务中断中</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">// 任务已中断</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br><span class="line"></span><br><span class="line">// 可能状态转换：</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">// NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">// NEW -&gt; CANCELLED</span><br><span class="line">// NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"></span><br><span class="line">// 支持结果返回的任务</span><br><span class="line">private Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">// 任务执行结果：包含正常和异常的结果，通过get方法获取</span><br><span class="line">private Object outcome; </span><br><span class="line"></span><br><span class="line">// 任务执行线程</span><br><span class="line">private volatile Thread runner;</span><br><span class="line"></span><br><span class="line">// 栈结构的等待队列，该节点是栈中的最顶层节点</span><br><span class="line">private volatile WaitNode waiters;</span><br></pre></td></tr></table></figure><p>上述的WaitNode 结构定义如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用一个简单的链表节点来记录等待结果的线程 </span><br><span class="line">// 链表的具体实现为 Treiber Stack</span><br><span class="line">// 注: Treiber Stack 为一个无锁并发栈, 这意味着先进来的等待线程</span><br><span class="line">// 会最后获得结果.</span><br><span class="line">// Treiber Stack 实现思路为CAS+不断重试. </span><br><span class="line">// 参考：https://www.cnblogs.com/micrari/p/7719408.html</span><br><span class="line">static final class WaitNode &#123;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    volatile WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器</p><p>FutureTask提供了2个构造器：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接传入callable任务</span><br><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    // 初始状态为NEW</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入runnable任务及结果变量</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">        // 将Runnable 任务转换为Callable任务</span><br><span class="line">        this.callable = Executors.callable(runnable, result);</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask提供了两个构造方法，支持runnable和callable两种任务，但其实最终都是转换为callable任务。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 利用适配器模式进行转换</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunnableAdapter实现了Callable接口, 以实现适配器模式</span><br><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runnable转为callable的方法,其实就是通过RunnableAdapter适配器，RunnableAdapter本身是实现了callable接口，然后在call方法中，实际执行的是runnable的run方法，另外将传入的结果参数原封不动的作为结果返回。</p></li><li><p>run方法<br>run方法是FutureTask任务实际执行体，它主要完成包装的callable的call方法执行，并将执行结果保存到outcome中，同时捕获了call方法执行出现的异常，并保存异常信息，而不是直接抛出。另外，run方法存在的另一个意义就是通过它对状态机进行了维护，比如NEW-COMPLETEING-NORMAL 或 NEW-COMPLETEING-EXCEPTIONAL，保证了任务的处理流程。run方法一开始通过CAS更新runner为当前线程，从而避免了多线程下run被执行多次的调用，若runner线程不为null，则CAS失败。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    // 状态机不为NEW表示执行完成或任务被取消了，直接返回</span><br><span class="line">    // 状态机为NEW,同时将runner设置为当前线程，保证同一时刻只有一个线程执行run方法，如果设置失败也直接返回</span><br><span class="line">    // 只有runnner 为null时才会进行设置</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">    !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        // 取出任务检测不为空 且 再次检查状态为NEW</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行任务</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                // 任务执行抛出异常时，保存异常信息，而不直接抛出</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                // 执行成功则保存结果</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 在此之前执行器必须不能null,</span><br><span class="line">        // 与上面的CAS配合以此避免多线程并发调用run()的情况</span><br><span class="line">        runner = null;</span><br><span class="line">        // 任务取消之后必须重新获取state的状态，防止错过处理中断请求</span><br><span class="line">        int s = state;</span><br><span class="line">        // 如果被置为了中断状态则进行中断的处理</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">        handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get方法<br>get方法有两种，分别是一直阻塞和超时阻塞获取；get方法本意是直接获取任务执行结果，但是任务没执行完成时，会将当前线程进行阻塞等待，直到任务执行完成时才会唤醒。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 阻塞获取</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    // 任务非最终完成状态前通过awaitDone方法进行阻塞等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 超时阻塞获取</span><br><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    if (unit == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int s = state;</span><br><span class="line">    // 阻塞获取并达到阻塞超时时间后抛出超时异常</span><br><span class="line">    if (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">    (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        throw new TimeoutException();</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>awaitDone方法<br>调用awaitDone方法将请求线程进行阻塞。请求线程阻塞时，会创建一个waiter节点，然后加入到阻塞等待的栈中。当任务执行完成时或设置了阻塞超时时间的线程超时时，会将该线程从阻塞栈中移除，移除的方法很复杂，充分考虑了多线程并发的情况。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 线程阻塞等待方法</span><br><span class="line">private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123;</span><br><span class="line">    // 若timed 为true,则计算阻塞超时时间</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    // 默认不阻塞</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 如果阻塞线程被中断则将当前线程从阻塞队列中移除</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt; COMPLETING) &#123; </span><br><span class="line">            // 任务已经完成时直接返回结果</span><br><span class="line">            if (q != null)</span><br><span class="line">                q.thread = null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s == COMPLETING) </span><br><span class="line">            //如果任务执行完成，但还差最后一步最终完成，则让出CPU给任务执行线程继续执行</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (q == null)</span><br><span class="line">            // 新进来的线程添加等待节点</span><br><span class="line">            q = new WaitNode();</span><br><span class="line">        else if (!queued)</span><br><span class="line">            // 上一步节点创建完，还没将其添加到waiters栈中,</span><br><span class="line">            // 因此在下一个循环就会执行此处进行入栈操作，并将当前线程的等待节点置于栈顶</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q);</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            // 如果设置了阻塞超时时间，则进行检查是否达到阻塞超时时间，</span><br><span class="line">            // 达到了则删除当前线程的等待节点并退出循环返回，否则继续阻塞</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            // 阻塞线程</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;else</span><br><span class="line">            // 非超时阻塞</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>report方法<br>report方法会根据任务状返回结果。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取任务结果方法：正常执行则直接返回结果，否则抛出异常</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cancel方法<br>任务取消时会先检查是否允许取消，当任务已经完成或者正在完成（正常执行并继续处理结果 或 执行异常处理异常结果）时不允许取消。<br>cancel方法有个boolean入参，若为false，则只唤醒所有等待的线程，不中断正在执行的任务线程。若为true则直接中断任务执行线程，同时修改状态机为INTERRUPTED。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    // 不允许取消的情况：状态机不是NEW 或CAS更新状态机失败</span><br><span class="line">    if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        return false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果要求中断执行中的任务，则直接中断任务执行线程，并更新状态机为最终状态INTERRUPTED</span><br><span class="line">        if (mayInterruptIfRunning) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                if (t != null)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; finally &#123; </span><br><span class="line">                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 移除和唤醒所有线程, 并调用done方法,并设置cableable为null</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他方法<br>setException方法主要用于任务执行异常对处理，主要完成异常信息保存到outcom结果、状态机从NEW到EXCEPTIONAL的变化更新，以及唤醒阻塞在waiters队列中请求get的所有线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 任务执行异常处理</span><br><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    // 将状态机由NEW更新为COMPLETING</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        // 将异常信息保存到输出结果中</span><br><span class="line">        outcome = t;</span><br><span class="line">        // 更新状态机为处理异常的最终状态-EXCEPTIONAL</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">        // 通用的完成操作，主要作用就是唤醒阻塞在waiters队列中请求get的线程</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法任务正常处理和异常处理流程基本一样，不一样的是状态的变化为NEW-COMPLETEING-NORMAL。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePossibleCancellationInterrupt()方法处理可能的取消中断，其实它的作用就是—当发起中断的线程A将状态机更新为INTERRUPTING，还没继续中断任务线程前，CPU切换到任务执行线程B了，此时线程B执行本方法让出CPU，让发起中断的线程A能继续处理中断B的操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void handlePossibleCancellationInterrupt(int s) &#123;</span><br><span class="line">if (s == INTERRUPTING)</span><br><span class="line">    while (state == INTERRUPTING)</span><br><span class="line">        Thread.yield(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeWaiter方法主要的功能就是移除等待节点，当线程被中断或超时时会调用该方法来移除等待节点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void removeWaiter(WaitNode node) &#123;</span><br><span class="line">    if (node != null) &#123;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        retry:</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                for (WaitNode pred = null, q = waiters, s; q != null; q = s) &#123;</span><br><span class="line">                    s = q.next;</span><br><span class="line">                    if (q.thread != null)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    else if (pred != null) &#123;</span><br><span class="line">                        red.next = s;</span><br><span class="line">                    if (pred.thread == null) </span><br><span class="line">                        continue retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s))</span><br><span class="line">                        continue retry;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finishCompletion方法会移除和唤醒所有等待线程，并调用done方法，并将callable设置为null。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 移除和唤醒所有等待线程, 并调用done方法, 并将callable设置为null</span><br><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    // assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    q.thread = null;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next = null; // unlink to help gc</span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">    callable = null;        // to reduce footprint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2><ol><li><p>使用Callable + Future获取执行结果</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureExample &#123;</span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        // Future 对执行结果进行操作, submit方法底层也会将task包装成一个FutureTask对象</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(task);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2. 使用Callable + FutureTask获取执行结果</p><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    // 利用callable创建任务</span><br><span class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子线程正在进行计算&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 方式一</span><br><span class="line">        /*ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        executorService.shutdown();*/</span><br><span class="line"></span><br><span class="line">        //  方式二</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        // 因为futureTask实现了RunnableFuture接口, 而</span><br><span class="line">        RunnableFuture接口继承了Runnable</span><br><span class="line">        Thread thread = new Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程正在执行任务&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Task 运行结果&quot; + futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;主线程执行任务完毕&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>FutureTask实现了Runnable接口，因此可以作为一个线程执行任务处理，比如在线程池中submit方法就是用FutureTask类包装了一个runnable或callable任务；</li><li>FutureTask内部有个状态机，用于记录任务的处理状态，比如有三种最终状态：正常完成、执行异常、任务取消；</li><li>通过get方法阻塞获取任务执行结果，同时内部维护了一个阻塞等待栈，用于多线程并发调用get方法时，同时将这些线程阻塞并保存它们的阻塞信息，以便在任务执行完成后进行唤醒；</li><li>支持任务的取消操作，但是前提是任务还没完全执行成功的情况下才允许取消，取消分为两种：只唤醒阻塞等待结果的线程、唤醒线程同时强制中断任务执行线程。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3949310.html</a><br>[2] <a href="https://juejin.im/post/6844904181824749582" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/6844904181824749582</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;创建线程通过有两者方式：一种是继承Thread，一种是实现Runnable接口。但是着两种方式都存在着一个不足，即执行完任务之后无法获取执行结果
      
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.huangbin.fun/categories/Concurrency/"/>
    
    
      <category term="J.U.C" scheme="http://www.huangbin.fun/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之常用同步器(ReentrantLock, CountDownLatch, Semaphore, CyclicBarrier, Condition)源码分析</title>
    <link href="http://www.huangbin.fun/J-U-C%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%90%8C%E6%AD%A5%E5%99%A8-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://www.huangbin.fun/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析.html</id>
    <published>2020-06-15T13:58:25.000Z</published>
    <updated>2020-11-26T06:03:33.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用同步器"><a class="markdownIt-Anchor" href="#常用同步器"></a> 常用同步器</h2><p>J.U.C中许多常用同步器都是基于AQS实现，主要有以下：CountDownLatch，Semaphore，CyclicBarrier，ReentrantLock，Condition。<br>下面对上述同步器进行源码分析, 源码分析下基于JDK 8。</p><h2 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>ReentrantLock是在JDK 1.5 引入的一个显示锁，可以实现多线程的互斥访问，可以实现和synchronized关键字同样的功能。ReentrantLock只支持独占方式的获取操作，是对lock接口的实现。<br>ReentrantLock将同步状态用于保存锁获取操作的次数（0 - 锁可被获取；整数i - 锁已被其他线程获取，因为ReentrantLock可重入，所以状态为整数i(i &gt;= 1)），并且还维护了一个owner变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。并且在tryRelease中检查owner域，从而确保当前线程在执行unlock操作之前已经获取了锁；在tryAcquire中使用这个域来区分获取操作是重入的还是竞争的。</p><h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3><p>下面的源码分析都是基于非公平的ReentrantLock实现。</p><h4 id="获取锁操作"><a class="markdownIt-Anchor" href="#获取锁操作"></a> 获取锁操作</h4><ol><li><p>lock()<br>ReentrantLock对外提供lock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的获取操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquire(int arg)<br>lock会调用acquire方法完成获取操作。若tryAcquire方法返回true，即成功获取到锁，就直接返回，线程继续往下运行；若获取失败则调用acquireQueud方法阻塞当前线程，等待锁的释放。<br>tryAcquire方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算获取锁成功。<br>阻塞一个线程由acquireQueued来实现。关于如何阻塞一个线程和如何唤醒线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquire(int arg)<br>ReentrantLock 实现 tryAcquire方法来获取资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 得到当前资源状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 当前同步状态 == 0, 表示锁未被获取</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 获取锁, 原子性修改同步状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置为独占模式的线程, 即owner状态</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若是重复获取, 即重入获取, 则修改同步状态为c+acquires</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="释放锁操作"><a class="markdownIt-Anchor" href="#释放锁操作"></a> 释放锁操作</h4><ol><li><p>unlock()<br>ReentrantLock对外提供unlock方法给用户调用，用户不需要知道ReentrantLock的具体实现细节就可完成锁的释放操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>release(int arg)<br>unlock方法会调用tryRelease方法去释放锁。若释放锁成功，则代表下一个等待锁的线程可以来获取锁，此时调用用unparkSuccesor方法唤醒；若释放锁失败，则直接返回。<br>tryRelease方法交由ReentrantLock来实现，它自己来实现判断逻辑 - 何时才算释放锁成功。<br>关于如何唤醒下一个线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // tryRelease(arg)返回true, 则表示释放锁成功, </span><br><span class="line">    // 可以去唤醒下一个等待线程了</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        // 唤醒下一个等待线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryRelease(int releases)<br>ReentrantLock 实现 tryRelease方法来释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 当前线程不是获取锁的线程, 抛出错误</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 若c == 0, 当前锁没有进行重入</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置锁状态, 因为是可重入的, 可能需要多次释放操作</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="应用实例"><a class="markdownIt-Anchor" href="#应用实例"></a> 应用实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();    </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void insert(Thread thread) &#123;</span><br><span class="line">        // 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><ol><li>公平锁与非公平锁：<br>公平锁尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁；<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</li><li>ReentrantLock 与 synchronized对比<ol><li>ReentrantLock 是对lock接口的实现，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而ReentrantLock 在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用ReentrantLock 时需要在finally块中释放锁；</li><li>ReentrantLock 可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过ReentrantLock 可以知道有没有成功获取锁，而synchronized却无法办到； ReentrantLock 可以提高多个线程进行读操作的效率；</li><li>可以通过 ReentrantLock lock = new ReentrantLock(true) 来实现公平锁。</li></ol></li></ol><h2 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h2><h3 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h3><p>JUC提供了Lock可以方便的进行锁操作，但是有时候我们也需要对线程进行条件性的阻塞和唤醒，以此来模拟线程间的相互协助，这时我们就需要condition条件变量，它就像是在线程上加了多个开关，可以方便的对持有锁的线程进行阻塞和唤醒。<br>官方解释如下：</p><blockquote><p>条件（也称为条件队列或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其&quot;等待&quot;）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式释放相关的锁，并挂起当前线程，就像Object.wait 做的那样</p></blockquote><p>Condition主要是为了在J.U.C框架中提供和Java传统的监视器风格的wait，notify和notifyAll方法类似的功能。wait，notify等需要和synchronized结合适用，Condition则绑定在一个锁（Lock）上，一般作Lock的内部实现。<br>两者的主要区别见下图：</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/compare.png" title="compare"><h3 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h3><h4 id="condition-interface"><a class="markdownIt-Anchor" href="#condition-interface"></a> Condition interface</h4><p>Condition接口提供了如下方法以供实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*============阻塞=============*/</span><br><span class="line">// 当前线程在接到信号或被中断之前一直处于等待状态.=</span><br><span class="line">void await() throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号之前一直处于等待状态 [注意：该方法对中断不敏感]</span><br><span class="line">void awaitUninterruptibly(); </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">// 返回值表示剩余时间, 如果在&apos;nanosTimeout&apos;之前唤醒,那么返回值 </span><br><span class="line">=&apos;nanosTimeout - 消耗时间&apos;,</span><br><span class="line">// 如果返回值&apos;&lt;= 0&apos; ,则可以认定它已经超时了</span><br><span class="line">long awaitNanos(long nanosTimeout) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">boolean await(long time, TimeUnit unit) throws InterruptedException; </span><br><span class="line">// 当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span><br><span class="line">// 如果没有到指定时间就被通知, 则返回 true ,否则表示到了指定时间,返回返回 false</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException; </span><br><span class="line"></span><br><span class="line">/*===========唤醒==============*/</span><br><span class="line">// 唤醒一个等待线程, 将线程从条件队列移到AQS同步队列中</span><br><span class="line">// 该线程从等待方法返回前必须获得与Condition相关的锁</span><br><span class="line">void signal(); </span><br><span class="line">// 唤醒所有等待线程, 将所有等待线程从条件队列中移到AQS步队列中</span><br><span class="line">void signalAll();</span><br></pre></td></tr></table></figure><p>Condition接口仅有一个实现类为ConditionObject，该类定义为AQS的内部类。</p><h4 id="线程挂起操作"><a class="markdownIt-Anchor" href="#线程挂起操作"></a> 线程挂起操作</h4><ol><li><p>await()<br>线程在调用await方法后将执行挂起操作，即新建 Condition 节点加入到 Condition 的队列尾部，并阻塞当前线程在条件队列中，直到线程等待的某个条件为真时才会被唤醒。在当前线程持有锁的基础上释放锁资源，以便其他线程获取锁资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    // 线程被中断,则抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 将节点加入到条件队列(Condition Queue)中</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放当前线程的锁,因为锁可重入, 所以是完全释放</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 当前节点是否在AQS同步队列中</span><br><span class="line">    // 如果不在同步队列中, 则park当前线程, 说明该线程还未满足竞争锁资源的</span><br><span class="line">    // 条件；如果在或者被中断过, 则退出循环</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当走到这步时, 代表已经调用了signal/signalAll方法, 重新竞争锁资源</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 清理取消等待的节点</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addConditionWaiter()<br>addConditionWaiter会将新建一个状态为Condition状态的节点并加入到条件队列的末尾。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // Node的节点状态如果不为CONDITION,</span><br><span class="line">    // 则表示该节点不处于等待状态,需要清除节点</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程新建节点,状态 CONDITION</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fullyRelease()<br>fullyRelease方法负责完成释放该线程持有的锁，因为例如 ReentrantLock 是可以重入的。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 持有锁的数量 </span><br><span class="line">        int savedState = getState();</span><br><span class="line">        // 完全释放锁, 因为ReentrantLock可重入</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed = false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁失败, 将节点状态置为CANCELLED</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>isOnSyncQueue()<br>isOnSyncQueue方法判断一个节点是否在AQS的同步队列上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">    // 状态为 Condition或者前驱节点为 null, 返回 false</span><br><span class="line">    if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">        return false;</span><br><span class="line">    // 后继节点不为 null，肯定在同步队列中</span><br><span class="line">    if (node.next != null) </span><br><span class="line">        return true;</span><br><span class="line">    // 从同步队列尾部开始向前查找, 判断是否在同步队列上</span><br><span class="line">    return findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unlinkCancelledWaiters()<br>unlinkCancelledWaiters方法负责将条件队列中状态不为Condition的节点删除。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    // 记录上一个Node节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        // 节点状态不为CONDITION, 将其删除</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="线程唤醒操作"><a class="markdownIt-Anchor" href="#线程唤醒操作"></a> 线程唤醒操作</h4><ol><li><p>signal()<br>signal方法会将Condition 的头节点移动到AQS同步队列尾部，让其等待再次获取锁资源。会首先唤醒条件队列中第一个节点，即等待时间最长的节点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //检测当前线程是否拥有锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //头节点，唤醒条件队列中的第一个节点</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doSignal()<br>doSignal方法会依次移除条件队列的节点，并调用transferForSignal方法将节点移动到AQS同步队列中。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //修改头结点，完成旧头结点的移出工作</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    // 将条件队列中的节点移动到同步队列中</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">    (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>transferForSignal()<br>transferForSignal会将条件队列的节点移动到AQS同步队列中。并修改当前节点的前一个结点状态为SIGNAL。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //将该节点从状态CONDITION改变为初始状态0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //将节点加入到同步队列中去,返回的是同步队列中node节点前面的一个节点</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //如果结点p的状态为cancel 或者修改waitStatus失败,则直接唤醒</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h3><p>使用Condition实现生产者消费者模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConditionExample &#123;</span><br><span class="line">    // 缓冲区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer;</span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line">    private Lock lock;</span><br><span class="line">    // 定义两个Condition, 即两个条件队列</span><br><span class="line">    private Condition fullCondition;</span><br><span class="line">    private Condition notFullCondition;</span><br><span class="line"></span><br><span class="line">    ConditionExample(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">        lock = new ReentrantLock();</span><br><span class="line">        fullCondition = lock.newCondition();</span><br><span class="line">        notFullCondition = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        //获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                //缓冲区已经满了,不能再进行添加, </span><br><span class="line">                // 调用await方法将添加的线程设置为等待状态,并且释放锁</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加数据到缓存区</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            // 告知可以从缓冲区获取数据了 ,将fullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            fullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 记得释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (buffer.size() == 0)&#123;</span><br><span class="line">                // 缓冲区为空,不能进行获取, </span><br><span class="line">                // 调用await方法将获取的线程设置为等待状态,并且释放锁</span><br><span class="line">                fullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            // 从缓存区取数据</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            // 告知可以添加数据到缓存区了,将notFullCondition条件队列的线程</span><br><span class="line">            // 移动到AQS同步队列中, 等待唤醒并获取锁</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object::wait，notify实现生产者消费者模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;</span><br><span class="line"></span><br><span class="line">    ConditionTest(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="http://www.iocoder.cn/JUC/sike/Condition/" rel="external nofollow noopener noreferrer" target="_blank">http://www.iocoder.cn/JUC/sike/Condition/</a><br>[2] <a href="https://www.cnblogs.com/dolphin0520/p/3920385.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3920385.html</a></p><h2 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h2><h3 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h3><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源，或者说是同时执行某个特定操作的数量。<br>Semaphore将AQS同步状态用来保存当前可用许可的数量，许可的数量可以通过构造函数的参数指定。</p><ol><li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可；</li><li>访问资源后，使用release释放许可。<br>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</li></ol><h3 id="源码分析-3"><a class="markdownIt-Anchor" href="#源码分析-3"></a> 源码分析</h3><h4 id="获取许可操作"><a class="markdownIt-Anchor" href="#获取许可操作"></a> 获取许可操作</h4><ol><li><p>acquire()<br>Semaphore对外提供acquire方法，用户不需要了解其他详细的获取细节，线程通过调用该方法来获取许可，以完成对特定资源的访问。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquireSharedInterruptibly()<br>acquireSharedInterruptibly方法会调用tryAcquireShared方法来获取许可。若返回正整数（大于等于0），表示获取许可成功，线程继续向前执行；否则将调用doAcquireSharedInterruptibly方法将线程加入到同步队列，等待许可的释放。<br>tryAcquireShared方法交由Semaphore来实现，它自己来实现判断逻辑 - 怎么才算获取许可成功。<br>xxxxShared表示该获取操作是非独占操作（Shared）。<br>关于如何阻塞一个线程，将线程加入到同步队列中，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    // 线程中断</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 若返回整数, 则表示获取需求成功, 线程继续向后执行</span><br><span class="line">    // 否则, 获取失败, 将线程加入到同步队列, 等待许可的释放</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared()<br>Semaphore实现tryAcquireShared方法来完成具体的许可获取逻辑。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到可用许可</span><br><span class="line">        int available = getState();</span><br><span class="line">        // 计算剩余许可</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        // 原子更新可用许可, 并返回剩余许可数</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="释放许可操作"><a class="markdownIt-Anchor" href="#释放许可操作"></a> 释放许可操作</h4><ol><li><p>release()<br>Semaphore对外提供release方法，用户不需要了解其他详细的许可释放细节就可以完成许可释放操作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>releaseShared()<br>release方法会调用releaseShared方法去释放许可。若释放许可成功，则调用doReleaseShared方法来唤醒同步队列中的等待线程来尝试重新获取需求；若释放许可失败，则直接返回。<br>tryReleaseShared方法交由Semaphore来实现，它自己来实现释放许可逻辑。<br>关于如何释放同步队列中的一个等待线程，参考<a href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html#more">《JU.C之AQS源码分析》</a>。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 许可释放成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 唤醒等待获取许可的线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared()<br>Semaphore通过tryReleaseShared方法来实现许可的释放逻辑。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 得到当前许可数量</span><br><span class="line">        int current = getState();</span><br><span class="line">        // 修改许可数量</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        // 原子更新许可数量</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="应用实例-2"><a class="markdownIt-Anchor" href="#应用实例-2"></a> 应用实例</h3><p>Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。<br>读取数据到数据库中，可以启动几十个线程并发读取来进行读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SemaphoreTest&#123;</span><br><span class="line">    private static final int COUNT = 40;</span><br><span class="line">    private static Executor executor = Executors.newFixedThreadPool(COUNT);</span><br><span class="line">    private static Semaphore semaphore = new Semaphore(10);</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        for(inti=0;i&lt;COUNT;i++)&#123;</span><br><span class="line">            executor.execute(newThreadTest.Task());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override </span><br><span class="line">        public void run()&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">            // 获取许可, 因为许可数量只有十个, 所有最多只能有10个线程进行操作</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            //todo 存数据过程</span><br><span class="line">            semaphore.release();</span><br><span class="line">            &#125;catch(InterruptedExceptione)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><p>[1] <a href="https://www.jianshu.com/p/0090341c6b80" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0090341c6b80</a></p><h2 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h2><h3 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h3><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3><p>CountDownLatch是通过一个计数器来实现的，通过同步状态保存当前计数值，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/countDownLatch.png" title="countDownLatch"><h3 id="源码分析-4"><a class="markdownIt-Anchor" href="#源码分析-4"></a> 源码分析</h3><h4 id="获取闭锁操作"><a class="markdownIt-Anchor" href="#获取闭锁操作"></a> 获取闭锁操作</h4><ol><li><p>await()<br>CountDownLatch对外部提供await方法，用户不需要了解闭锁获取的细节，线程通过调用该方法来获取闭锁。<br>在await() 方法中会调用与Semaphore相同的acquireShared方法来获取锁，并且获取失败之后的处理也一致，都是AQS提供了公共方法。主要不同体现在tryAcquireShared 方法的实现上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared(int acquires)<br>当同步状态等于0时，表示其他线程已经全部执行完毕，获取闭锁成功，线程继续往下执行；若失败，则将线程放入到同步队列中，并阻塞线程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    // 同步状态等于0时,代表其他线程已经执行完毕, 获取闭锁成功</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="释放闭锁操作"><a class="markdownIt-Anchor" href="#释放闭锁操作"></a> 释放闭锁操作</h3><ol><li><p>countDown()<br>CountDownLatch对外部提供countDown方法，其他线程调用该方法来释放资源。<br>在countDown() 方法中会调用与Semaphore相同的releaseShared方法来释放资源，并且释放成功之后的处理也一致，都会尝试唤醒同步队列上的等待线程，都是AQS提供了公共方法。主要不同体现在tryReleaseShared 方法的实现上。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 释放资源成功</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 尝试唤醒同步队列的等待线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared(int args)<br>tryReleaseShared方法将会减少同步状态，当同步状态等于0时，返回true，会调用doReleaseShared 方法唤醒同步队列的等待线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 减少同步状态直到为0</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="应用实例-3"><a class="markdownIt-Anchor" href="#应用实例-3"></a> 应用实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchExample &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建一个线程池</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; catch (Exception e)&#123;</span><br><span class="line">                    log.info(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 只有当threadCount 为0时, 即200个线程执行完毕之后, 才会执行后面的语句</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        // 等待10ms, 若200个线程没有执行完毕, 则当前线程会继续执行</span><br><span class="line">        // countDownLatch.await(10, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(&quot;finish&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test (int threadNum) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><ol><li>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数器为1的CountDownLatch，并让其他所有线程都在这个锁上等待，只需要调用一次countDown()方法就可以让其他所有等待的线程同时恢复执行。</li><li>开始执行前等待N个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统都已经启动和运行了。</li><li>死锁检测：一个非常方便的使用场景是你用N个线程去访问共享资源，在每个测试阶段线程数量不同，并尝试产生死锁。</li></ol><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><p>[1] <a href="https://www.jianshu.com/p/4b6fbdf5a08f" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4b6fbdf5a08f</a></p><h3 id="countdownlatch和semaphore结合实例"><a class="markdownIt-Anchor" href="#countdownlatch和semaphore结合实例"></a> CountDownLatch和Semaphore结合实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcurrencyTest&#123;</span><br><span class="line">    //请求数</span><br><span class="line">    public static intc lientTotal=1000;</span><br><span class="line">    //并发请求数</span><br><span class="line">    public static int threadTotal=50;</span><br><span class="line">    //共享计数量</span><br><span class="line">    public static int count=0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)throws InterruptedException&#123;</span><br><span class="line">        //定义线程池</span><br><span class="line">        ExecutorService executorService=Executors.new CachedThreadPool();</span><br><span class="line">        //定义信号量,并设置运行并发数</span><br><span class="line">        final Semaphore semaphore=new Semaphore(threadTotal);</span><br><span class="line">        //定义CountDownLatch,在所有的请求完成之后输出结果</span><br><span class="line">        final CountDownLatch countDownLatch=new CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        //线程执行</span><br><span class="line">        for(inti=0;i&lt;clientTotal;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    //获取信号量-最大并发数为50</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    count();</span><br><span class="line">                    //释放信号量</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                    log.info(&quot;InterruptedException&quot;,e);</span><br><span class="line">                &#125;</span><br><span class="line">                //进行count--</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //只有countDown到0的时候,才会唤起线程继续执行,不然会挂起继续等待</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        //关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        //在所有子线程执行完之后,打印count值</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void count()&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h2><h3 id="概述-5"><a class="markdownIt-Anchor" href="#概述-5"></a> 概述</h3><p>CycliBarrier也称为循环屏障，它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，循环是指因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</p><h3 id="实现原理-2"><a class="markdownIt-Anchor" href="#实现原理-2"></a> 实现原理</h3><p>CyclicBarrier将同步状态设置为到达屏障的线程数量。当某一个线程到达屏障之后，将当前线程加入到同步队列中并阻塞，并且数量减一，当数量为0时，唤醒被阻塞的所有线程，让它们继续执行。</p><img src="/J-U-C之常用同步器-ReentrantLock-CountDownLatch-Semaphore-CyclicBarrier-Condition-源码分析/cyclicBarrier.png" title="cyclicBarrier"><h3 id="源码分析-5"><a class="markdownIt-Anchor" href="#源码分析-5"></a> 源码分析</h3><ol><li><p>CyclicBarrier(int parties) / CyclicBarrier(int parties, Runnable barrierAction)<br>CyclicBarrier提供了两种构造方法，提供了参数有：需要到达屏障的线程数，到达指定屏障后优先执行的动作。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    // 屏障数量</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    // 当前还有多少线程没有到达屏障</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>await()<br>CyclicBarrier对外提供await方法。用户不需要了解循环屏障的具体实现细节就可使用其提供的功能。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // dowait(timed, nanos)</span><br><span class="line">        // 当timed = true时, 表示设置等待超时时间, nanos为时才</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dowait(boolean timed, long nanos)<br>await通过调用dowait方法来实现线程的阻塞和唤醒。若还有剩余线程未到达屏障，线程通过调用该方法来完成阻塞操作，将线程阻塞在屏障前；若所有线程已到达屏障前，则唤醒所有被阻塞的线程，让它们继续向前执行。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">throws InterruptedException, BrokenBarrierException,</span><br><span class="line">TimeoutException &#123;</span><br><span class="line">    // 定义一个可重入锁, 保证多线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 构建一个&quot;代&quot;(Generation)对象</span><br><span class="line">        // 同一个Generation表示同一代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        // 如果broken=true表示当前屏障被损坏了,抛出异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        // 如果线程被中断过, 设置屏障为损坏状态    </span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 需要到达屏障的线程数减 - 1</span><br><span class="line">        int index = --count;</span><br><span class="line">        // 若数量为0, 表示所有线程都到达了屏障</span><br><span class="line">        if (index == 0) &#123;</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                // 表示到达屏障之后,如果我们有设置barrierCommand, 则优先执行</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                 //执行到这里的时候，说明所有线程都执行await()方法(到达了屏障)</span><br><span class="line">                // 且设置的barrierCommand也已经执行完了</span><br><span class="line">                //接下来要做的事情就是换代(所以CyclicBarrier是通过换代的方式</span><br><span class="line">                // 实现重新计数的)</span><br><span class="line">                //换代之后相当于进入一个新的周期,所有线程在后续中又可以通过</span><br><span class="line">                // await()阻塞一次</span><br><span class="line">                ranAction = true;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 如果ranAction = false说明当前屏障还有流程没执行完,</span><br><span class="line">                // 所以需要屏障设置会损坏状态</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 进行自旋操作直到count=0,调用breakBarrier方法(表示屏障有问题的场景),</span><br><span class="line">        // 中断或者超时</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            // 没有设置超时时间,</span><br><span class="line">            // 调用Condition的await()阻塞,相当于把线程加入</span><br><span class="line">            // 到Condition队列中阻塞, 等到调用signalAll方法唤醒</span><br><span class="line">            if (!timed)</span><br><span class="line">                trip.await();</span><br><span class="line">            // 设置阻塞超时时间</span><br><span class="line">            else if (nanos &gt; 0L)</span><br><span class="line">                nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                // 如果当前屏障没有换代,也没有损坏,</span><br><span class="line">                // 那么就设置为损坏状态之后再抛出中断异常</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 中断线程等待</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果屏障已经被损坏了</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line">                                        </span><br><span class="line">            // 如果发现已经换代了, 就不继续循环了,</span><br><span class="line">            // 直接返回剩余屏障数</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            // 表示超时时间到了</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nextGeneration()<br>若所有线程都到达了屏障，将条件队列中的线程切换到AQS同步队列中，并唤醒所有等待线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 条件队列中的等待线程切换AQS同步队列中, AQS同步队列中等待线程依次被唤醒获取锁</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // 开始一个循环屏障</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用实例-2"><a class="markdownIt-Anchor" href="#使用实例-2"></a> 使用实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line"></span><br><span class="line">    // 设置屏障数量为5</span><br><span class="line">    // private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5);</span><br><span class="line">    // 到达指定屏障之后, 优先执行barrierAction中的动作</span><br><span class="line">    private static CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&gt; &#123;</span><br><span class="line">        log.info(&quot;Priority Action!!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    doSomething(threadNum);</span><br><span class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void doSomething(int threadNum) throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am ready!&quot;, threadNum);</span><br><span class="line">        // 某个线程初始化完毕, 则阻塞等待, 若阻塞数量达到5个, 则一起执行每个线程后面的方法</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        log.info(&quot;&#123;&#125;: I am done!&quot;, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><p>CyclicBarrier适用多线程计算数据，最后合并计算结果的场景。<br>相比于CountDownLatch，CyclicBarrier能适用于更多场景，例如，如果计算发生错误，可以重置计数 器，并让线程重新执行一次。因为CountDownLatch计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</p><h3 id="参考资料-3"><a class="markdownIt-Anchor" href="#参考资料-3"></a> 参考资料</h3><p>[1] <a href="http://blog.sikacode.com/article/40#CyclicBarrier_68" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sikacode.com/article/40#CyclicBarrier_68</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用同步器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常用同步器&quot;&gt;&lt;/a&gt; 常用同步器&lt;/h2&gt;
&lt;p&gt;J.U.C中许多常用同步器都是基于AQS实现，主要有以下：CountDownLatch，Semaphore，CyclicBar
      
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.huangbin.fun/categories/Concurrency/"/>
    
    
      <category term="J.U.C" scheme="http://www.huangbin.fun/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS源码学习</title>
    <link href="http://www.huangbin.fun/J-U-C%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/J-U-C之AQS源码学习.html</id>
    <published>2020-06-12T09:08:53.000Z</published>
    <updated>2020-11-24T13:15:52.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="aqsabstractqueuedsynchronizer"><a class="markdownIt-Anchor" href="#aqsabstractqueuedsynchronizer"></a> AQS(AbstractQueuedSynchronizer)</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>AQS 提供了一种实现阻塞锁和一系列依赖FIFO同步队列的同步器的框架，ReentrantLock，CountDownLatch等等都是基于AQS的基础上实现的。<br>使用AQS去实现自定义的同步器时，我们只需要实现对共享资源的获取和释放即可，对于阻塞线程的维护和唤醒都有AQS进行了实现，进一步简便了自定义同步器的实现。<br>在基于AQS构建的同步器类中，最基本的操作包括各种形式的获取操作和释放操作，还有定义状态信息。</p><ol><li>获取操作是一种依赖状态的操作，并且通常会阻塞。当使用锁或信号量时，“获取&quot;操作的含义就是获取锁或者许可，并且调用者可能会一直等待直到同步器类处于可被获取的状态。例如在使用CountDownLatch时，“获取&quot;操作意味着&quot;等待并直到闭锁到达结束状态”，使用FutureTask时，则意味着&quot;等待并直到任务已经完成”。<br>根据同步器的不同，获取操作可以是独占操作（ReentrantLock），也可以是非独占操作（Semaphore，CountDownLatch）。<br>如果某个同步器支持独占的获取操作，那么需要实现一些保护方法，包括tryAcquire，tryRelease和isHeldExclusively等，而对于支持共享获取的同步器，则应该实现tryAcquireShared，tryReleaseShared等。AQS中的acquire，acquiredShared，release，releaseShared等方法都将调用这些方法在子类中带有前缀try的版本来判断某个操作是否能执行。<br>在同步器的子类中，可以根据其获取操作和释放操作的语义，使用getState，setState以及compareAndSetState来检查和更新状态，并通过返回的状态值来告知基类&quot;获取&quot;或&quot;释放&quot;同步器的操作是否成功。</li><li>&quot;释放&quot;操作并不是一个可阻塞的操作，当执行&quot;释放&quot;时，所有在请求时被阻塞的线程都会开始执行。</li><li>一个类想要成为状态依赖的类，它必须拥有一些状态。AQS负责管理同步器类中的状态，它管理了一个整数状态信息（volatile关键字修饰），可通过getState，setState和compareAndSetState等方法来操作。这个整数可以表示为任意状态。例如ReentrantLock用它来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它来表示任务的状态（尚未开始，正在运行，已完成或已取消）。<br>同步器还可以自行管理一些额外的状态变量，例如ReentrantLock保存了锁的所有者的信息，以此来区分获取操作是重入的还是竞争的。</li></ol><p>下图说明了获取操作和释放操作的伪代码：</p><img src="/J-U-C之AQS源码学习/getrelease.jpg" title="get/release"><p>对于获取操作：同步器判断当前状态是否允许获得操作，如果允许，则允许线程执行，并更新同步器的状态，否则获取操作将阻塞或失败。具体的判断实现，由同步器的语义决定。<br>对于释放操作：更新同步器的状态，并且如果新的状态允许某个被阻塞的线程获取成功，则解除等待队列中一个或多个线程的等待状态。</p><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><p>OneShotLatch是一个使用AQS来实现的二元闭锁。包含两个方法：await，signal，分别对应获取操作和释放操作。<br>AQS状态用来表示闭锁的状态 - 关闭（0） 和 打开（1）。起初，闭锁是关闭的，任何调用await方法的线程都将阻塞并直到闭锁被打开。当通过调用signal打开闭锁时，所有等待中的线程都将被释放，并且随后到达闭锁的线程也被允许执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class oneShotLatch &#123;</span><br><span class="line">    private final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    public void signal()&#123;</span><br><span class="line">        sync.releaseShared(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await()&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(0);</span><br><span class="line">    &#125;</span><br><span class="line">    private class Sync extends AbstractQueueSynchronizer&#123;</span><br><span class="line">        protected int tryAcquireShared(int ignored)&#123;</span><br><span class="line">            // 如果闭锁打开状态(1), 则获取操作成功, 否则失败</span><br><span class="line">            return (getState() == 1) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        protected boolean tryReleaseShared(int ignored)&#123;</span><br><span class="line">            // 打开闭锁</span><br><span class="line">            setState(1);</span><br><span class="line">            // 返回true, 代表其他线程可以获取该闭锁</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 的acquireSharedInterruptibly 和 releaseShared 方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行流程如下：</p><ol><li>当某个线程调用await方法时，该方法会调用AQS的acquireSharedInterruptibly方法，然后接着调用oneShotLatch的tryAcquireShared方法（在这个方法中实现同步器的获取语义），在tryAcquireShared的实现中返回一个值来表示获取操作能否执行。<br>若闭锁是关闭的（获取失败），那么AQS会调用doAcquireSharedInterruptibly方法将线程放入等待线程队列中。</li><li>当某个线程调用signal方法时，该方法会调用AQS的releaseShared方法，然后接着调用oneSlotLatch的tryReleaseShared方法（在这个方法中实现同步器的释放语义），oneShotLatch的tryReleaseShared方法实现将无条件把闭锁设置为打开，通过返回true表示该同步器处于被释放的状态。<br>若释放成功，AQS 会调用 doReleaseShared 方法会让所有等待的线程都尝试重新请求同步器，并且由于tryAcquireShared将返回成功，因此获取操作将成功。</li></ol><h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h2><p>下述的源码分析基于JDK 8。<br>前面所提到的获取操作可能会阻塞线程，释放操作可能会对唤醒线程，并且也提到了阻塞线程是记录在一个同步队列上，那么AQS是如何来完成线程的阻塞和唤醒的呢？<br>AQS通过一个FIFO队列（双向链表，该队列也被称为同步队列）来保存阻塞线程，队列中每个Node节点就是对每一个等待获取资源的线程的封装，Node 作为一个静态内部类保存了线程本身（Thread），线程的等待状态（WaitStatus），双向链表指针（pre，next）以及独占模式还是共享模式等等。<br>其中在队列中的一个线程具有以下五种状态：</p><ol><li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化；</li><li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL；</li><li>CONDITION(-2)：表示结点等待在Condition上。当调用Condition的await方法时，会将线程置为CONDITION状态，并将线程从同步队列（Sync queue）移动到条件队列中（Condition queue)，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从条件队列转移到同步队列中，将线程状态设置为0，等待获取同步锁；</li><li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点；</li><li>0：新结点入队时的默认状态。</li></ol><img src="/J-U-C之AQS源码学习/syncQueue.png" title="syncQueue"><p>其中head结点所指的标杆结点，就是当前获取到资源的那个结点或null。</p><h3 id="独占模式下资源获取"><a class="markdownIt-Anchor" href="#独占模式下资源获取"></a> 独占模式下资源获取</h3><ol><li><p>acquire(int arg)<br>acquire方法是独占模式下线程获取资源的顶层入口。如果获取到了资源（tryAcquire方法返回true，该方法实现具体由自定义同步器的语义决定），则线程直接返回；否则将当前线程加入等待队列，等待其他线程释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquire(int arg)<br>tryAcquire方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryAcquire方法交由自定义同步器来实现具体的获取资源的逻辑。</p></li><li><p>addWaiter(Node mode)<br>addWriter方法根据传递过来的mode（SHARED - 共享模式，EXCLUSIVE - 独占模式）创建一个新的node节点，队列的尾结点不为空，则将新结点插入到尾部，并返回Node结点。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 将新node放置结尾</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 原子更新tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 上一步设置失败, 则通过enq入队</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>endq(final Node node)<br>当tail结点为空时，addWaiter方法插入结点失败，此时会调用enq方法来进行新结点入队。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //CAS&quot;自旋&quot;，直到成功加入队尾</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它</span><br><span class="line">        if (t == null) &#123; </span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">        // 若此时tail结点不为空, 则将node结点放入尾部</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquireQueued(final Node node，int arg)<br>当执行完addWaiter方法时，关于当前线程的Node结点已经放入同步队列，当前线程进入到等待状态，等待其他线程释放资源。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    // 标记是否成功拿到资源</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 标记等待过程是否被中断</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 自旋等待获取资源</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 拿到前驱结点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前驱结点是head, 则表示当前结点是&quot;老二&quot;, 便有资格去获取资源</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //拿到资源后，将head指向该结点</span><br><span class="line">                // 就是当前获取到资源的那个结点或null</span><br><span class="line">                setHead(node);</span><br><span class="line">                // setHead中node.prev已置为null,此处再将head.next置为null,</span><br><span class="line">                // 就是为了方便GC回收以前的head结点</span><br><span class="line">                p.next = null;</span><br><span class="line">                // 成功获取资源</span><br><span class="line">                failed = false;</span><br><span class="line">                // 返回等待过程中是否被中断过</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 利用shouldParkAfterFailedAcquire方法将线程设置了watting状态</span><br><span class="line">            // 如果等待过程中被中断过,哪怕只有那么一次,就interrupted标记为true</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 如果等待过程中没有成功获取资源</span><br><span class="line">        // 那么取消结点在队列中的等待</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>shouldParkAfterFailedAcquire (Node pre，Node node)<br>shouldParkAfterFailedAcquire  主要用来检查状态，防止前面的结点已经放弃了等待，但是没有被移除。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    // 前一个结点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    // 前序结点为SIGNAL时, 表示后继结点在等待唤醒</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        return true;</span><br><span class="line">    // 当前驱结点 &gt; 0时, 即为CANCELLED状态时, 代表前驱节点中的线程已经放弃了等待</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        // 一直往前找,直到找到最近一个正常等待的状态,并排在它的后边</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果前驱状态正常，那就把前驱的状态设置成SIGNAL, 表示后继节点在等待唤醒</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt()<br>parkAndCheckInterrupt方法就是让线程去休息，真正进入等待状态。<br>park方法会让当前线程进入waiting状态，可以有两种途径唤醒它：unpark方法/interrupt方法。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    //调用park()使线程进入waiting状态</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    //如果被唤醒，查看自己是不是被中断的</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结</p> <img src="/J-U-C之AQS源码学习/acquire.png" title="acquire"><ol><li>调用AQS提供的acquire方法来获取资源，在acquire方法中会调用自定义同步器所实现的tryAcquire方法判断是否可以成功获取资源，若获取成功，则直接返回，线程继续向前执行；</li><li>若第一步中获取资源失败，则调用addWaiter方法将当前线程封装成一个Node结点加入到同步队列的末尾；</li><li>入队成功后，调用acquireQueued方法将设置线程为waitting状态（具体是调用park方法）。需要注意是，在首次调用acquireQueued方法时就会进行一次判断，判断是否可以获取到资源，因为此时可能会其他线程进行了释放操作；</li><li>如果线程调用了unpark方法和interrupt方法，那么将唤醒当前线程，判断线程是否可以<br>获取到资源，若可以进行获取操作，则将线程的Node结点设置为head结点，并返回。</li></ol></li></ol><h3 id="独占模式下资源释放"><a class="markdownIt-Anchor" href="#独占模式下资源释放"></a> 独占模式下资源释放</h3><ol><li><p>release(int arg)<br>release方法是独占模式下线程获取资源的顶层入口。该方法会释放指定量的资源，与此同时，它会唤醒同步队列中的等待线程来获取资源。具体释放资源操作由tryAcquire方法实现，而该方法的具体实现由自定义同步器的语义决定。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        // 找到头结点</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒等待队列的下一个线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryRelease (int arg)<br>tryRelease方法尝试去释放指定量的资源。如果释放成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryRelease方法交由自定义同步器来实现具体的释放资源的逻辑。</p></li><li><p>unparkSuccessor(Node node)<br>unparkSuccessor方法用于唤醒同步队列中当前Node结点的下一个结点，唤醒其中的线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    // 获取当前结点的状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 若结点状态为 SIGNAL(-1), CONDITION(-2), PROPAGATE(-3)</span><br><span class="line">    // 将状态更新为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    // 找到下一个需要唤醒的结点</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    // 若下一个需要唤醒的结点为null 或状态为已取消(CANCELLED - 1)</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前查找, 找到一个可以被唤醒的结点</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        if (t.waitStatus &lt;= 0)</span><br><span class="line">            s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 调用unpark方法, 唤醒s结点中的线程, 那么被唤醒的线程会继续执行acquireQueued中的获取操作</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="共享模式下资源获取"><a class="markdownIt-Anchor" href="#共享模式下资源获取"></a> 共享模式下资源获取</h3><ol><li><p>acquireShared(int arg)<br>acquireShared方法是共享模式下线程获取资源的顶层入口。它会获取指定量的资源，若获取成功则直接返回，否则失败进行同步队列等待资源的释放。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryAcquireShared(int arg)<br>AQS作为一个框架，它提供了tryRelease方法交由自定义同步器来实现具体获取资源的逻辑。相比于tryAcquire返回一个boolean值，tryAcquiredShared方法将返回一个整数：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doAcquireShared(int arg)<br>doAcquireShared方法会调用addWaiter方法将当前线程封装为一个Node结点并插入到同步队列的末尾。之后进入到一个自旋操作，若满足条件（前序结点为head）会尝试获取一次资源，若获取失败，则调用parkAndCheckInterrupt方法中的park方法使得线程进行watting状态。<br>doAcquireShared的获取流程和acquireQueued方法的获取流程大致一致，只是将中断之后的调用方法放置在了方法内部。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 调用addWaiter方法将当前线程的结点插入到同步队列末尾</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    // 是否成功获取资源</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 等待过程中是否被中断的标记</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获得前驱结点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前驱结点是head, 则表示当前结点是&quot;老二&quot;, 便有资格去获取资源</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取资源</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 若返回整数则代表获取成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将head指向自己，还有剩余资源可以再唤醒之后的线程</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; </span><br><span class="line">                    //如果等待过程中被打断过, 此时将中断补上</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            // 判断状态，调用park方法使进入waiting状态, 等着被unpark()或interrupt()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    if (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>setHeadAndPropagate(Node node，int propagate)<br>setHeadAndPropagate方法 首先会将当前Node结点设置为head结点，若还有剩余资源，则尝唤醒下一个邻居线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // 记录旧头部以便下面的检查操作</span><br><span class="line">    // 将head指向自己</span><br><span class="line">    setHead(node);</span><br><span class="line">    // 如果还有剩余量, 继续唤醒下一个邻居线程</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">    (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared(); // 唤醒下一个邻居线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="共享模式下资源释放"><a class="markdownIt-Anchor" href="#共享模式下资源释放"></a> 共享模式下资源释放</h3><ol><li><p>releaseShared(int arg)<br>releaseShared方法是共享模式下线程获取资源的顶层入口。该方法会释放指定量的资源，与此同时，它会唤醒同步队列中的等待线程来获取资源。具体释放资源操作由tryAcquireShared方法实现，而该方法的具体实现由自定义同步器的语义决定）</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放资源</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 唤醒后继结点</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryReleaseShared (int arg)<br>tryReleaseShared方法尝试去释放指定量的资源。如果释放成功，则直接返回true，否则直接返回false。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS作为一个框架，它提供了tryReleaseShared方法交由自定义同步器来实现具体的释放资源的逻辑。</p></li><li><p>doReleaseShared ()<br>doReleaseShared方法主要用来唤醒同步队列上的线程。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    // 自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            // 若head结点的状态为SIGNAL</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;</span><br><span class="line">                // 唤醒后继结点</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">            !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] 《并发编程实战》<br>[2] <a href="https://www.cnblogs.com/waterystone/p/4920797.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;aqsabstractqueuedsynchronizer&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#aqsabstractqueuedsynchronizer&quot;&gt;&lt;/a&gt; AQS(AbstractQueuedSynchronize
      
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.huangbin.fun/categories/Concurrency/"/>
    
    
      <category term="J.U.C" scheme="http://www.huangbin.fun/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>对象的共享</title>
    <link href="http://www.huangbin.fun/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.huangbin.fun/对象的共享.html</id>
    <published>2020-06-07T08:20:24.000Z</published>
    <updated>2020-11-24T09:09:25.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<br>在多线程下，面临一个问题就是，无法确保执行读操作的线程能适时地看到其他线程写入的值。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready;</span><br><span class="line">    private static int number;</span><br><span class="line"></span><br><span class="line">    private static class ReaderThread extends Thread &#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            while(!ready)</span><br><span class="line">                // 让出线程执行时间, 从执行状态-&gt; 就绪状态</span><br><span class="line">                Thread.yield();</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new ReaderThread().start();</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是因为可见性问题，NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready值，还可能的是，NoVisibility可能会输出0，因为读线程看到了写入的ready值，但是却没有看到之后写入的number值，这种现象被称为&quot;重排序(Reordering)&quot;。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以很明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。</p><h3 id="失效数据"><a class="markdownIt-Anchor" href="#失效数据"></a> 失效数据</h3><p>上面NoVisibility的读线程所获得的数据称为失效数据。失效数据可能不会同时出现：一个线程获得某个变量的最新值，而获得另一个变量的失效值。失效数据会导致一些让人意想不到的错误，不精确的计算以及无限循环。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MutableInteger &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    </span><br><span class="line">    // 线程安全 public synchronized int get()</span><br><span class="line">    public int get()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 线程安全  public synchronized void set(int value)</span><br><span class="line">    public void set(int value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个线程调用了set，那么另一个正在调用get的线程可能会看到更新之后的最新值，也可能看到的是过期值（失效值）。可以加上synchronized同步使其线程安全。</p><h3 id="最低安全性"><a class="markdownIt-Anchor" href="#最低安全性"></a> 最低安全性</h3><p>当某个线程在没有同步的情况下读写一个变量，可能会得到失效值，但是这个值至少了之前某个线程设置的值，而不是一个随机值，这中安全性保证称为&quot;最低安全性（out-of-thin-air-safety）&quot;。<br>绝大部分变量都符合最低安全性，但是存在一个例外：非volatile类型的64位数值变量（double，long）。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但是对于非volatile类型的64位数值变量，JVM允许将64位的读操作或写操作分解位32位的操作，那么当读写操作在不同线程执行时，可能会读取到某个值的高32位和另一个值的低32位。<br>因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型变量都是不安全的，除非使用volatile声明或加锁。</p><h3 id="加锁和可见性"><a class="markdownIt-Anchor" href="#加锁和可见性"></a> 加锁和可见性</h3><p>内置锁可以确保某个线程以一种可预测的方式来查看另一个线程的结果。</p><img src="/对象的共享/sync.jpg" title="sync"><p>当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。<br>加锁的含义步仅仅局限于互斥行为，还包括内存可见性。</p><h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3><p>Java 提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程，即保证了新值能够立即同步回主存，以及每次使用前立即从主存刷新，总是返回最新写入的值。当把变量声明为volatile类型时，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序，volatile变量也不会被缓存在寄存器或者对处理器不可见的地方。<br>volatile的特性主要是通过内存屏障和禁止重排序优化来实现。</p><ol><li>内存屏障：对volatile变量写操作时，会在写操作之后加入一条store屏障指令，将工作内存中的共享变量同步回主存中；对volatile变量读操作时，会在读操作之前加入一条load屏障指令，将主存中最新的值刷新到工作内存中;</li><li>禁止重排序优化。</li></ol><p>访问volatile变量不会执行加锁操作，因此也就不会执行线程阻塞，所以说volatile是一种比synchronized关键字更加轻量级的同步机制。<br>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。volatile正确的使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生。<br>volatile常用的一个场景作为状态标识量，可以用来作为某个操作完成，发生中断或者状态的标志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean inited=false;</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">context = loadContext();</span><br><span class="line">inited=true;</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><p>单独使用volatile并不能保证对共享变量操作的线程安全。例如volatile的语义并不能保证递增操作（Count++）的线程安全性（原子性）。<br>当且仅当满足以下条件时，才应该使用volatile变量：</p><ol><li>对变量的写入操作不依赖变量的当前值，或者保证只有单个线程更新变量的值；</li><li>该变量不会与其他状态变量一起纳入不变性条件中；</li><li>在访问变量时不需要加锁。</li></ol><h3 id="加锁和volatile"><a class="markdownIt-Anchor" href="#加锁和volatile"></a> 加锁和volatile</h3><p>加锁机制即可以确保可见性又可以保证原子性，而volatile变量只能保证可见性。</p><h3 id="其他可见性方案"><a class="markdownIt-Anchor" href="#其他可见性方案"></a> 其他可见性方案</h3><ol><li><p>synchronized<br>synchronized的可见性是由&quot;对一个变量执行unlock操作之前，必须先把此变量同步回主存中（执行store，write）&quot;这条规则得到的。可以详细解释为：</p><ol><li>线程解锁时，必须把共享变量的最新值刷新到主存；</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中得到最新的值。</li></ol></li><li><p>final<br>final关键字的可见性是指： 被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把&quot;this&quot; 的引用传递出去，那么在其他线程中就能看到final字段的值。</p></li></ol><h2 id="线程封闭"><a class="markdownIt-Anchor" href="#线程封闭"></a> 线程封闭</h2><p>当访问共享的可变数组时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，这种技术就称为线程封闭。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。<br>Java 语言中并没有强制规定某个变量必须由锁来保护，也无法强制将对象封闭在线程中。线程封闭时程序设计的一个考虑因素，必须在程序中实现。</p><h3 id="ad-hoc线程封闭"><a class="markdownIt-Anchor" href="#ad-hoc线程封闭"></a> Ad-hoc线程封闭</h3><p>Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序来承担。此种线程封闭时不可靠且脆弱的，因为没有任何一种语言特性能将对象封闭到目标线程上。</p><h3 id="栈封闭"><a class="markdownIt-Anchor" href="#栈封闭"></a> 栈封闭</h3><p>在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比Ad-hoc线程封闭更易于维护，也更加健壮。<br>对于基本类型的局部变量，任何方法都无法获得对于基本类型的引用，因此确保了基本类型的局部变量始终封闭在线程内。<br>在维持对象引用的栈封闭性时，需要多做一些工作以确保被引用的对象不会逸出。<br>如果在线程内部（Within-Thread）上下文使用非线程安全的对象，那么该对象仍然是线程安全的。</p><h3 id="threadlocal线程封闭"><a class="markdownIt-Anchor" href="#threadlocal线程封闭"></a> ThreadLocal线程封闭</h3><p>ThreadLocal 类提供了get和set方法，这些方法为每个使用该变量的线程都存有一份独立的副本。ThreadLocal通常用来防止对可变的单实例变量（Singleton）或全局变量进行共享。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectioHolder</span><br><span class="line">    = new ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">    // 调取initialValue获取初始值</span><br><span class="line">    // 为每个线程都分配一个数据库连接</span><br><span class="line">    public Connection initialValue()&#123;</span><br><span class="line">        return DriverManaget.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">    return ConnectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将TheadLocal<t>视为包含了Map&lt;Thread, T&gt;对象，其中保存了特定于该线程的值，但是ThreadLocal的实现并非如此。当线程终止后，这些值会被做为垃圾回收。</t></p><h2 id="对象发布和逸出"><a class="markdownIt-Anchor" href="#对象发布和逸出"></a> 对象发布和逸出</h2><h3 id="对象发布"><a class="markdownIt-Anchor" href="#对象发布"></a> 对象发布</h3><p>发布对象：使一个对象能够被当前作用域之外的代码所使用。<br>例如：将一个指向该对象的引用保存在其他代码可以访问的地方；在某一个非私有的方法返回该对象的引用；将引用传递到其他类的方法中。</p><ol><li><p>将一个指向该对象的引用保存在其他代码可以访问的地方</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Set&lt;Person&gt; knowPerson;</span><br><span class="line"></span><br><span class="line">public void initalize () &#123;</span><br><span class="line">    knowPerson = new HashSet&lt;Person&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发布某个对象时，可能会间接发布其他对象。比如若Set集合中保存了若干Person 对象，那么发布了KnowPerson之后，里面的Person对象也会被发布出去。</p></li><li><p>在某个非私有的方法返回该对象的引用</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class publish &#123;</span><br><span class="line">    // 定义一个字符串对象数组</span><br><span class="line">    public String[] strings = &#123;&quot;HB&quot;, &quot;QQL&quot;, &quot;HY&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 通过一个公有方法发布它, 使得当前范围之外代码所使用</span><br><span class="line">    public String[] getStrings () &#123;</span><br><span class="line">        return strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Publish publish = new Publish();</span><br><span class="line">        log.info(&quot;Strings: &#123;&#125;&quot;, Arrays.toString(publish.getStrings()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将引用传递到其他类的方法中</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class publish &#123;</span><br><span class="line">    class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        OtherClass otherClass = new OtherClass();</span><br><span class="line">        otherClass.doSomething(new Person());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，发布了Person对象。通常接受被发布对象的方法称为外部方法（Alien），即定义一个类C，对于C来说，外部方法是指行为并不完全由C来规定的方法，包括其它类中定义的方法以及类C中可以被改写的方法。当把一个对象传递给一个外部方法时，就相当于发布了这个对象。<br>另外当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。总结来说，一个已经发布的对象能够通过非私有的变量引用或方法调用到达其他的对象，那么这些对象也会被间接发布。</p></li></ol><h3 id="对象逸出"><a class="markdownIt-Anchor" href="#对象逸出"></a> 对象逸出</h3><p>对象逸出：一种错误的发布，某个不应该发布的对象被发布。<br>当一个对象逸出后，其他类或线程可能会误用该对象。<br>几种常见的对象逸出可看下述代码示例：</p><ol><li><p>内部状态的逸出</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Escape &#123;</span><br><span class="line">    // 定义一个私有的字符串对象数组</span><br><span class="line">    private String[] strings = &#123;&quot;HB&quot;, &quot;QQL&quot;, &quot;HY&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 通过一个公有方法发布它, 使得当前范围之外代码所使用</span><br><span class="line">    public String[] getStrings () &#123;</span><br><span class="line">        return strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafePublish unsafePublish = new UnsafePublish();</span><br><span class="line">        log.info(&quot;Stings: &#123;&#125;&quot;, Arrays.toString(unsafePublish.getStrings()));</span><br><span class="line">        unsafePublish.getStrings()[0] = &quot;CCZ&quot;;</span><br><span class="line">        // 不安全, 其他线程会够对私有对象进行修改</span><br><span class="line">        log.info(&quot;Stings: &#123;&#125;&quot;, Arrays.toString(unsafePublish.getStrings()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串数组作为私有变量但是被发布了，逸出了它所在的作用域。在发布一个对象时，要确保对象的内部状态不被发布，可能会破坏封装性。</p></li><li><p>this引用在构造函数逸出</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThisEscape &#123;</span><br><span class="line">    public ThisEscape (EventSource source) &#123;</span><br><span class="line">        source.registerListener (</span><br><span class="line">            // 匿名内部类, 持有指向外部类对象的引用</span><br><span class="line">            new EventListener() &#123;</span><br><span class="line">                public void onEvent (Event e) &#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述发布隐式地使this引用逸出，当ThisEscape发布了EventListener时，也隐含了发布了ThisEscape本身，并且发布的ThisEscape时一个尚未构造完成的对象，会造成线程安全性问题。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。<br>通常一下几种操作会造成this应用逸出：</p><ol><li>在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论时显示创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未构造完成之前，新的线程就可以看见它。<br>在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initalize方法来启动；</li><li>在构造函数中调用一个可改写的示例方法时（既不是私有方法，也不是final方法），同样会导致this应用在构造过程中逸出。</li></ol> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThisEscape &#123;</span><br><span class="line">    private int thisCanBeEscape = 89;</span><br><span class="line"></span><br><span class="line">    public ThisEscape () throws InterruptedException &#123;</span><br><span class="line">        // a. 创建一个线程</span><br><span class="line">        Thread thread = new Thread(() -&gt;&#123;</span><br><span class="line">            log.info(&quot;Escape caused by create thread &#123;&#125;&quot;, ThisEscape.this.thisCanBeEscape);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.run();</span><br><span class="line"></span><br><span class="line">        // b. 调用一个实例方法</span><br><span class="line">        doSomething();</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        log.info(&quot;&#123;Escape caused by call method&#125;&quot;, UnsafeEscape.this.thisCanBeEscape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThisEscape thisEscape = new ThisEscape ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过使用一个私有的构造函数和一个公共的工厂方法来避免不正确的构造过程：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SafeListener &#123;</span><br><span class="line">    private final EventListener listener;</span><br><span class="line"></span><br><span class="line">    private SafeListener () &#123;</span><br><span class="line">        listener = new EventListener() &#123;</span><br><span class="line">            public void onEvent(Event e) &#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SafeListener newInstance (EventSource source) &#123;</span><br><span class="line">        SafeListener safe = new SafeListener(); // 构造函数已完成</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        return safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象分类"><a class="markdownIt-Anchor" href="#对象分类"></a> 对象分类</h2><h3 id="不可变对象"><a class="markdownIt-Anchor" href="#不可变对象"></a> 不可变对象</h3><p>如果某个对象在被创建后其状态就不能被修改，称这个对象为不可变对象。线程安全性是不可变对象的固有属性之一（不可变对象一定是线程安全的，可以安全地发布和共享），它们的不变性条件是由构造函数创建的（不可变对象只有一种状态，并且该状态由构造函数来控制），只要它们的状态不改变，那么这些不变性条件就能得以维持。<br>当满足以下条件时，对象才是不可变的：</p><ol><li>对象创建以后其状态就不能修改；</li><li>对象的所有域都是final类型；</li><li>对象是正确创建的（在对象的创建期间，this引用没有逸出）。</li></ol><p>对于不可变对象，不得不提的就为final关键字，它用来构造不可变对象，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。<br>但是要知道的是，不可变性并不等于将对象中所有的域声明为final类型就可以，就算声明为final，这个对象仍是可变的，因为final类型的域中可以保存可变对象的引用。<br>除了final，下面这些容器也可以创建不可变对象，Collections.unmodifiableXXX：Collection，List，Set，Map… 以及 Guava：ImmutableXXX：Collection，List，Set，Map…</p><h3 id="事实不可变对象"><a class="markdownIt-Anchor" href="#事实不可变对象"></a> 事实不可变对象</h3><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么称这种对象为事实不可变对象（Effectively Immutable Object）。<br>在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象，所以对于事实不可变对象，安全发布就足够了。</p><h3 id="可变对象"><a class="markdownIt-Anchor" href="#可变对象"></a> 可变对象</h3><p>对于可变对象，不仅在发布对象时需要使用同步（因为安全发布只能确保&quot;发布当时&quot;状态的可见性），而且在每次访问时同样需要使用同步来确保后续修改的操作的可见性。</p><h2 id="安全发布对象"><a class="markdownIt-Anchor" href="#安全发布对象"></a> 安全发布对象</h2><p>所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的。<br>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有同步。<br>可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程都必须使用同步。要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。<br>下面是一个不安全的发布例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不安全的发布</span><br><span class="line">public Holder holder;</span><br><span class="line"></span><br><span class="line">public void initialize() &#123;</span><br><span class="line">    holder = new Holder(43);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在可见性问题，其他线程看到的Holder对象可能处于不一致状态，这种不正确的发布导致其他线程看到尚未创建完成的对象。在未被正确发布的对象中存在两个问题：</p><ol><li>除了发布对象的线程外，其他线程可能看到的Holder域是一个失效值，可能是一个空引用或者一个之前的旧值；</li><li>线程看到Holder 引用的值是最新的，但Holder状态的值确实失效的。</li></ol><p>一个正确构造的对象可以通过以下方式来安全地发布：</p><ol><li>在静态初始化函数中初始化一个对象引用；</li><li>将对象的引用保存到volatile类型的域中或者AtomicReferance对象中；</li><li>将对象的引用保存在某个正确构造的对象的final类型域中；</li><li>将对象的引用保存到一个由锁保护的域中。</li></ol><p>其中需要对第一项进行以下解释，静态初始化器（例如静态代码块）由JVM在类的初始化阶段执行，由于在JVM的内部存在着同步机制，因此通过这种方式初始化的任何对象都是可以被安全的发布。<br>在线程安全容器内部的同步意味着，在将某个对象放入到某个容器，将满足上述最后一条请求。线程安全库中的容器类提供了以下的安全发布保证：</p><ol><li>通过将一个键或者值放入Hashtable，synchronizedMap或ConcurrentMap中，可以安全地将它发布给任何访问它的线程（无论是直接访问还是迭代器访问）；</li><li>通过将某个元素放入Vector，CopyOnWriteArrayList，CopyOnWriteSet，synchronizedList，synchronizedSet中，可以安全地将它安全地发布任何从这些容器中访问该元素的线程；</li><li>通过将某个元素放入BlockingQueue，ConcurrentLinkedQueue，可以安全地将它安全地发布任何从这些容器中访问该元素的线程。</li></ol><p>如果对象在构造后可以修改，那么安全发布只能确保&quot;发布当时&quot;状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全的共享可变对象，这些对象就必须被安全地发布，并且必须时线程安全的或者由某个锁保护起来。</p><p>综上，对象的发布需求取决于它的可变性，可以概括为：</p><ol><li>不可变对象可以通过任何机制来发布；</li><li>事实不可变对象必须通过安全方式来发布；</li><li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>在并发程序中使用和共享对象时，可以使用一下一些使用的策略：</p><ol><li>线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改，常见的线程封闭为使用本地变量；</li><li>只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象；</li><li>线程安全共享：线程安全共享对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。</li><li>保护对象：被保护的对象只能通过持有特定的锁来访问。保护的对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定的锁保护的对象。</li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>先检查再执行：if(condition(a)) {handle(a)};  即使对象a和b都是线程安全对象，但是这种先检查再执行的操作是线程不安全的，因为这种操作不属于原子性操作。</li><li>遍历（迭代器遍历，foreach遍历，因为foreach是一种实际使用迭代器实现的语法糖）Vertor，ArrayList等，不能同时进行添加和删除操作。<br>具体解析见：<a href="https://www.cnblogs.com/kobelieve/p/10626473.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/kobelieve/p/10626473.html</a></li><li>Java 非同步容器：HashMap，HashSet，ArrayList，StringBuilder等。</li><li>Java同步容器：Vector，Stack，HashTable（Key，Value不能同时为空），Collections.synchronizedXXX(List，Set，Map)。</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] 《Java编程实战》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可见性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可见性&quot;&gt;&lt;/a&gt; 可见性&lt;/h2&gt;
&lt;p&gt;可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。&lt;br&gt;
在多线程下，面临一个问题就是，无法确保执行读操作的线程能适
      
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.huangbin.fun/categories/Concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://www.huangbin.fun/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/经典排序算法.html</id>
    <published>2020-05-29T14:41:32.000Z</published>
    <updated>2020-11-23T12:57:35.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述"><a class="markdownIt-Anchor" href="#排序算法概述"></a> 排序算法概述</h2><h3 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h3><ol><li><p>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；</p></li><li><p>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p></li></ol><p>以下是常用的十一种排序算法：</p><img src="/经典排序算法/totalSort.png" title="totalSort"><h3 id="算法时间复杂度"><a class="markdownIt-Anchor" href="#算法时间复杂度"></a> 算法时间复杂度</h3><img src="/经典排序算法/time.png" title="time"><h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3><ol><li>稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ol><h2 id="排序算法实现"><a class="markdownIt-Anchor" href="#排序算法实现"></a> 排序算法实现</h2><h3 id="公共代码实现"><a class="markdownIt-Anchor" href="#公共代码实现"></a> 公共代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 交换两个元素值</span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 得到最大值</span><br><span class="line">private int getMaxValue (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (maxValue &lt; nums[i]) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最小值</span><br><span class="line">private int getMinValue (int[] nums) &#123;</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (minValue &gt; nums[i]) &#123;</span><br><span class="line">           minValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#冒泡排序bubble-sort"></a> 冒泡排序（Bubble Sort）</h3><ol><li><p>概述<br>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;数列的顶端。</p></li><li><p>算法思路</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；</li><li>针对所有的元素重复以上的步骤，最后已排序好的元素不需要再次比较；</li><li>重复步骤1~3，直到排序完成。</li></ol> <img src="/经典排序算法/bubbleSort.gif" title="bubbleSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bubbleSort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 当最外层循环遍历完毕, 则代表着数组有序</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 从头开始依次两两比较, 比较结束条件为len - i - 1</span><br><span class="line">        for(int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">            // 比较相邻的两个元素, 若前者大于后者, 则进行交换</span><br><span class="line">            if (nums[j] &gt; nums[j + 1])&#123;</span><br><span class="line">                swap(nums, j + 1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序quick-sort"><a class="markdownIt-Anchor" href="#快速排序quick-sort"></a> 快速排序（Quick Sort）</h3><ol><li><p>概述<br>快速排序的基本思想是：通过一趟排序以基准元素为基础将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序（分别进行划分），整个排序过程可以递归进行，使整个数据变成有序序列。</p></li><li><p>算法思路</p><ol><li>数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，该位置称为 K ；</li><li>根据第2步得到的基准元素位置 K，递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列进行1~2步的分区操作。</li></ol> <img src="/经典排序算法/QuickSort.gif" title="QuickSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    quickSort(nums, 0, len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 - left &gt;= right时</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 2. 递进操作</span><br><span class="line">        // 递归排序分区, 返回基准元素所在位置</span><br><span class="line">        int partitionIndex = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, partitionIndex - 1);</span><br><span class="line">        quickSort(nums, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 选择最左边的数为基准元素</span><br><span class="line">    int pivot = left;</span><br><span class="line">    // 以基准元素为比较元素开始分区操作</span><br><span class="line">    int index = pivot + 1;</span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行 </span><br><span class="line">    index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, pivot, index - 1);</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排序优化<br>快速排序的运行时间与划分是否对称有关。最坏情况下，每次划分过程产生两个区域分别包含n-1个元素和1个元素，其时间复杂度会达到O(n^2)。在最好的情况下，每次划分所取的基准都恰好是中值，即每次划分都产生两个大小为n/2的区域。此时，快排的时间复杂度为O(nlogn)。所以基准的选择对快排而言至关重要。<br>如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。<br>为了解决上述问题，可以采用随机基准的方式来应对上述特殊情况。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">     </span><br><span class="line">    // 将随机选择一个元素作为基准元素</span><br><span class="line">    // Math.Random()函数能够返回带正号的double值, 该值大于等于0.0且小于1.0</span><br><span class="line">    int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 将随机索引处的元素与left处进行交换</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量index，其[pivot + 1,index)范围内的元素小于基准元素</span><br><span class="line">    int index = left + 1;</span><br><span class="line"></span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行</span><br><span class="line">    // index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    // 2. 定义变量i，其[index, i - 1]范围内的元素大于基准元素</span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        // 3. 触发index变量转移条件，保证循环不变量定义正确</span><br><span class="line">        if (nums[i] &lt; nums[left]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, left, index - 1);</span><br><span class="line">    // 4. 返回结果</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二路快速排序quick-sort-2-ways"><a class="markdownIt-Anchor" href="#二路快速排序quick-sort-2-ways"></a> 二路快速排序（Quick Sort 2 Ways）</h3><ol><li><p>概述<br>二路快速排序的时间和空间复杂度同随机化快速排序。 但是对于有大量重复元素的数组，如果使用随机化快速排序效率是非常低的，导致 partition 后大于基点或者小于基点数据的子数组长度会极度不平衡，甚至会退化成 O(n^2)时间复杂度的算法，对这种情况可以使用双路快速排序算法。</p></li><li><p>算法思路<br>双路快速排序算法是随机化快速排序的改进版本，partition 过程使用两个索引值（i、j）用来遍历数组，将  &lt;= V 的元素放在索引i所指向位置的左边，而将 &gt;= V的元素放在索引 j 所指向位置的右边，V 代表标定值，平衡左右两边子数组。</p> <img src="/经典排序算法/quickSort2.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void quickSort2ways (int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件</span><br><span class="line">    if (left &gt; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int index = partition2(nums, left, right);</span><br><span class="line">    quickSort3Ways(nums, left, index - 1);</span><br><span class="line">    quickSort3Ways(nums, index + 1, right);</span><br><span class="line"></span><br><span class="line">    // 3. 递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partition2(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 随机选择一个基准</span><br><span class="line">    int randomIndex = (int) (Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 交换left和randomIndex的位置</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line">    int v = nums[left];</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量i, 其在[left + 1, i)范围中的元素 &lt;= v</span><br><span class="line">    //    定义变量j, 其在(j, right] 范围中的元素 &gt;= v</span><br><span class="line">    int i = left + 1, j = right;</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量i改变条件</span><br><span class="line">        while (i &lt;= right &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量j改变条件</span><br><span class="line">        while (j &gt;= left + 1 &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 循坏退出条件</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // 交换 i, j索引处元素</span><br><span class="line">        // 此时若 nums[i] == nums[j] == v, 也会进行交换</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放置到正确位置上</span><br><span class="line">    swap(nums, left, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三路快速排序quick-sort-3-ways"><a class="markdownIt-Anchor" href="#三路快速排序quick-sort-3-ways"></a> 三路快速排序（Quick Sort 3 Ways）</h3><ol><li><p>概述<br>三路快速排序时间和空间复杂度同随机化快速排序。三路快速排序算法是使用三路划分策略对数组进行划分，对处理大量重复元素的数组非常有效提高快速排序的过程。它增加了处理等于基准元素值的逻辑，将所有等于基准元素的值集中在一起。</p></li><li><p>算法思路<br>三路快速排序是双路快速排序的进一步改进版本，三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，等于 v 的数据在下次递归中不再需要排序，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优。</p> <img src="/经典排序算法/quickSort3.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort3Ways(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 left &gt;= right</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 随机选择一个基准</span><br><span class="line">        int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        int curr = nums[left];</span><br><span class="line"></span><br><span class="line">        // 1. 定义lt为[left + 1, lt]中的元素小于curr</span><br><span class="line">        int lt = left;</span><br><span class="line">        // 1. 定义gt为[gt, r]中的元素大于curr</span><br><span class="line">        int gt = right + 1;</span><br><span class="line">        // 1. 定义[lt + 1, i) 中的元素等于curr</span><br><span class="line">        int i = left + 1;</span><br><span class="line"></span><br><span class="line">        // 2. 递归结束条件, i碰到了gt边界</span><br><span class="line">        while (i &lt; gt) &#123;</span><br><span class="line">            if (nums[i] &lt; curr) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                // 3. 触发变量</span><br><span class="line">                swap(nums, lt, i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (nums[i] &gt; curr) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums, i, gt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将基准元素放置在正确位置上</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line"></span><br><span class="line">        // 对[left, lt - 1] 进行处理</span><br><span class="line">        quickSort3Ways(nums, left, lt - 1);</span><br><span class="line">        // 对[gt, right] 进行处理</span><br><span class="line">        quickSort3Ways(nums, gt, right);</span><br><span class="line"></span><br><span class="line">        // 4. 返回结果 - 暂无</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入排序insertion-sort"><a class="markdownIt-Anchor" href="#插入排序insertion-sort"></a> 插入排序（Insertion Sort）</h3><ol><li><p>概述<br>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>算法思路</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出有序序列的下一个元素，作为待插入的新元素，在已经排序的元素序列中从后向前扫描；</li><li>如果有序序列中的元素大于新元素，则从后向前继续比较有序序列中的元素；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol> <img src="/经典排序算法/InsertionSort.gif" title="InsertionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void insertSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 从下标为1的元素开始选择合适的位置插入, 因为下标0默认是有序的</span><br><span class="line">    for(int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        // 需要插入的新元素</span><br><span class="line">        int curr = nums[i];</span><br><span class="line">        // 从已经排序的序列的最右-&gt;左开始比较</span><br><span class="line">        int j = i;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; curr) &#123;</span><br><span class="line">            // 进行数组的移动</span><br><span class="line">            nums[j] = nums[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到了插入位置</span><br><span class="line">    if(j != i)</span><br><span class="line">        nums[j] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序shell-sort"><a class="markdownIt-Anchor" href="#希尔排序shell-sort"></a> 希尔排序（Shell Sort）</h3><ol><li><p>概述<br>希尔排序是简单插入排序的改进版，是基于插入排序的以下两点性质而提出的一种排序方法：</p><ol><li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  —&gt; 希尔排序会优先比较距离较远的元素，从而达到更远的移动距离；</li><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 —&gt; 希尔排序在整个序列&quot;基本有序&quot;的时候，直接采用插入排序来进行一次比较。<br>希尔排序又叫缩小增量排序。</li></ol></li><li><p>算法思路</p><ol><li>选择一个增量序列t1，t2，…，ti，tj，….tk，其中ti&gt;tj，tk=1，增量序列在排序的过程中不断递减；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各个子序列进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol> <img src="/经典排序算法/ShellSort.gif" title="ShellSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    int gap = 1;</span><br><span class="line">    </span><br><span class="line">    // 选择合适的初始值, 如果直接用len/3的话, 后面可能无法递减为1</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;  // 1, 4, 13, 40, 121....  // Tk, Tk-1,.....,T1</span><br><span class="line">    </span><br><span class="line">    // 对序列进行k趟排序</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        // 从下标为gap的元素(从后往前)开始选择合适的位置插入, 因为子序列的第一个元素默认是有序的</span><br><span class="line">        for(int i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            int j = i - gap;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; nums[j] &gt; cur) &#123;</span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将新元素放置到正确位置, j + gap是因为while循环中最后进行了一次j = j - gap</span><br><span class="line">            nums[j + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        // 缩小增量</span><br><span class="line">        gap = gap / 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="选择排序shell-sort"><a class="markdownIt-Anchor" href="#选择排序shell-sort"></a> 选择排序（Shell Sort）</h3><ol><li><p>概述<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li><li><p>算法思路</p><ol><li>初始未排序区域为nums[0…nums.length - 1]</li><li>从未排序区域找到元素值最小的元素，将它和数组中第一个元素交换位置；未排序区域更新为nums[1…nums.length - 1]，从该区域找到第二个元素值最小的元素，将它和数组中第二个元素交换位置，如此反复，直到整个数组排序完成。</li></ol> <img src="/经典排序算法/SelectionSort.gif" title="SelectionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void selectionSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 将nums[i] 与 nums[i+1..len - 1]中最小的元素交换</span><br><span class="line">        int min = i;</span><br><span class="line">        // 从无序区域找到一个最小的元素</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序heap-sort"><a class="markdownIt-Anchor" href="#堆排序heap-sort"></a> 堆排序（Heap Sort）</h3><ol><li><p>概述<br>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></li><li><p>算法思路</p><ol><li>初始化堆：堆将待排序序列构造成一个大顶堆/小顶堆（升序 - 大顶堆，降序 - 小顶堆），此时，整个序列的最大值就是堆顶的根节点；</li><li>将根节点与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n 个元素的次大值；</li><li>如此反复执行，便能得到一个有序序列。</li></ol> <img src="/经典排序算法/HeapSort.gif" title="HeapSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 堆排序算法</span><br><span class="line">public void heapSort(int[]arr)&#123;</span><br><span class="line">     //1.初始化堆,从最后一个非叶子节点从右向左,从下向上依次进行&quot;堆化&quot;</span><br><span class="line">    for(int i=(arr.length/2)-1; i&gt;=0; i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.依次交换栈顶元素和末尾元素和重新调整堆</span><br><span class="line">    for(int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);</span><br><span class="line">        adjustHeap(arr,0,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整堆</span><br><span class="line">public void adjustHeap(int[]arr,int i,int len)&#123;</span><br><span class="line">    //取出当前元素</span><br><span class="line">    int curr = arr[i];</span><br><span class="line">    //从当前节点的左节点开始比较</span><br><span class="line">    for(intk=i*2+1;k&lt;len;k=k*2+1)&#123;</span><br><span class="line">        //若右节点存在且大于左节点,则切换到左节点进行操作</span><br><span class="line">        if(k+1&lt;len&amp;&amp;arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">            k=k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子节点的值大于父节点</span><br><span class="line">        if(arr[k]&gt;curr)&#123;</span><br><span class="line">            //交换元素值</span><br><span class="line">            arr[i]=arr[k];</span><br><span class="line">            //以孩子节点作为父节点继续进行调整</span><br><span class="line">            i=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i]=curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><ol><li><p>概述<br>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li>自上而下的递归；</li><li>自下而上的迭代。</li></ol></li><li><p>算法思路</p><ol><li><p>递归法<br>在每一层递归上分为三个步骤：<br>a. 分解（Divide）：将n个元素分为 n / 2 个元素的子序列，然后一直递归分解，直到只剩一个元素；<br>b. 解决（Conquer）：用合并排序法对两个子序列进行排序；<br>c. 合并（Combine）：合并两个已排序的子序列得到当前递归层的排序结果。</p></li><li><p>迭代法<br>先归并那些微型的数组，然后再成对归并得到的子数组，如此这般，直到将整个数组归并完成。<br>a. 先进行两两归并（归并子数组长度为1），得到一个&quot;部分有序&quot;（两两相邻有序）的数组；<br>b. 然后对第一步得到的数组进行四四归并（将两个大小为2的数组归并为一个有四个元素的子数组），又得到一个相比于第一步更加有序的数组；<br>c. 然后是八八归并，一直归并下去，直到整个数组有序；<br>d. 注意对最后一个子数组的处理，其长度可能小于归并的默认长度。</p></li></ol> <img src="/经典排序算法/MergeSort.gif" title="MergeSort"></li><li><p>代码实现</p><ol><li><p>公共代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将nums数组进行归并, 将nums[start..end]和data[mid+1, end]归并成一个更大的有序数组, 其中nums[start..mid],</span><br><span class="line">// nums[mid+1,end]已有序</span><br><span class="line">private void mergeResult(int[] nums, int start, int mid, int end) &#123;</span><br><span class="line">    int i = start, j = mid + 1, len = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 归并所需要的辅助数组</span><br><span class="line">    int[] temp = new int[len];</span><br><span class="line"></span><br><span class="line">    // 辅助数组</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        temp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在temp数组上进行大小比较, 然后temp中的值放回到nums中,返回过程中进行排序</span><br><span class="line">    // 比较方法 - nums[start..mid]和data[mid+1, end]依次开始比较</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        // nums[start..mid]的数据排序完成</span><br><span class="line">        if (i &gt; mid) &#123;</span><br><span class="line">            nums[k] = temp[j++];</span><br><span class="line">        // nums[mid + 1..end]的数据排序完成</span><br><span class="line">        &#125; else if (j &gt; end) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else if (temp[i] &lt; temp[j]) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            nums[k]= temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    merge(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge (int[] nums, int start, int end) &#123;</span><br><span class="line">    // 1. 递归结束条件 -只有一个元素</span><br><span class="line">    if (start == end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int mid = (start + end) / 2;</span><br><span class="line">    // 对左边进行排序</span><br><span class="line">    merge(nums, start, mid);</span><br><span class="line">    // 对右边进行排序</span><br><span class="line">    merge(nums, mid + 1, end);</span><br><span class="line">    // 对上述排序结果进行合并</span><br><span class="line">    mergeResult(nums, start, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // sz表示子数组的长度</span><br><span class="line">    for (int sz = 1; sz &lt; len; sz = sz + sz) &#123;</span><br><span class="line">        // 以sz为基准, 把nums分为若干个长度为2sz的子数组, 对其进行归并排序                                  </span><br><span class="line">        //  若下一个子数组的起始位置大于等于len-sz则表示剩余的元素小于sz个，则不需要再进行合并排序了（上一个归并已经处理了）</span><br><span class="line">        for (int lo = 0; lo &lt; len - sz; lo += sz + sz) &#123;</span><br><span class="line">            // 后面的Math.min(lo + sz + sz - 1, len - 1) 是为了保证对未能组成两个归并数组的处理</span><br><span class="line">            mergeResult(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, len - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="多路归并排序merge-sort"><a class="markdownIt-Anchor" href="#多路归并排序merge-sort"></a> 多路归并排序（Merge Sort）</h3><p>插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要外部排序算法来解决。<br>外部排序算法由两个阶段构成：</p><ol><li>按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为&quot;归并段&quot;或者&quot;顺段&quot;），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li><li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li></ol><p>对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。<br>想要达到减少访问外存的次数（归并次数）从而提高算法效率的目的，可以从两个角度实现：</p><ol><li>增加 k-路平衡归并中的 k 值 — 多路归并算法；</li><li>尽量减少初始归并段的数量 m，即增加每个归并段的容量 — 置换-选择排序算法；</li></ol><h3 id="计数排序counting-sort"><a class="markdownIt-Anchor" href="#计数排序counting-sort"></a> 计数排序（Counting Sort）</h3><ol><li><p>概述<br>在于将输入的数据值转化为键（数组索引）存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。<br>额外开辟的数组空间的长度为输入数组的最大值+1，这也意味着计数排序对于数据范围很大的输入数据，它需要很大的空间来用来进行计数，所以计数排序是一种典型的空间换时间的算法。</p></li><li><p>算法思路</p><ol><li>找出待排序数组的最大值，开辟一个额外数组，其长度为最大值+1；</li><li>遍历待排序数组，计算数组中每个元素的出现次数，并且将元素值作为索引，出现的次数作为值存入到额外数组中；</li><li>遍历额外数组，若其元素值（出现次数）大于0，则将其索引作为元素值回写到待排序数组中，并且出现次数-1，直到完成排序；</li></ol> <img src="/经典排序算法/CountSort.gif" title="countSort"><p>如果按照上述的算法（朴素的计数排序）思路来进行排序的话，还存在着如下两个问题：</p><ol><li><p>额外数组在某些情况下利用率低。例如待排序数组范围 90 ~ 99，那么额外数组的长度为99+1，这造成前0~89个数组空间的浪费。<br>要解决这个问题，可以使用（maxValue - minValue）+ 1作为额外数组的长度，以minValue作为偏移量，nums[i] - minValue来定位nums[i] 在额外数组中的位置；</p></li><li><p>朴素的计数排序不是稳定的排序，它只是简单遍历的额外数组，然后对于值不为0的元素输出其下标，若待排序数组有nums[i] == nums[j]（i &lt; j），排序之后，nums[i] == nums[j]（i &gt; j）。若是单纯的进行整数排序，排序之后交换了位置也没关系，但是如果面临现实业务（比如考试分数的排序）中，就行不通了。<br>要解决这个问题，需要对额外数组进一步操作，依次将当前位置的值和前一个位置的值相加（代码描述为：countNums[i] += countNums[i - 1]），这样额外数组中存储的值代表了元素的最终排序位置。</p> <img src="/经典排序算法/countSort.png" title="countSort"><p>输入待排序数组为[4,0,9,5,5]，经过计数之后得到上述图片的上半部分，进行处理后得到下半部分，那么下标为9的的值为5，则代表中元素9最终排序的位置为5。</p></li></ol></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[maxValue + 1];</span><br><span class="line"></span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历额外数组countNums, 将其索引回写到nums数组中</span><br><span class="line">    int sortIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        while (countNums[i] &gt; 0) &#123;</span><br><span class="line">            nums[sortIndex++] = i;</span><br><span class="line">            countNums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码如下:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 得到最小值</span><br><span class="line">    int minValue = getMinValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[(maxValue - minValue) + 1];</span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值 - 偏移量(minValue)作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value - minValue]++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // countNums[nums[i] - minValue]为 nums[i]的最终位置</span><br><span class="line">        sortArray[countNums[nums[i] - minValue] - 1] = nums[i];</span><br><span class="line">        countNums[nums[i] - minValue]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums = sortArray.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><ol><li><p>概述<br>桶排序是计数排序的升级版，降低了额外空间的大小和提高了额外空间的利用率。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定，对于桶的内部，选择何种内部排序算法也对性能有着重要的影响。为了使桶排序更加高效，需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ol></li><li><p>算法思路</p><ol><li>根据待排序数组中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数<br>，设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>选择一种排序算法，对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol> <img src="/经典排序算法/bucketSort.png" title="bucketSort"> <img src="/经典排序算法/bucketSort2.png" title="bucketSort2"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bucketSort (int[] nums) &#123;</span><br><span class="line">    bucketSort(nums, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void bucketSort(int[] nums, int bucketSize) &#123;</span><br><span class="line">    // 根据最大值和最小值计算需要的桶的个数 - 映射规则(可以选择不同的映射规则)</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125; else if (value &lt; minValue) &#123;</span><br><span class="line">            minValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到所需桶个数</span><br><span class="line">    int bucketCount = (int) (Math.floor((maxValue - minValue) / bucketSize) + 1);</span><br><span class="line">    // 创建桶</span><br><span class="line">    int[][] buckets = new int[bucketCount][0];</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到桶中</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int index = (int) Math.floor((nums[i] - minValue) / bucketSize);</span><br><span class="line">        buckets[index] = numsAppend(buckets[index], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int[] bucket : buckets) &#123;</span><br><span class="line">        if (bucket.length &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对每个桶中元素进行排序 - 采用插入排序, 可使用其他排序算法</span><br><span class="line">        bucket = insertSort(bucket);</span><br><span class="line">        // 将已经排序完的元素回写到数组中</span><br><span class="line">        for (int value : bucket) &#123;</span><br><span class="line">            nums[index++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将数据添加到桶中</span><br><span class="line">private int[] numsAppend (int[] bucketNums, int value) &#123;</span><br><span class="line">    bucketNums = Arrays.copyOf(bucketNums, bucketNums.length + 1);</span><br><span class="line">    bucketNums[bucketNums.length - 1] = value;</span><br><span class="line">    return bucketNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort）</h3><ol><li><p>概述<br>基数排序是一种非比较型整数排序算法，其原理是将整数按位数（通常是低位-&gt;高位进行分割）切割成不同的数字，然后将分割之后的数字分配到不同桶中，对桶中元素进行排序，然后依次输出桶中元素，接着按照下一个位数进行分割，反复进行上述操作，直到整个数组有序。<br>若待排序数组分割之后的位数的数值范围较小，可以不利用桶来收集分割之后的元素，可以直接采用计数排序。比如对于整数的基数排序，只需要分配固定十个桶（位数范围0~9），则直接可以基于计数排序进行。<br>基数排序既可以从高位优先进行排序（Most Significant Digit first，简称MSD），也可以从低位优先进行排序（Least Significant Digit first，简称LSD）。</p></li><li><p>算法思路</p><ol><li>得到待排序数据中的最大值，并得到最大值的位数digit；</li><li>从低位到高位依次待排序数组进行计数排序，计数排序的次数为digit；</li><li>重复第二步，直到整个数组有序。</li></ol> <img src="/经典排序算法/RadixSort.gif" title="RadixSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void radixSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值的长度(位数), 通过这个就知道需要进行几次基数排序</span><br><span class="line">    int maxDigit = getMaxDigit(nums);</span><br><span class="line">    sort(nums, maxDigit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sort (int[] nums, int maxDigit) &#123;</span><br><span class="line">    int exp = 1;</span><br><span class="line">    // 最大值的位数为maxDigit, 则代表要进行maxDigit次计数排序</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, exp *= 10) &#123;</span><br><span class="line">        countingSort(nums, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对基数排序的每位进行计数排序</span><br><span class="line">private static void countingSort (int[] nums, int exp) &#123;</span><br><span class="line">    // 开辟额外数组存在每个数字出现次数</span><br><span class="line">    int[] countNums = new int[10];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[(value / exp) % 10]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        sortArray[countNums[(nums[i] / exp) % 10] - 1] = nums[i];</span><br><span class="line">        countNums[(nums[i] / exp) % 10]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为需要基于nums再进行若干次计数排序, 所以将sortArray 赋值给nums</span><br><span class="line">    for (int i = 0; i &lt; sortArray.length; i++) &#123;</span><br><span class="line">        nums[i] = sortArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最大值的位数</span><br><span class="line">private static int getMaxDigit (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (maxValue &lt; value)</span><br><span class="line">        maxValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    // 得到最大值的位数</span><br><span class="line">    int length = 0;</span><br><span class="line">    while (maxValue != 0) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        maxValue = maxValue / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect</a><br>[2] <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/onepixel/articles/7674659.html</a><br>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#排序算法概述&quot;&gt;&lt;/a&gt; 排序算法概述&lt;/h2&gt;
&lt;h3 id=&quot;算法分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法分类&quot;&gt;&lt;/a&gt; 算法
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>重新认识时间复杂度</title>
    <link href="http://www.huangbin.fun/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html"/>
    <id>http://www.huangbin.fun/重新认识时间复杂度.html</id>
    <published>2020-05-19T13:40:22.000Z</published>
    <updated>2020-11-19T14:39:43.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大o符号表示法"><a class="markdownIt-Anchor" href="#大o符号表示法"></a> 大O符号表示法</h2><p>我们假设计算机运行一行基础代码需要执行一次运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(void)&#123;</span><br><span class="line">    printf(&quot;Hello,World!\n&quot;);  //需要执行1次</span><br><span class="line">    return 0;  //需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面这段代码执行的总运算次数为2次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;  //需要执行(n+1)次, 从0 -&gt; n</span><br><span class="line">        printf(&quot;Hello,World!\n&quot;);  //需要执行n次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行的总次数为 n + 1 + n + 1次。<br>使用 T(n) 来表示算法需要执行的总的运算次数，T(n) 为一个关于输入次数n的函数。    例如上面的两段代码中：第一段代码 T(n) = 2； 第二段代码 T(n) = 2n + 2。<br>但是仅仅有T(n) 是不够的，为了估算算法需要的运行时间和简化算法分析，再一次引入时间复杂度的概念。</p><blockquote><p>定义：存在一个常数C和f(n)，使得当n &gt;= C时，有T(n) &lt;= f(n)，表示为T(n) = O(f(n))</p></blockquote><p>就那T(n) = 2n 举例来说，存在C=2，且 n&gt;=C时，总有f(n) = 2n+1 &gt; T(n) = 2n，我们可以说说f(n)的增长速度是大于或等于T(n)的，也就是说f(n)为T(n)的上界，我们就可以用f(n)的增长速度来度量T(n)的增长速度，可以表示为 T(n) = O(f(n)) = O(2n + 1)，所以我们可以说这个算法的时间复杂度为O(f(n)) = O(2n+1)，O(f(n))表示运行算法所需要执行的指令数和f(n)成正比，n表示数据规模。<br>这个f(n) 并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间随着输入n的增大的增长变化趋势，所以常数1 和 与n相乘的常数2 对增长速度的影响不明显，所以可以省略，所以时间复杂度可以简化为 O(n)。</p><img src="/重新认识时间复杂度/Defination.jpg" title="Defination"><p>显然T(n) = O(f(n)) = O(3n+1)，T(n) = O(f(n)) = O(n^2)…… 都是成立，但是T(n) = O(f(n)) = O(2n+1)的增长速度相比其他是更加接近的，所以选择了它。<br>上面所提到的T(n) = O(f(n)) 也称为&quot;大O符号表示法&quot;。<br>下面可以用一个图来展示时间复杂度随着输入n的增大的增长变化趋势。从下图可知，常数对于时间复杂度的决定性总是微乎其微的，并且描述了一个事实，当数据规模n到达了某个零界点之后，时间复杂度低的算法的执行效率一定比时间复杂度高的执行效率更高。</p><img src="/重新认识时间复杂度/comparation.png" title="comparation"><h2 id="时间复杂度推导规律"><a class="markdownIt-Anchor" href="#时间复杂度推导规律"></a> 时间复杂度推导规律</h2><ol><li>推导T(n)<ol><li>对于一个循环，假设循环体的运算执行次数为 n ，循环次数为 m，则这个循环的总执行次数为 T(n) = n * m。</li><li>对于多个循环，假设循环体的运算执行次数为 n，各个循环的循环次数分别是a，b， c…，则这个循环的总执行次数为T(n) =  n * a * b * c…。分析的时候应该由里向外分析这些循环。</li><li>对于顺序执行的语句或者算法，总的运算执行次数等于其中最大的运算执行次数。</li><li>对于条件执行的语句或者算法，总的运算执行次数等于其中路径中最大的运算执行次数。<br>综合说：从内向外进行分析，如果遇到函数调用，进行调用函数进行分析。</li></ol></li><li>T(n) -&gt; O(f(n))<br>假设我们已经得到了T(N)，即一个算法的执行次数，那么可以通过以下几个规律来简单推导：<ol><li>常数项对于函数增长速度的影响并不明显，忽略常数项。<br>T(n) = c = O(1)，c为常数；<br>T(n) = n + 1 = 1 = O(n)；</li><li>高次项对于函数的增长速度的影响是最大的，保留最高次项，忽略低次项，若最高次项有常数相乘，忽略它；<br>T(n) = n^3 + n^2 + n = O(n^3)；<br>T(n) = 3 n^3 = O(n^3)；<br>Ps：忽略低次项只适合于规模n属于同一个的情况。若某个时间复杂度为O(logn + m)，n和m属于两个不同的数据规模，则不可忽略其他任何一部分。</li></ol></li></ol><p>综合说：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。</p><h2 id="时间复杂度实例"><a class="markdownIt-Anchor" href="#时间复杂度实例"></a> 时间复杂度实例</h2><ol><li><p>O(1)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum(int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for(int i = 0; i &lt;= n; i++) </span><br><span class="line">        result += i;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">void reverse(String s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    for(int i = 0; i &lt; n / 2; i++)</span><br><span class="line">        swap(s.charAt(i), s.charAt(n - 1 - i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n^2)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void selectionSort(int[] arr, int n) &#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">        for(int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内层if语句的执行次数为 (n - 1) +  (n - 2) +  (n - 3) …. + 0 = (0 + n - 1) * n / 2 =&gt; O(n^2)。</p></li><li><p>O(logn)时间复杂度实例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int n, int target) &#123;</span><br><span class="line">    int l = 0, r = n - 1;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (arr[mid] == target) return mid;</span><br><span class="line">        if (arr[mid] &gt; target) r = mid - 1;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>① 在n个元素中查找<br>② 在 n / 2个元素中查找<br>③ 在 n / 4 个元素中查找<br>…….<br>④ 在1个元素中查找<br>n经过几次&quot;除以2&quot;操作后，等于1？ log(2)n = O(logn)<br>也可以这样计算，设操作次数为t，则 2^t &lt;= n，t = log(2)n，得出为 O(logn)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String intToString(int num) &#123;</span><br><span class="line">    String s = &quot;&quot;;</span><br><span class="line">    while(num &gt; 0) &#123;</span><br><span class="line">        s += &quot;0&quot; + num % 10;</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    s = reverse(s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>n经过几次&quot;除以10&quot;操作后，等于1？ log(10)n = O(logn)<br>为什么log(10)n和 log(2)n 的时间复杂度都可以视为O(logn)呢？ 主要是因为对数换底公式：</p> <img src="/重新认识时间复杂度/fomula.png" title="fomula"><p>所以具体对数底是如何并不重要。</p></li><li><p>O(nlogn)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hello (int n) &#123;</span><br><span class="line">    for(int sz = 1; sz &lt; n; sz += sz)</span><br><span class="line">        for(int i = 1; i &lt; n; i++) </span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(sqrt(n))时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isPrime(int n) &#123;</span><br><span class="line">    for(int x = 2; x * x &lt;= n; x++) &#123;</span><br><span class="line">        if(n % x == 0)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>X初始化为2，每次增加1，直到遍历到sqrt(n)就退出循环。</p></li><li><p>递归调用时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int l, int r, int target) &#123;</span><br><span class="line">    if(l &gt; r)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        if (arr[mid] == target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (arr[mid] &gt; target) </span><br><span class="line">            return binarySearch(arr, l, mid - 1, target);</span><br><span class="line">        else </span><br><span class="line">            return binarySearch(arr, mid + 1, r, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，最多只进行一次递归调用，这时我们需要计算中递归调用的最大深度是多少，由实例4可知，由n-&gt;1，递归的最大深度为logn，则时间复杂度为O(logn)。<br>总结如下：如果在递归函数中，只进行一次递归调用，递归深度为depth，在每个递归函数中，时间复杂度为T，则总体的时间复杂度为O(T*depth)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    if (n == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    return f(n - 1) + f(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，会进行两次递归调用，此时应该更加关注的是计算调用的次数，通常可以通过画递归树的方式来计算调用次数。时间复杂度为O(2^n)。</p> <img src="/重新认识时间复杂度/tree.png" title="tree"><p>递归树层数为4，2^0 + 2^1+ 2^2 + 2^3 = 2^n -1 =15</p></li><li><p>均摊复杂度分析实例</p><p>例如对于Java中ArrayList数组，它是一个动态数组，此类的动态数组在每个的插入操作为O(1)的时间复杂度，但是当超过当前数组容量时会进行数组扩容操作，扩容操作的时间复杂度为O(n)，但是就算在插入操作中存在着O(n)时间复杂度的扩容操作，也不能够说插入操作的时间复杂度为O(n)，它仍然是O(1)的时间复杂度，因为O(n)时间复杂度的扩容操作均摊到了前面n次的O(1)操作之中了。</p> <img src="/重新认识时间复杂度/resize.png" title="resize"><p>每个的删除操作为O(1)的时间复杂度，那么假设当剩余元素为当前数组容量的一半时会进行数组缩小操作，那么此时也可以使用如上所说明的均摊复杂度分析。</p> <img src="/重新认识时间复杂度/resize2.png" title="resize2"><p>但是如上可能会存在复杂度震荡问题，即当在数据扩容和缩小的零界点交替进行添加和删除操作会使得时间复杂度退化为O(n)。</p> <img src="/重新认识时间复杂度/resize3.png" title="resize3"></li><li><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符数组按照字典序排序，整个操作的时间复杂为？<br>解析：<br>假设最长的字符串长度为s；整个数组中有n个字符串。<br>对每个字符串排序时间复杂度为O(slogs)，将数组中的每一个字符串按照字母序排序：O(n<em>slogs)，将整个字符串数组按照字典序排序：O(s</em>nlogn)，其中s<em>nlogn为排序所需要的比较次数。<br>综上所述，整个时间复杂度为：O(n</em>slogs) + O(s<em>nlogn) = O(n</em>slogs + s<em>nlogn) =<br>O(ns</em>(logs + logn))</p></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li><p>&quot;O&quot;是渐进上界符号（Big-oh - 欧米可荣），用它评估算法的复杂度得到的只是问题规模充分大时的一个上界，但是这个定义是严格的学术定义，按照该定义来说，归并排序算法的时间复杂度是O(nlogn)，并且是O(n^2)，这种说法是正确的，因为O(n^2)也是满足条件的一个上界。但是通常来讲，我们使用&quot;O&quot;来表示算法执行的最低上界。</p></li><li><p>下图展示了不同时间复杂度随着数据规模n的增长的所需要执行指令数的增长速度。<img src="/重新认识时间复杂度/comparation2.png" title="comparation2"></p></li><li><p>数据规模的概念<br>如果想要在1s之内解决问题：<br>O(n^2) 的算法可以处理大约10^4级别的数据；<br>O(n)的算法可以处理大约10^8级别的数据；<br>O(nlogn)的算法可以处理大约10^7级别的数据。</p></li><li><p>空间复杂度<br>多开一个辅助数据：O(n)；多开一个辅助的二维数组：O(n^2)；多开常数空间：O(1)；递归调用具有空间代价</p></li></ol><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://www.jianshu.com/p/f4cca5ce055a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f4cca5ce055a</a><br>[2] <a href="https://blog.csdn.net/so_geili/article/details/53353593" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/so_geili/article/details/53353593</a><br>[3] <a href="https://coding.imooc.com/class/chapter/82.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/chapter/82.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大o符号表示法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大o符号表示法&quot;&gt;&lt;/a&gt; 大O符号表示法&lt;/h2&gt;
&lt;p&gt;我们假设计算机运行一行基础代码需要执行一次运算。&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>小小String对象大大奥秘</title>
    <link href="http://www.huangbin.fun/%E5%B0%8F%E5%B0%8FString%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%A4%A7%E5%A5%A5%E7%A7%98.html"/>
    <id>http://www.huangbin.fun/小小String对象大大奥秘.html</id>
    <published>2020-05-05T07:40:48.000Z</published>
    <updated>2020-05-06T11:05:00.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串？</h2><p>字符串是由引号所括起来的一系列字符序列。例如&quot;String&quot;，&quot;Hello&quot;就为一个字符串</p><h2 id="string-的不可变性"><a class="markdownIt-Anchor" href="#string-的不可变性"></a> String 的不可变性</h2><p>&quot;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何操作都会生成新的对象“。</p><ol><li>固定不变 - 从String 对象的源码中可以看出，String 类声明为 final，且它的属性和方法都被 final 所修饰</li><li>任何操作都会生成新对象 - String:: subString()，String::concat() 等方法都会生成一个新的String对象，不会在原对象上进行操作<br>从下面String源码部分中很容易得到上面的结论：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** String 类源码 */</span><br><span class="line">public final class String </span><br><span class="line">     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line">     *</span><br><span class="line">     * A String instance is written into an ObjectOutputStream according to</span><br><span class="line">     * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line">     */</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用一段代码来揭示这个过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String start = &quot;Hello&quot;;  // 1</span><br><span class="line">        String end = start.concat(&quot; World!&quot;); // 2</span><br><span class="line">          //String end = start + &quot; World!&quot;  </span><br><span class="line">        System.out.println(end); // 3</span><br><span class="line">             System.out.println(start); // 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">Hello World!</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>在这段代码中，没有改变任何对象。首先在第一个代码中，会在堆内存中创建一个新的String 对象，并把它的引用赋值给 start，接着在第二个调用String:: concat()方法对字符串进行拼接，<strong>此时会创建一个新的String 对象，该对象是&quot;Hello&quot; 和 “World” 的串联</strong>。就如String:: concat() 源码所示，第三个/四个代码的输出结果分别为：“Hello World!”, “World”。并且操作符 &quot; + &quot;完成了和String:: concat() 类似的事 - &gt; 操作符 “+” 算是一个语法糖，查看编译之后的字节码可以知道最终会调用StringBuilder:: append() 来完成字符串的拼接。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** concat() 源码 */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length();  // 拼接的字符串参数长度为0, 返回本身</span><br><span class="line">        if (otherLen == 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length;</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true); // 创建一个新String对象来存储拼接之后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可变性设计的初衷"><a class="markdownIt-Anchor" href="#不可变性设计的初衷"></a> 不可变性设计的初衷</h2><ol><li>字符串常量池的需要。String对象的不可变性为字符串常量池的实现提供了基础，使得常量池便于管理和优化。</li><li>多线程安全。同一个字符串对象可以被多个线程共享。</li><li>安全性考虑。字符串应用场景众多，设计成不可变性可以有效防止字符串被有意篡改。</li><li>由于String对象的不可变性，可以对其HashCode进行缓存，可以作为HashMap，HashTable等集合的key 值。</li></ol><h2 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h2><p>很多文章都提及到字符串常量池是String对象的集合，这种说法很接近了，但是更准确来说，它是 <strong>String 对象引用的集合</strong> （网上关于这个众说纷纭，我更加倾向于存储的是引用的集合~ 若有错误了请指出! 谢谢~ ps: 又看了一遍书，发现在JDK 6以前，永久代中的字符串常量池是存放String 对象实例的，但是JDK 7之后，字符串常量池移到了堆中，String 对象实例也是在堆中的，那字符串常量池只需要保存String 对象的引用就行啦~ 详见《深入理解Java虚拟机》 P63）。 虽说String 是不变的，但是它还是和Java中的其他对象一样，是分配在堆中的，所以说 <strong>String 对象存在于堆中，字符串常量池存放了它们的引用</strong>。因为 String 对象是不可变的，所以多个引用 “共享” 同一个String 对象是安全的，这种安全性就是 字符串常量池所带来的。</p><h3 id="字面量的形式创建字符串"><a class="markdownIt-Anchor" href="#字面量的形式创建字符串"></a> 字面量的形式创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;; // 1</span><br><span class="line">        String two = &quot;someString&quot;; // 2</span><br><span class="line"></span><br><span class="line">        System.out.println(one.equals(two));  // String 对象是否相同内容</span><br><span class="line">        System.out.println(one == two);  // String 对象是否相同的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>执行完上面的第一句代码之后，会在堆上创建一个String 对象，并把String 对象的引用存放到字符串常量池中，并把引用返回给 one，那当第二句代码执行时，字符串常量池已经有对应内容的引用了，直接返回对象引用给 two。one.equals(two) / one == two 都为true。 图形化如下所示：<img src="/小小String对象大大奥秘/stringLiterals1.jpg" title="stringLiterals1"></p><h3 id="new-创建字符串"><a class="markdownIt-Anchor" href="#new-创建字符串"></a> new 创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(one.equals(two));</span><br><span class="line">        System.out.println(one == two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>在使用 new关键字时的情况会有稍微不同，关于这两个字符串的引用任然会存放字符串常量池中，但是关键字 new使得虚拟机在运行时会创建一个新的String对象，而不是使用字符串常量池中已经存在的引用，此时 two 指向 堆中这个新创建的对象，而one 是常量池中的引用。 one.equals(two) 为 true，而 one == two 都为false。<img src="/小小String对象大大奥秘/stringLiterals2.jpg" title="stringLiterals2"></p><p>如果想要one，two都引用同一个对象，则可以使用 String:: intern()方法 - 当调用intern()方法时，如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中它的引用，如果没有，那就将它的引用保存一份到字符串常量池中，然后直接返回这个引用。这个方法是有返回值的，是返回引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String one = &quot;someString&quot;;</span><br><span class="line">String two = new String(&quot;someString&quot;); // 仍指向堆中new 出的新对象</span><br><span class="line">String three = two.intern(); </span><br><span class="line">System.out.println(one.equals(two)); // true</span><br><span class="line">System.out.println(one == two); // false </span><br><span class="line">System.out.println(one == three); // true</span><br><span class="line">System.out.println(two == three); // false</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a class="markdownIt-Anchor" href="#垃圾收集"></a> 垃圾收集</h3><p>当一个对象没有引用指向时，垃圾收集器便会对它进行收集操作。看下面的一个事例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        one = two = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 one = two = null时，只有一个对象会被回收，String 对象总是有来自字符串常量池的引用，所以不会被回收<img src="/小小String对象大大奥秘/stringLiterals3.jpg" title="stringLiterals3"></p><h2 id="string-对象的创建和字符串常量池的放入"><a class="markdownIt-Anchor" href="#string-对象的创建和字符串常量池的放入"></a> String 对象的创建和字符串常量池的放入</h2><p>上面嘀咕了那么久，那到底什么时候会创建String 对象？什么时候引用放入到字符串常量池中呢？先需要提出三个常量池的概念：</p><ol><li>静态常量池：常量池表（Constant Pool table，存放在Class文件中），也可称作为静态常量池，里面存放编译器生成的各种字面量和符号引用。其中有两个重要的常量类型为CONSTANT_String_info和CONSTANT_Utf8_info类型（具体描述可以看看《深入理解Java虚拟机》的p 219 啦~）</li><li>运行时常量池：运行时常量池属于方法区的一部分，常量池表中的内容会在类加载时存放在方法区的运行时常量池，运行时常量池相比于Class文件常量池一个重要特征是 动态性，运行期间也可以将新的常量放入到 运行时常量池中</li><li>字符串常量池：在HotSpot 虚拟机中，使用StringTable来存储 String 对象的引用，即来实现字符串常量池，StringTable 本质上是HashSet<string>，所以里面的内容是不可以重复的。一般来说，说一个字符串存储到了字符串常量池也就是说在StringTable中保存了对这个String 对象的引用</string></li></ol><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>有了上面的概念之后，便可来描述下述过程了<br>首先给出结论，<strong>“在类的解析阶段，虚拟机便会在创建String 对象，并把String对象的引用存储到字符串常量池中”。</strong></p><ol><li>当*.java 文件 编译为*.class 文件时，字符串会像其他常量一样存储到class 文件中的常量池表中，对应于CONSTANT_String_info和CONSTANT_Utf8_info类型；</li><li>类加载时，会把静态常量池中的内容存放到方法区中的运行时常量池中，其中CONSTANT_Utf8_info类型在类加载的时候就会全部被创建出来，即说明了加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，但是此时StringTable（字符串常量池）并没有相应的引用，在堆中也没有相应的对象产生；</li><li>遇到ldc字节码指令（该指令将int、float或String型常量值从常量池中推送至栈顶）之前会触发解析阶段，进入到解析阶段，若在解析的过程中发现StringTable已经有与CONSTANT_String_info一样的引用，则返回该引用，若没有，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；</li></ol><h3 id="具体示例"><a class="markdownIt-Anchor" href="#具体示例"></a> 具体示例</h3><p>下面给出几个具体实例，来说下这个过程：</p><ul><li><strong>字面量的形式创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    String name = &quot;HB&quot;;</span><br><span class="line">    String name2 = &quot;HB&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 = String  #14 </span><br><span class="line">#14 = utf8    HB</span><br><span class="line">……</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=3, args_size=1</span><br><span class="line">         0: ldc           #2  // String HB</span><br><span class="line">         2: astore_1     </span><br><span class="line">         3: ldc           #2  // String HB</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>当编译成字节码文件后，字面量&quot;HB&quot; 会存储到常量类型 CONSTANT_Utf8_info中，类加载时，其也会随之加载到方法区中的运行时常量池中，接下来可以用此来在StringTable查询是否有匹配的String 对象引用（当然只是简化的说法，具体CONSTANT_Utf8_info还指向一个Symbol对象~）；遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；astore_1指令把返回的引用存到本地变量name； 遇到二个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）已经有与CONSTANT_String_info一样的引用，则直接返回即可，并通过astore_2 指令将其返回的引用保存到本地变量 name2中</p><ul><li><strong>new 创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test2&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    String name = new String(&quot;HB&quot;);</span><br><span class="line">    String name2 = new String(&quot;HB&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: new           #2  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3 // String HB</span><br><span class="line">         6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #2 // class java/lang/String</span><br><span class="line">        13: dup</span><br><span class="line">        14: ldc           #3 // String HB</span><br><span class="line">        16: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure><p>使用了关键字new后，会有稍微不同，new 指令会在堆中创建一个新的String 对象，并将其引用值压入栈顶，通过dup指令 复制栈顶的新对象的引用值并把复制值压入栈顶，本地变量name 所保存的值就为该引用值；接下来在遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用, 所以在运行时，会创建两个String对象哦~接下来的过程和前面的差不多，就不一一叙述啦！</p><ul><li><strong>其他重要值得关注的示例</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;hb&quot;);</span><br><span class="line">String s2 = &quot;hb&quot;;</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line">String s3 = s1.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s2 == s3);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s5 = &quot;hb&quot; + &quot;haha&quot;;  // 虚拟机会优化进行优化, 当成一个整体 &quot;hbhaha&quot;成立, 而不会用StringBuild::append()处理</span><br><span class="line">String s6 = &quot;hbhaha&quot;;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String temp = &quot;hb&quot;;</span><br><span class="line">String s7 = temp + &quot;haha&quot;; // 采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s7 == s6);  // false</span><br><span class="line">String s8 = s7.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s8 == s6); // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s9 = new String(&quot;hb&quot;) + new String(&quot;haha&quot;);  //采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s9 == s6); // false</span><br><span class="line">String s10 = s9.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s10 == s6); // true</span><br><span class="line"></span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s11 = new StringBuilder(&quot;hello&quot;).append(&quot; world&quot;).toString();</span><br><span class="line">System.out.println(s11 == s11.intern()); // true - 一个很特殊的例子, intern()方法会把s11引用放入到字符串常量池中</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s12 = new StringBuilder(&quot;hello&quot;).append(&quot; java&quot;).toString();</span><br><span class="line">String s13 = &quot;hello java&quot;;</span><br><span class="line">System.out.println(s12 == s12.intern()); // false - 一个很特殊的例子, intern()方法返回s13 在常量池中的引用</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>String 对象存在于堆中，字符串常量池存放了它们的引用</li><li>字符串常量池存储String对象的引用，且是全局共享的，相同的字符串都将指向同一个字符串对象</li><li>运行时创建的字符串（new）关键字 和 “” (字面量形式) 创建的字符串存在不同</li><li>检查字符串是否相同的最好方法是 equal()</li><li>可以通过String:: intern() 方法从常量池中得到String对象的引用，或 将String 对象的引用存入到 字符串常量池中</li><li>上述所有的实验都是在JDK 8 HotSpot虚拟机下进行的，在JDK 7 中HotSpot，字符串常量池移到了堆中哦~，所以不同JDK版本，不同虚拟机下可能存在差异</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html" rel="external nofollow noopener noreferrer" target="_blank">https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>[2] <a href="https://www.iteye.com/blog/rednaxelafx-774673#comments" rel="external nofollow noopener noreferrer" target="_blank">https://www.iteye.com/blog/rednaxelafx-774673#comments</a><br>[3] <a href="https://www.zhihu.com/question/55994121/answer/408891707" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/55994121/answer/408891707</a><br>[4] <a href="https://www.cnblogs.com/Kidezyq/p/8040338.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/Kidezyq/p/8040338.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是字符串&quot;&gt;&lt;/a&gt; 什么是字符串？&lt;/h2&gt;
&lt;p&gt;字符串是由引号所括起来的一系列字符序列。例如&amp;quot;String&amp;quot;，&amp;quot;Hello&amp;quot;就
      
    
    </summary>
    
      <category term="Java学习" scheme="http://www.huangbin.fun/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.huangbin.fun/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存设计 - 缓存穿透/雪崩/击穿</title>
    <link href="http://www.huangbin.fun/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF.html"/>
    <id>http://www.huangbin.fun/Redis-缓存设计-缓存穿透-雪崩-击穿.html</id>
    <published>2020-05-01T06:26:45.000Z</published>
    <updated>2020-05-01T06:49:51.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存收益和成本"><a class="markdownIt-Anchor" href="#缓存收益和成本"></a> 缓存收益和成本</h2><ol><li>缓存收益</li></ol><ul><li>加速读写</li><li>减低后端负载</li></ul><ol start="2"><li>缓存成本</li></ol><ul><li>数据不一致问题：缓冲层和数据层保存的数据可能不一致</li><li>代码维护成本变高，多了一层缓存逻辑</li><li>运维成本，例如 Redis cluster的维护</li></ul><ol start="3"><li>使用场景</li></ol><ul><li>减低后端负载：对高消耗的SQL结果进行缓存，例如join结果集/分组统计结果</li><li>加速请求响应</li><li>大量写合并为批量写，如计数器先Redis累加再批量写到DB</li></ul><h2 id="缓存更新策略"><a class="markdownIt-Anchor" href="#缓存更新策略"></a> 缓存更新策略</h2><ol><li>LRU(Least Recently Used)，根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，则延迟其淘汰时间” - <a href="https://blog.csdn.net/yunhua_lee/article/details/7599671" rel="external nofollow noopener noreferrer" target="_blank">LRU缓存更新</a></li><li>LFU(Least Frequently Used)根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”- <a href="https://blog.csdn.net/yunhua_lee/article/details/7648549" rel="external nofollow noopener noreferrer" target="_blank">LFU缓存更新</a></li><li>FIFO ，根据&quot;先进先出&quot; 思想来更新缓存数据</li><li>超时剔除 - expire</li><li>主动更新 - 开发控制生命周期</li><li>扩展：缓存污染 - 缓存污染降低了缓存的使用率，把不常用的数据读取到缓存，同时会把常用的数据移出缓存，这样会直接降低系统的数据命中率</li></ol><h2 id="缓存穿透问题"><a class="markdownIt-Anchor" href="#缓存穿透问题"></a> 缓存穿透问题</h2><ol><li><p>定义：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询），导致大量请求发到了数据库上。<img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/缓存穿透.png" title="缓存穿透"></p></li><li><p>解决方法</p></li></ol><ul><li>缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，不超过5分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库。<br><strong>存在的问题：</strong><br>（1）需要更多的键，所以通常设置较短过期时间<br>（2）缓存层和存储层数据&quot;短期&quot;不一致</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/设置NULL.jpg" title="设置NULL"><ul><li>布隆过滤器拦截：<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。例如Redis可以使用bitMap来实现布隆过滤器</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/布隆过滤器.jpg" title="布隆过滤器"><h2 id="缓存雪崩问题"><a class="markdownIt-Anchor" href="#缓存雪崩问题"></a> 缓存雪崩问题</h2><ol><li>定义：缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务（可能是机器宕机或大量的缓存(key)在同一时间失效 - 过期），于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</li><li>解决方法</li></ol><ul><li>保证缓存层服务高可用性：即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，比如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</li><li>依赖隔离组件为后端限流并降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>数据预热：可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul><h2 id="缓存击穿问题"><a class="markdownIt-Anchor" href="#缓存击穿问题"></a> 缓存击穿问题</h2><ol><li>定义：一个存在的热点key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到数据库，造成瞬时数据库请求量大压力骤增。</li><li>解决方法</li></ol><ul><li>互斥锁</li><li>永不过期</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a><br>[2] <a href="https://www.cnblogs.com/George1994/p/10668889.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/George1994/p/10668889.html</a><br>[3] <a href="https://www.jianshu.com/p/b57d0773ee96" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b57d0773ee96</a><br>[4] <a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存收益和成本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#缓存收益和成本&quot;&gt;&lt;/a&gt; 缓存收益和成本&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;缓存收益&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;加速读写&lt;/li&gt;
&lt;li&gt;减低后端负载&lt;/li&gt;

      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 故障转移</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-故障转移.html</id>
    <published>2020-04-30T06:25:11.000Z</published>
    <updated>2020-05-01T07:06:04.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障发现"><a class="markdownIt-Anchor" href="#故障发现"></a> 故障发现</h2><ol><li>通过ping/pong消息来实现故障发现：不需要sentinel</li><li>主观下线：某个节点认为另一个节点不可用，“偏见” <img src="/Redis-Cluster-故障转移/主观下线.png" title="主观下线"></li><li>客观下线：当半数以上持有槽的主节点都标记了某节点主观下线<img src="/Redis-Cluster-故障转移/客观下线.png" title="客观下线"></li></ol><ul><li>故障链表可以维护了每个节点对其他节点的&quot;看法&quot;，即认为主观下线与否</li><li>尝试客观下线流程如下：<img src="/Redis-Cluster-故障转移/客观下线流程.png" title="客观下线流程"></li></ul><h2 id="故障恢复"><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h2><ol><li>资格检查<br>检查每个从节点与故障主节点的断线时间。超过cluster-node-timeout * cluster-slave-validity-factor(默认10)则取消资格。</li><li>准备选举时间<br>准备选举时间，偏移量更大的从节点拥有延迟更小的选举时间，尽量保证从节点与主节点的数据一致性<img src="/Redis-Cluster-故障转移/选举时间.png" title="选举时间"></li><li>选举投票<img src="/Redis-Cluster-故障转移/选举投票.png" title="选举投票"></li><li>替换主节点</li></ol><ul><li>当前从节点取消复制变为主节点（slaveof no one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给新的主节点</li><li>向集群广播自己的pong消息，表明已经替换了故障主节点</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;故障发现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#故障发现&quot;&gt;&lt;/a&gt; 故障发现&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过ping/pong消息来实现故障发现：不需要sentinel&lt;/li&gt;
&lt;li&gt;主观下线：某个节点认为另一个节点不可
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 重定向问题 - Moved/Ask重定向</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98-Moved-Ask%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-重定向问题-Moved-Ask重定向.html</id>
    <published>2020-04-28T06:20:16.000Z</published>
    <updated>2020-05-01T07:05:54.788Z</updated>
    
    <content type="html"><![CDATA[<p>相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。</p><h2 id="moved-重定向"><a class="markdownIt-Anchor" href="#moved-重定向"></a> Moved 重定向</h2><img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved.png" title="Moved"><ol><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。<br>从下面可以看出 php 的槽位9244不在当前节点中，所以会重定向到节点 192.168.2.23:7001中。redis-cli会帮你自动重定向（如果没有集群方式启动，即没加参数 -c，redis-cli不会自动重定向），并且编写程序时，寻找目标节点的逻辑需要交予程序员手动完成。<br><em>cluster keyslot keyName</em>  # 得到keyName的槽<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved2.png" title="Moved2"></li></ol><h2 id="ask-重定向"><a class="markdownIt-Anchor" href="#ask-重定向"></a> ASK 重定向</h2><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/ASK.png" title="ASK"></p><h2 id="smart客户端"><a class="markdownIt-Anchor" href="#smart客户端"></a> smart客户端</h2><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来减低复杂性，追求更好的性能。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。<br>实现原理：</p><ol><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/映射关系.png" title="映射关系"></li><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/命令操作流程.png" title="命令操作流程"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。&lt;/p&gt;
&lt;h2 id=&quot;moved-重定向&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#move
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 集群伸缩</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-集群伸缩.html</id>
    <published>2020-04-26T06:05:21.000Z</published>
    <updated>2020-05-01T07:05:41.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群伸缩"><a class="markdownIt-Anchor" href="#集群伸缩"></a> 集群伸缩</h2><p>在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动</p><h2 id="集群扩容"><a class="markdownIt-Anchor" href="#集群扩容"></a> 集群扩容</h2><ol><li>准备新节点，把新节点配置为集群模式，相关配置信息和其他节点统一，启动后新节点是孤立节点，和集群之间还没有联系</li><li>使用 <em>cluster meet newNodeIP newNodePort</em> 把新节点加入到集群中，当然也可以使用官方的 redis-trib.rb的 相关命令来加入新节点（需要配置Ruby 环境~）。节点加入集群后，可以有两个作用：1. 为它迁移槽和数据实现扩容 ；2. 作为从节点负责故障转移</li><li>若新加入的节点大于一个，还可以进行主从分配， <em>cluster replicate nodeId</em></li><li>迁移槽和数据</li></ol><ul><li>制订迁移计划，每个节点要迁移多少个槽给新节点</li></ul><img src="/Redis-Cluster-集群伸缩/集群扩容.png" title="集群扩容"><ul><li>开始迁移操作<br> a. 对目标节点： <em>cluster setslot {slot} importing {sourceNodeId}</em>  让目标节点准备导入槽的数据<br> b. 对源节点： <em>cluster setslot {slot} migrating {targetNodeId}</em> 让源节点准备迁出槽的数据<br> c. 源节点循环执行  <em>cluster getkeysinslot {slot} {count}</em> 每次获取count个属于槽的键<br> d. 在源节点执行 <em>migrate {targetIp} {targetPort} key 0 {timeout}</em> 命令把指定key迁移，0 表示数据库0<br> e. 重复执行步骤 3 ~ 4直到槽下所有的键数据迁移到目标节点<br> f. 向集群内所有主节点发送  <em>cluster setslot {slot} node {targetNodeId}</em> 命令，告诉所有主节点 槽分配给了目标节点   <img src="/Redis-Cluster-集群伸缩/slot迁移.png" title="slot迁移"></li></ul><p>  上述的迁移操作很是繁琐，可以使用官方提供的redis-trib.rb的相关命令进行操作。使用 redis-trib.rb reshard IP:Port 进行交互模式来完成槽的移动  - <a href="https://www.jianshu.com/p/21f67bd739cc" rel="external nofollow noopener noreferrer" target="_blank">redis-trib工具使用</a></p><h2 id="集群收缩"><a class="markdownIt-Anchor" href="#集群收缩"></a> 集群收缩</h2><ol><li>下线集群节点之前，需要看节点是否持有槽，即是否有数据，若有，则需要迁移到其他节点<br><em>redis-trib.rb reshard --from {downNodeId} --to {migrateNodeId} --slots {slotNumber}  IP:Port</em>，其中的 IP:Port，任意一个节点的 IP:Port都行哦~<img src="/Redis-Cluster-集群伸缩/集群收缩.png" title="集群收缩"></li><li>通知其他所有节点忘记下线节点，<em>cluster forget {downNodeId}</em>_ 或者 <em>redis-trib.rb del-node IP:Port {forgetNodeId}</em> 。若有主从复制，要先下线从节点哦~ <img src="/Redis-Cluster-集群伸缩/集群收缩2.png" title="集群收缩2"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群伸缩&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集群伸缩&quot;&gt;&lt;/a&gt; 集群伸缩&lt;/h2&gt;
&lt;p&gt;在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动&lt;/p&gt;
&lt;h2 id=&quot;集群扩容&quot;&gt;&lt;a clas
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法 - 基于《算法》第四版</title>
    <link href="http://www.huangbin.fun/KMP%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.html"/>
    <id>http://www.huangbin.fun/KMP算法-基于《算法》第四版.html</id>
    <published>2020-04-20T13:01:18.000Z</published>
    <updated>2020-04-20T13:43:29.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2><ol><li>规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)</li><li>基本思想：当出现不匹配时，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配），根据这些已经知晓的内容决定  <strong>在出现不匹配时，模式应在处于哪个位置和文本的下一个字符比较 - 即找到已知晓内容和模式的最长公共前缀（利用模式去匹配已知晓的内容）</strong></li></ol><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><p>看《算法》的时候，有点部分真的太简洁了，看的晦涩难懂( 是我太菜了~ /(ㄒoㄒ)/~~） ，关注一下几个要点，要结合书中内容看可能会有新的理解</p><ol><li><p>指向文本的指针 i 永远不会回退，不会重复扫描文本，只有模式的指针 j 会进行回退。</p></li><li><p>有限状态机（DFA）只和 模式 有关，所以只要计算出了一个 模式的有限状态机（DFA），就可以匹配不同的文本。</p></li><li><p>DFA[txt.charAt(i)][j] = next， 表示 当前状态 j 时，遇到 文本字符 txt.charAt(i) （即 txt.charAt(i) 和 pat.charAt(j)进行比较）后的下一个状态是 next ( 即模式的指针 j 需要回退/前进到 next 处 和 文本字符 txt.charAt(i + 1)进行比较) 。</p></li><li><p>在一个状态中，要确定状态会进行何种转移，需要知道 <strong>当前状态</strong> 和 <strong>遇到的字符</strong>。</p></li><li><p>构造DFA：匹配成功时，即txt.charAt(i) == pat.charAt(j)，DFA[txt.charAt(i)][j] = j +1； 匹配失败时，模式指针 j 的回退也不是盲目回退， 它会根据 <strong>部分已经匹配成功的字符串与模式进行匹配后所处的状态（即书上所说的 X 重启状态）</strong> 以及 <strong>当前匹配失败的输入</strong> 来决定回退到哪个位置<img src="/KMP算法-基于《算法》第四版/匹配图.png" title="匹配图">在箭头处出现了不匹配，那此时pat 指针 j 应该回退到哪个地方在和 txt 的下一个字符 A 比较呢？<br>知道 状态 j 遇到了 字符D 发生了不匹配，意味着pat的前 j  个字符串 (0… j-1)和文本的 (i - j, i - 1)是相匹配的， 就像上述所示，但是我们不用理会 txt.charAt(i-j)，因为 i - j处已经不可能出现匹配，所以  <strong>部分已经匹配成功的字符串</strong> 就为 B A B A （pat[1… j - 1]）。<br>现我们考虑 B A B A 和 模式 进行匹配会到达什么状态（所到达的状态也是书中所提到的 <strong>重启状态 X</strong>），这个过程我们也可以看成是找 <strong>部分已经匹配成功的字符串</strong>  和 <strong>模式</strong> 的 <strong>最长公共前缀</strong> 的过程。<img src="/KMP算法-基于《算法》第四版/匹配图2.png" title="匹配图2">可以看到 B A B A 和 模式 进行匹配之后到达了 状态 3，即 X =3。则可以知道 DFA[D][5] = DFA[D][3]，即在状态 5 遇到 字符 D发生不匹配时应该回退的位置 就是在状态 3 遇到 字符 D 时 应该到达的位置。 这可以对应到书中代码 DFA[C][j] = DFA[C][X]。</p></li><li><p>困扰我很久的一个 X 如何进行求得，可以将其看成一个 X[] 数组，记录了模式与 部分匹配成功的字符串（pat[1…j -1]）所达到的所有状态（书本P765，图5.3.8很好的表达了此点）。它们之间关系是一个递推关系，X[i+1]为X[j]状态 遇到 pat.charAt(j)时所到达的状态，即 X[j + 1] = DFA[pat.charAt(j)][x[j]]，X[0]初始化状态为0。 这也便是书中代码中的 X = DFA[pat.charAt(j)][X]。理解了上述6,7之后，就可以写出构造DFA的过程（当然，我对于上述6，7的说明都是基于你已经看过了《算法》中字符串查找部分哦~）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] DFA;</span><br><span class="line">public void generateDFA(String pat)&#123;</span><br><span class="line">        int M = pat.length();</span><br><span class="line">        int R = 256;  // ASCII字符不会操过256种</span><br><span class="line">        DFA = new int[R][M];</span><br><span class="line">        // 初始化状态0, 在状态0只有遇到了pat.charAt(0)才会向前推进, 遇到其他为0(java默认初始化数组为0)</span><br><span class="line">        DFA[pat.charAt(0)][0] = 1;</span><br><span class="line">        int X = 0;  // 初始化重启状态为0</span><br><span class="line">        for (int j = 1; j &lt; M; j++)&#123;  // 构造DFA数组过程</span><br><span class="line">           for (int c = 0; c &lt; R; c++)</span><br><span class="line">          // 状态j遇到字符c不匹配时,把重启状态X遇到字符c到达哪个状态赋值DFA[c][j]</span><br><span class="line">                DFA[c][j] = DFA[c][X];</span><br><span class="line">           DFA[pat.charAt(j)][j] = j + 1;  // 匹配成功, 状态向前推进</span><br><span class="line">           X = DFA[pat.charAt(j)][X];  // 部分已经成功匹配字符串中增加了pat.charAt(i), 需要更新重启状态X,即它们的最长重叠字符会发生变化</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>我们已经计算出了DFA，下面是利用DFA来搜索文本的算法 - 结合书本P498 图5.3.7理解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int search(String txt) &#123;</span><br><span class="line">   int M = pat.length();</span><br><span class="line">   int N = txt.length();</span><br><span class="line">   int i,j;</span><br><span class="line">    // pat 的初始态为 0 - 模拟有限状态机运行</span><br><span class="line">   for (i = 0,j = 0; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">        // 当前是状态 j，遇到字符 txt[i]，</span><br><span class="line">        // pat 应该转移到哪个状态？</span><br><span class="line">        j = dp[txt.charAt(i)][j];</span><br><span class="line">        // 如果达到终止态，返回匹配开头的索引</span><br><span class="line">        if (j == M) return i - M;</span><br><span class="line">   &#125;</span><br><span class="line">   // 没到达终止态，匹配失败</span><br><span class="line">   return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>结合上面两部分就可以得到具体的KMP算法啦！ （ 具体参考书籍上的算法哦</p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>要使用KMP算法进行匹配，重要的是求出 DFA 数组，而要求出正确的得到DFA数组，格外需要关注（难理解）的是重启状态X和重启状态X的转移，即为每次发生匹配时，模式 和 pat[1…j]的最长公共前缀。只要得到了DFA数组之后，模拟有限状态机运行就可以进行匹配操作了。</li><li>对于长度为M的模式字符串和长度为N的文本，KMP查找算法访问字符串不会超过 N + M个。</li><li>就算书上所提的一样，KMP算法为最坏情况提供的线性级别运行时间保证的一个理论成果，在实际运用中，它比暴力算法的速度优势并不明显</li></ol><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="https://judes.me/tech/2016/04/10/kmp.html" rel="external nofollow noopener noreferrer" target="_blank">https://judes.me/tech/2016/04/10/kmp.html</a><br>[2] <a href="https://book.douban.com/subject/19952400/discussion/59623403/" rel="external nofollow noopener noreferrer" target="_blank">https://book.douban.com/subject/19952400/discussion/59623403/</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/83334559" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/83334559</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本思想&quot;&gt;&lt;/a&gt; 基本思想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)&lt;/li&gt;
&lt;li&gt;基本思想：当出现不匹配时，就能
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="KMP" scheme="http://www.huangbin.fun/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster学习</title>
    <link href="http://www.huangbin.fun/Redis-Cluster%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster学习.html</id>
    <published>2020-04-18T02:57:05.000Z</published>
    <updated>2020-04-18T03:29:21.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称当个Redis可以使用10万并发），高可用问题（部分节点不可达能继续处理命令）。 Redis 集群常常和主从复制结合使用。</p><h2 id="分布式数据库-数据分区"><a class="markdownIt-Anchor" href="#分布式数据库-数据分区"></a> 分布式数据库 - 数据分区</h2><img src="/Redis-Cluster学习/数据分区.png" title="数据分区"><h3 id="哈希分区"><a class="markdownIt-Anchor" href="#哈希分区"></a> 哈希分区</h3><p>假如有1~100条数据，按照哈希函数（例如 hash(key)%3），把数据分区到不同的三个数据库</p><ol><li>节点取余分区： hash(key) % nodes。若增加/减少节点，会进行大量数据迁移，例如当前有3个节点，增加了一个节点，按照新的hash(key) % 4进行计算时，很多数据需要进行移动。 建议进行 多倍扩容，例如当前有3个节点，可以扩容到6个节点，减少数据迁移量。节点取余也成为 不一致性哈希。比较适合缓存的场景</li><li>一致性哈希分区<br>能保证最小迁移数据，比较适合缓存的场景 - <a href="http://blog.codinglabs.org/articles/consistent-hashing.html" rel="external nofollow noopener noreferrer" target="_blank">一致性哈希分区</a></li><li>虚拟槽分区：Redis cluster采用此种分区方式，预设虚拟槽（slot），每个虚拟槽映射一个数据子集，每个节点管理一定数量的虚拟槽，redis 虚拟槽范围 0 ~ 16383。<br>使用分散函数（例如CRC16(keys) % slots ）计算出 keys 属于哪个槽，再根据节点所管理的槽的范围，从而确定数据属于哪个节点（节点中共享信息，若一个虚拟槽不属于当前节点，会告诉虚拟操去哪个节点去存储）</li></ol><img src="/Redis-Cluster学习/虚拟槽分区.png" title="虚拟槽分区"><h3 id="顺序分区"><a class="markdownIt-Anchor" href="#顺序分区"></a> 顺序分区</h3><p>假如有1 ~ 100条数据，按照顺序分区规则，可以把1 ~ 33，34 ~ 66，67 ~ 100分区到三个不同的三个数据库</p><h3 id="方式对比"><a class="markdownIt-Anchor" href="#方式对比"></a> 方式对比</h3><img src="/Redis-Cluster学习/分区比较.png" title="分区比较"><h2 id="cluster-架构"><a class="markdownIt-Anchor" href="#cluster-架构"></a> Cluster 架构</h2><img src="/Redis-Cluster学习/cluster架构.png" title="cluster架构"><ol><li>通过配置文件 cluster-enabled yes 将一个节点设置为一个集群节点</li><li>节点之间通过gossip协议进行通信，了解彼此的信息</li><li>将虚拟槽指派给上述节点</li><li>客户端通过 CRC16( key ) % 16383 并可知道对应的key应该到哪个虚拟槽的哪个节点进行处理</li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="配置集群节点"><a class="markdownIt-Anchor" href="#配置集群节点"></a> 配置集群节点</h3><ol><li><em>cluster-enabled yes</em>  # 配置当前节点为集群节点</li><li><em>cluster-config-file nodes-${port}.conf</em>  # 配置cluster节点自身配置文件</li><li><em>cluster-node-timeout 15000</em>  # 集群中各个节点相互通讯（ping）时，允许&quot;失联&quot;的最大毫秒数，如果超过这个时间没有得到响应，会认为该节点故障，若节点是主节点，则会进行故障转移</li><li><em>cluster-require-full-coverage yes</em>  # 若配置为 yes，则当集群中有节点不可用时，整个集群都不能提供服务，通常设置为 no</li></ol><h3 id="通过meet把每个集群节点组合成集群-集群发现"><a class="markdownIt-Anchor" href="#通过meet把每个集群节点组合成集群-集群发现"></a> 通过meet把每个集群节点组合成集群 - 集群发现</h3><ol><li><em>cluster meet ip port</em>  #当前节点去发现新的集群节点</li></ol><img src="/Redis-Cluster学习/发现集群.png" title="发现集群"><h3 id="分配槽"><a class="markdownIt-Anchor" href="#分配槽"></a> 分配槽</h3><ol><li><em>cluster addslots slot [slot…]</em>   # 为当前节点分配槽</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># addslots.sh</span><br><span class="line"># 开始槽</span><br><span class="line">start=$1</span><br><span class="line"># 结束槽</span><br><span class="line">end=$2</span><br><span class="line"># 分配端口</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">   echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">   redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 分配操作</span><br><span class="line">sh addslots 0 5461 7000</span><br><span class="line">sh addslots 5462 10923 7001</span><br><span class="line">sh addslots 10923 16383 7002</span><br></pre></td></tr></table></figure><p>在第二步中配置了6个集群节点，但是只为7000 ~ 7002分配槽，7000 ~ 7002作为master，其余作为slave节点</p><h3 id="配置主从关系"><a class="markdownIt-Anchor" href="#配置主从关系"></a> 配置主从关系</h3><ol><li><em>cluster replicate node-id</em>  # 对 node-id节点进行复制，node-id在集群启动时会进行分配。</li><li><em>cluster nodes</em>  # 查看node-id</li></ol><img src="/Redis-Cluster学习/配置主从关系.png" title="配置主从关系"><h3 id="ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"><a class="markdownIt-Anchor" href="#ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"></a> Ruby配置集群 -除了上述安装方式，官方提供了脚本进行快速集群配置</h3><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>Gossip 协议：所有节点都保存了一份元数据，当节点发生伸缩或更新时，会将最新的元数据信息传播给所有节点。 - <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">gossip协议</a><br>Redis 使用Gossip协议时采用了meet，ping，pong，fail消息进行通信</li></ol><img src="/Redis-Cluster学习/gossip协议.png" title="gossip协议"><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://blog.csdn.net/makyan/article/details/104798725" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/makyan/article/details/104798725</a><br>[2] <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/8279d6fd65bb</a><br>[3] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长回文子串</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长回文子串.html</id>
    <published>2020-04-13T10:40:48.000Z</published>
    <updated>2020-04-14T02:30:32.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;br&gt;
示例 1：&lt;br&gt;
输入: “ba
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.huangbin.fun/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>初探动态规划算法</title>
    <link href="http://www.huangbin.fun/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/初探动态规划算法.html</id>
    <published>2020-04-13T09:18:28.000Z</published>
    <updated>2020-04-14T02:30:30.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h1&gt;
&lt;p&gt;维基百科的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dynamic programming is a method for solvi
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="Gynamic Programming" scheme="http://www.huangbin.fun/tags/Gynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel学习</title>
    <link href="http://www.huangbin.fun/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Sentinel学习.html</id>
    <published>2020-04-10T14:10:33.000Z</published>
    <updated>2020-04-14T02:35:15.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sentinel生产可用。sentinel作为一个独立的进程，监控多个运行的Redis 数据库。<br>主要解决主从复制发生故障时，进行手动故障转移的复杂性问题，当主节点宕机后，需要手动选择一个从节点作为新的主数节点，其他作为从节点，而利用sentinel能自动完成故障转移过程。<br>sentinel也支持集群，因为使用单个sentinel进程了监控Redis是不可靠的，容易出现单点问题</p><ul><li>即使有一些sentinel进程宕掉了，依然可以进行Redis 集群的主从切换</li><li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现Redis 集群的主从切换</li><li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于Redis 集群中的信息</li></ul><h2 id="功能和架构"><a class="markdownIt-Anchor" href="#功能和架构"></a> 功能和架构</h2><ol><li>功能<ul><li>监控Redis的运行状况</li><li>当发生故障时实现主从切换。当一个master宕机之后，从它的多个slave中投票选举中一个新的master，剩余节点作为新的master的slave</li></ul></li><li>架构</li></ol><img src="/Redis-Sentinel学习/架构图.png" title="架构图"><p>在这个架构中，sentinel节点会监控master和slave的相关信息，主要值得关注的是client与sentinel之间的交互：</p><ol><li>client首先需要知道sentinel节点集合和mastername信息，通过遍历它所知道的sentinel集合，获取到一个可用的sentinel节点</li><li>找到可用的sentinel节点之后，client通过 sentinel get-master-addr-by-name masterName 命令的得到master节点的地址和端口</li><li>得到master相关信息之后，会进行一次role/role replication验证，master节点会返回验证信息，至此client可以对master进行写入和读取</li><li>sentine也会将redis数据节点的变化通知给客户端 - 使用发布订阅模式进行通知</li><li>上述过程不是通过代理模式实现的，即上述client和master建立关系的过程通常只需执行一次即可</li></ol><h2 id="故障转移过程"><a class="markdownIt-Anchor" href="#故障转移过程"></a> 故障转移过程</h2><ol><li>当一个sentinel检测master宕机并不会马上进行故障转移（主观下线），只有当后面的sentinel也都认为master不可用并达到一定数量时（客观下线），选举出一个领导者sentinel来进行故障转移操作</li><li>选出一个slave作为master，执行 slave of one 让其成为master节点</li><li>通知其余slave做为新的master的slave</li><li>等待老的master复活，若复活成功，成为新的master的slave</li><li>通知客户端发生了主从变化</li></ol><p>实现上述故障转移依靠三个定时任务：</p><ol><li>每10s每个sentinel对master和slave执行info操作<ul><li>发现slave操作</li><li>确认主从关系</li></ul></li><li>每2s每个sentinel通过master节点的channel交换信息<ul><li>发布订阅模式</li><li>通过_sentinel_:hello频道交互</li><li>交互对节点的&quot;看法&quot;和自身信息 - 可以知道其他sentinel的相关信息或投票来确定哪个sentinel来进行故障转移<img src="/Redis-Sentinel学习/sentinel发布订阅图.png" title="sentinel发布订阅图"></li></ul></li><li>每1s每个sentinel对其他sentinel和redis执行ping<ul><li>心跳检测，失败判定依据，比如可以作为客观下线的依据。</li></ul></li></ol><h2 id="sentinel配置和启动"><a class="markdownIt-Anchor" href="#sentinel配置和启动"></a> Sentinel配置和启动</h2><ol><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel运行端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 守护进程启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># sentinel工作目录</span><br><span class="line">dir &quot;/usr/local/share/redis/redis-3.0.5/backs&quot;</span><br><span class="line"></span><br><span class="line"># sentinel 日志文件</span><br><span class="line">logfile &quot;sentinel-26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master信息 master-name ip port quorum - 当quorm个数sentinel节点认为maste</span><br><span class="line"># r失联,则执行故障转移</span><br><span class="line">sentinel monitor mymaster 192.168.2.23 6379 2</span><br><span class="line"></span><br><span class="line"># 一定时间内,master没有应答哨兵sentinel, sentinel认为master主观下线 默认30秒(ping 30 次没有ping通)</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 在进行主从切换时(故障转移),最多可以几个slave对新的master进行同步。若设置的值很小, 则同</span><br><span class="line">步需要花费很长时间, 值很大,则有很多slave应为同步复制而不可用, 也会降低master节点的性能</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移超时时间, 应用于以下情况</span><br><span class="line"># 1. 同一个sentinel对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2. 当一个slave从一个错误的master那里同步数据开始计算时间,直到slave被纠正为向正确的mast</span><br><span class="line"># er那里同步数据时</span><br><span class="line"># 3.当想要取消一个正在进行的failover所需要的时间  </span><br><span class="line"># 4.当进行failover时,配置所有slaves指向新的master所需的最大时间。不过，即使过了这个时间,</span><br><span class="line"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则进行处理</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>注：可以看到sentinel.conf配置文件主要是对master节点进行监控，通过master节点使用 info replecation 进行slave的相关信息获取，会将获取的slave信息自动添加到 sentinel.conf配置文件之中，在配置文件中的标识为：Generated by CONFIG REWRITE，需要注意的是，redis在添加slave信息的同时，也会对一些配置信息进行更改，例如sentinel down-after-milliseconds，sentinel parallel-syncs，sentinel failover-timeout会被移除，添加sentinel config-epoch，sentinel leader-epoch等配置 。</p><ol start="2"><li>启动</li></ol><p>  <em>redis-sentinel sentinel.conf</em>  # 启动sentinel<br>  <em>redis-cli -p 26379</em>  # 连接sentinel, sentinel也当成一个普通的Redis 节点来对待</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>主观下线：每个sentinel节点对Redis 节点失败的&quot;偏见&quot;，可能由于网络问题，Redis 节点不能在规定的时间内回应sentinel节点</li><li>客观下线：所有sentin节点对Redis 节点失败达成&quot;共识&quot;，即sentinel节点中认为Redis 节点可以进行客观下线的个数超过quorum的个数，此时可以真正进行故障转移操作。其中达成共识通过sentinel is-master-down-by-addr命令询问其他sentinel节点的&quot;意见&quot;来完成的</li><li>领导者选举<ul><li>原因：只需要一个sentinel节点来进行故障转移</li><li>如何：1. 每个做主观下线的sentinel节点通过sentinel is-master-down-by-addr 来询问其他sentinel节点的&quot;意见&quot;是否要对master节点进行客观下线的时候，通过也会要求将其设置为领导者；2. 收到命令的sentinel节点如果没有同意其他sentinel节点成为领导者的请求，那就同意，否则拒绝；3. 如果该sentinel节点发现自己的票数超过了sentinel集合半数且超过了quorum，那么它将成为领导者来进行故障处理；4. 如果有多个sentin节点成为领导者，则过一段时间再进行选举</li></ul></li><li>如何选择合适的slave让其成为master<ul><li>选择 slave-priority优先级最高的slave节点</li><li>若全部优先级相同，则选择复制偏移量最大（与以前的master节点数据最接近）的slave节点</li><li>若上述都不成立，则选择runId最小的节点，即启动最早的slave</li></ul></li></ol><h2 id="运维问题"><a class="markdownIt-Anchor" href="#运维问题"></a> 运维问题</h2><ol><li>主节点手动下线，进行故障转移<br>  <em>sentinel failover masterName</em></li><li>高可用的读写分离<br>sentinel只会对master节点进行故障转移，对于slave节点只有进行主观下线，所以要实现高可用的读写分离，客户端要关注slave节点的变化，例如关注以下三个消息: +switch-master: 从节点晋升为主节点，+conver-to-slave:  原主节点降为从节点，+sdown: 主观下线</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://segmentfault.com/a/1190000002680804" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002680804</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sent
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.huangbin.fun/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://www.huangbin.fun/Redis主从复制.html</id>
    <published>2020-04-10T13:53:44.000Z</published>
    <updated>2020-04-14T02:33:00.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave）上，数据流向是单向的 - Master -&gt; Slave。通常主数据进行数据写入操作，从数据库进行读操作，实现数据的读写分离。</p><h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2><ol><li><p>命令方式</p><ul><li><em>slaveof  slavehost</em> # 将 slavehost 将复制为当前Redis数据库的从数据库，异步操作，会将数据库的数据进行清除。<br><em>e.g., 127.0.0.1: 6380 &gt; slaveof 127.0.0.1: 6379</em>  # 127.0.0.1: 6379将会成为127.0.0.1: 6380的主数据库</li><li><em>slaveof  no one</em> # 取消当前命令执行数据库的复制，以前主数据库已经同步的数据不会清除。</li><li><em>info replication</em>  # 当前数据库是主还是从数据库的相关信息</li></ul></li><li><p>配置 - redis.conf，配置之后需重启</p><ul><li><em>slaveof  masterip masterport</em></li><li><em>slave-read-only yes</em></li></ul></li></ol><h2 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h2><p>执行完全量复制之后，主从数据库之间数据库状态已经相同了。但这个状态并非一成不变，如果主数据库执行了写操作，那么主数据库的数据库状态就会修改，并导致主从数据库状态不再一致。所以为了让主从数据库再次回到一致状态，主数据库需要对从数据库执行命令传播操作：主数据库会将自己执行的写命令，也即是造成主从数据库不一致的那条写命令，发送给从数据库执行，当从数据库执行了相同的写命令之后，主从数据库将再次回到一致状态。</p><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><img src="/Redis主从复制/主从复制.png" title="全量复制"><ol><li>复制过程<ul><li>从数据库向主数据库发送PSYNC命令 - 从2.8开始，SYNC替换成PSYNC，提供了完整重同步和部分重同步</li><li>收到PSYNC命令后，主数据库将自身的runId和offset传给从数据库，之后主数据库执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主数据库的BGSAVE命令执行完毕时，主数据库会将BGSAVE命令生成的RDB文件发送给从数据库，从数据库接收并载入这个RDB文件，将自己的数据库状态更新至主数据库执行BGSAVE命令时的数据库状态</li><li>主数据库将记录在缓冲区里面的所有写命令发送给从数据库，从数据库执行这些写命令，将自己的数据库状态更新至主数据库数据库当前所处的状态</li></ul></li><li>开销<ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>清空从数据库花费时间</li><li>从数据库加载RBD文件花费的时间，并且载入期间，从数据库可能因为阻塞而无法处理客户端请求</li></ul></li></ol><h2 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h2><img src="/Redis主从复制/部分复制.png" title="部分复制"> <ol><li>解决问题：处理从数据库断线后的重连问题。当从数据库在断线后重新连接主数据库时，如果条件允许，主数据库可以将主从数据库连接断开期间执行的写命令发送给从数据库，从数据库只要接收并执行这些写命令，就可以将数据库更新至主数据库当前所处的状态。而2.8以前，断连之后还要进行一次SYNC操作。</li><li>复制过程<ul><li>当从数据库断线后，主数据库会继续把写命令放入到复制积压缓冲区（replication backlog）中</li><li>当从数据库重新连上主数据库时，从数据库会通过PSYNC命令将自己的复制偏移量（replication offset）和主数据库的运行ID（run id）发送给主数据库，主数据库会根据这个复制偏移量和运行ID来决定对从数据库执行何种同步操作</li><li>如果从数据库发送的运行ID和当前连接的主数据库的运行ID相同，那么说明从数据库断线之前复制的就是当前连接的这个主数据库，主数据库可以继续尝试执行部分复制操作</li><li>相反，如果从数据库发送的运行ID和当前连接的主数据库的运行ID并不相同，主数据库将对从数据库执行全量复制操作</li><li>如果从数据库的复制偏移量之后的数据（也即是offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主数据库将对从数据库执行部分复制操作</li><li>相反，如果offset之后的数据已经不存在于复制积压缓冲区，那么主数据库将对从数据库执行全量复制操作</li></ul></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>复制偏移量（replication offset）：主数据库和从数据库会分别维护一个复制偏移量：<ul><li>主数据库每次向从数据库传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从数据库每次收到主数据库传播来的N个字节的数据时，就将自己的复制偏移量的值加上N<br>对比主从数据库的复制偏移量，可知道主从数据库是否处于一致状态：</li><li>如果主从数据库处于一致状态，那么主从数据库两者的偏移量总是相同的</li><li>相反，如果主从数据库两者的偏移量并不相同，那么说明主从数据库并未处于一致状态</li></ul></li></ol><img src="/Redis主从复制/复制偏移量.png" title="复制偏移量"><ol start="2"><li><p>复制积压缓冲区（replication backlog）：复制积压缓冲区是由主数据库维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主数据库进行命令传播时，它不仅会将写命令发送给所有从数据库，还会将写命令入队到复制积压缓冲区里面。因此，主数据库的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量<img src="/Redis主从复制/复制积压缓冲区.png" title="复制积压缓冲区"><br>复制积压缓冲区默认大小为1MB，如果主数据库需要执行大量写命令，又或者主从数据库断线后重连接所需的时间比较长，那么Redis的部分复制功能可能会达不到想要的效果。复制积压缓冲区的最小大小可以根据公式 second*write_size_per_second 来估算：</p><ul><li>second为从数据库断线后重新连接上主数据库所需的平均时间（以秒计算）</li><li>write_size_per_second是主数据库平均每秒产生的写命令数据量。</li><li>例如，如果主数据库平均每秒产生1 MB的写数据，而从数据库断线之后平均要5秒才能重新连接上主数据库，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理，可以通过修改repl-backlog-size配置进行设置。</li></ul></li><li><p>数据库运行ID<br>每个Redis数据库，不论主数据库还是从服务，都会有自己的运行ID。运行ID在数据库启动时自动生成，由40个随机的十六进制字符组成，例53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。<br>当从数据库对主数据库进行初次复制时，主数据库会将自己的运行ID传送给从数据库，而从数据库则会将这个运行ID保存起来。当从数据库断线并重新连上一个主数据库时，从数据库将向当前连接的主数据库发送之前保存的运行ID。</p></li></ol><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li>读写分离<ul><li>数据复制延迟</li><li>读到过期数据</li><li>从数据库故障</li></ul></li><li>主从数据库配置不一致<ul><li>maxmemory不一致：丢失数据</li><li>数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致</li></ul></li><li>规避全量复制<ul><li>第一次全量复制不可避免 - 尽量低峰（夜间）进行</li><li>避免主数据库runId不匹配导致的全量复制</li><li>避免复制积压缓冲区不足导致的全量复制 - 修改rel_backlog_size配置</li></ul></li><li>规避复制风暴<ul><li>单主数据库复制风暴 - 主数据库重启，多从数据库复制</li><li>单机器复制风暴 - 机器有多个主数据库，机器宕机，大量全量复制。避免多个主数据库部署在一个机器上</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化常见问题</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangbin.fun/Redis持久化常见问题.html</id>
    <published>2020-04-10T13:45:43.000Z</published>
    <updated>2020-04-14T02:35:04.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fork操作"><a class="markdownIt-Anchor" href="#fork操作"></a> Fork操作</h2><ol><li>定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这是一种内核机制，在创建子进程并不发生复制，创建子进程后父子进程共用数据，只有在修改数据是才会创建新的空间。</li><li>Redis中需要用到fork操作的相关命令：bgsave，bgrewriteaof，查看上一次fork消耗时间：info stats</li><li>同步操作 - 会对父进程执行的业务造成影响</li><li>与内存量息息相关 - 内存越大，耗时越长，同时也与机器类型相关</li><li>改善fork：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存: maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1 。修改sysctl vm.overcommit_memory=1<br>  0  -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br> b1 -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>  2 -  表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>降低fork频率：例如放宽AOP重写的自动触发时机</li></ul></li></ol><h2 id="子进程的开销和优化"><a class="markdownIt-Anchor" href="#子进程的开销和优化"></a> 子进程的开销和优化</h2><ol><li>CPU<ul><li>开销: RDB和AOF文件的生成，属于CPU密集型</li><li>优化： 不做CPU绑定 ，不和CPU密集型一起部署</li></ul></li><li>内存<ul><li>开销: fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>硬盘<ul><li>开销：AOF和RDB文件写入，结合iostat，iotop分析</li><li>优化：不和高硬盘负载服务部署在一起，根据写入量决定磁盘类型。</li></ul></li><li>扩展：<ul><li>CPU绑定 - 进程和CPU的绑定是为了让应用获得更好的性能，进程的Affinity属性指明了进程调度器能够把这个进程调度到哪些CPU上。CPU Affinity分为2种，soft affinity和hard affinity。soft affinity仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的CPU上。hard affinity是调度器必须遵守的规则。</li><li>CPU密集型（CPU-bound），也叫计算密集型，系统运作时CPU的消耗接近100%，I/O读写可以在很短的时间完成，但是CPU的计算任务繁重。多重程序系统中，大部份时间用来做计算、逻辑判断等的程序称之CPU bound，一般而言，CPU bound的程序CPU占用率相当高。</li><li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，CPU消耗并不高。I/O bound的程序需要大量的I/O操作。</li><li>Transparent hugepage默认是被开启的以便去改善操作系统的内存管理，但是在某种情况下会造成不可预知的节点重启和性能问题</li></ul></li></ol><h2 id="aof追加阻塞"><a class="markdownIt-Anchor" href="#aof追加阻塞"></a> AOF追加阻塞</h2><ol><li><p>定义：如果AOF文件同步时间与上次同步时间相比大于2s，Redis主进程就会阻塞，等待同步完成；如果AOF文件同步时间与上次同步时间相比小于2s，Redis主进程就会返回。其实这样做的目的是为了保证文件安全性的一种策略。 <img src="/Redis持久化常见问题/AOF追加阻塞.png" title="AOF追加阻塞"></p></li><li><p>问题：</p><ul><li>主线程阻塞造成业务受影响</li><li>虽然每秒everysec刷盘策略，但是实际上不是丢失1s数据，实际有可能丢失2s数据</li></ul></li><li><p>问题定位</p><ul><li><p>Redis日志<img src="/Redis持久化常见问题/Redis日志.png" title="Redis日志"></p></li><li><p>Info Persistence中的aof_delayed_fsync,同步延迟历史总数</p></li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fork操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork操作&quot;&gt;&lt;/a&gt; Fork操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.huangbin.fun/Redis持久化.html</id>
    <published>2020-04-10T12:44:30.000Z</published>
    <updated>2020-04-14T02:35:09.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化</p><h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2><ol><li><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行了指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB生成的文件也可作为复制媒介使用。</p></li><li><p>触发方式</p><ul><li><em>save</em>  # 客户端发出命令后，redis会生成相应的dump.rdb文件（若存在老的RDB文件，则新替老）。该命令为同步命令，进行Save 命令时，其他命令不能执行，容易发生阻塞， O(n)</li><li><em>bgsave</em> #与Save 不同的是，该命令为异步命令，会开一个子进程进行处理， O(n)</li></ul> <img src="/Redis持久化/RDB持久化.png" title="RDB持久化"> <img src="/Redis持久化/RDB持久化2.png" title="RDB持久化2"> <ul><li>利用配置文件进行触发 - 采用 bgsave方式</li></ul> <img src="/Redis持久化/RDB持久化3.png" title="RDB持久化3"> <p>  <strong>重要配置项：</strong><br>   dbfilename dump.rdb  # 指定本地数据库名<br>   dir ./   # 指定本地数据库存放目录<br>   rdbcompression yes #默认开启数据压缩，redis采用LZF压缩方式，但占用了一点CPU的时间。<br>   stop-writes-on-bgsave-error yes #出现错误是否停止写入<br>   rdbchecksum yes #是否对RDB文件进行校验</p><ul><li>全量复制 - 主从复制时会自动生成RDB文件</li><li>debug reload - 也会生成RDB文件</li><li>shutdown - Redis也会RDB文件</li></ul></li><li><p>优缺点</p><ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li><li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了 - 不可控，丢失数据。</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件 - 耗时，耗性能</li></ul></li></ol><h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2><ol><li><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></li><li><p>配置文件</p><ul><li>appendonly yes  # 开启AOF</li><li>appendfilename “appendonly-6379.aof” # 指定本地数据库名</li><li>appendfsysnc always/everysec/no # 指定更新日志条件<br>  - always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但是数据完整性比较好（慢，安全）<br>  - everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>  - no ：不同步，由OS决定何时把命令写入到文件中</li></ul> <img src="/Redis持久化/AOF持久化.png" title="AOF持久化">  <img src="/Redis持久化/AOF持久化2.png" title="AOF持久化2">  <img src="/Redis持久化/AOF持久化3.png" title="AOF持久化3"> <ul><li>为了缩小AOF文件的大小，提供了AOP重写,目的减少磁盘占用量（减少冗余）,加速恢复速度</li></ul> <img src="/Redis持久化/AOF持久化4.png" title="AOF持久化4"> <p>  <strong>重写原理</strong><br>  Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中，并没有读取旧文件，最后替换旧的aof文件。<br>  <strong>重写方式</strong><br>  a. bgrewriteaof  #异步，会开启一个子进程来进行处理<br>  b. 配置文件 - 执行bgrewriteaof<br>    auto-aof-rewrite-min-size #AOF文件重写需要的尺寸<br>    auto-aof-rewrite-percentage #AOF文件增加率<br>    当AOF文件大小是上次rewrite后大小的一倍（增加率）且文件大于64M（尺寸）时触发</p><ul><li>no-appendfsync-on-rewrite yes # 在重写时是否可以进行AOF持久化操作</li><li>aof-load-truncated yes # 在AOF文件出现错误时，是否忽略错误，尽量加载更多的数据</li><li>在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复</li></ul></li><li><p>优缺点</p><ul><li>更高的数据完整性和一致性</li><li>随着时间的增加，AOF文件会越来越大，数据恢复速度会越来越慢，可以通过重写解决</li></ul></li></ol><h2 id="持久化策略对比"><a class="markdownIt-Anchor" href="#持久化策略对比"></a> 持久化策略对比</h2><img src="/Redis持久化/持久化对比.png" title="持久化对比"> <h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/itdragon/p/7906481.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/itdragon/p/7906481.html</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化&lt;/p&gt;
&lt;h2 id=&quot;rdb持久化&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
</feed>
