<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小小String对象大大奥秘"><meta name="keywords" content="Java"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>小小String对象大大奥秘 | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是字符串"><span class="toc-number">1.</span> <span class="toc-text"> 什么是字符串？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-的不可变性"><span class="toc-number">2.</span> <span class="toc-text"> String 的不可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可变性设计的初衷"><span class="toc-number">3.</span> <span class="toc-text"> 不可变性设计的初衷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串常量池"><span class="toc-number">4.</span> <span class="toc-text"> 字符串常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字面量的形式创建字符串"><span class="toc-number">4.1.</span> <span class="toc-text"> 字面量的形式创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-创建字符串"><span class="toc-number">4.2.</span> <span class="toc-text"> new 创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集"><span class="toc-number">4.3.</span> <span class="toc-text"> 垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-对象的创建和字符串常量池的放入"><span class="toc-number">5.</span> <span class="toc-text"> String 对象的创建和字符串常量池的放入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行过程"><span class="toc-number">5.1.</span> <span class="toc-text"> 执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#具体示例"><span class="toc-number">5.2.</span> <span class="toc-text"> 具体示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">小小String对象大大奥秘</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java学习/">Java学习</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串？</h2>
<p>字符串是由引号所括起来的一系列字符序列。例如&quot;String&quot;，&quot;Hello&quot;就为一个字符串</p>
<h2 id="string-的不可变性"><a class="markdownIt-Anchor" href="#string-的不可变性"></a> String 的不可变性</h2>
<p>&quot;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何操作都会生成新的对象“。</p>
<ol>
<li>固定不变 - 从String 对象的源码中可以看出，String 类声明为 final，且它的属性和方法都被 final 所修饰</li>
<li>任何操作都会生成新对象 - String:: subString()，String::concat() 等方法都会生成一个新的String对象，不会在原对象上进行操作<br>
从下面String源码部分中很容易得到上面的结论：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** String 类源码 */</span><br><span class="line">public final class String </span><br><span class="line">     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line">     *</span><br><span class="line">     * A String instance is written into an ObjectOutputStream according to</span><br><span class="line">     * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line">     */</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来使用一段代码来揭示这个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String start = &quot;Hello&quot;;  // 1</span><br><span class="line">        String end = start.concat(&quot; World!&quot;); // 2</span><br><span class="line">          //String end = start + &quot; World!&quot;  </span><br><span class="line">        System.out.println(end); // 3</span><br><span class="line">             System.out.println(start); // 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">Hello World!</span><br><span class="line">World</span><br></pre></td></tr></table></figure>
<p>在这段代码中，没有改变任何对象。首先在第一个代码中，会在堆内存中创建一个新的String 对象，并把它的引用赋值给 start，接着在第二个调用String:: concat()方法对字符串进行拼接，<strong>此时会创建一个新的String 对象，该对象是&quot;Hello&quot; 和 “World” 的串联</strong>。就如String:: concat() 源码所示，第三个/四个代码的输出结果分别为：“Hello World!”, “World”。并且操作符 &quot; + &quot;完成了和String:: concat() 类似的事 - &gt; 操作符 “+” 算是一个语法糖，查看编译之后的字节码可以知道最终会调用StringBuilder:: append() 来完成字符串的拼接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** concat() 源码 */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length();  // 拼接的字符串参数长度为0, 返回本身</span><br><span class="line">        if (otherLen == 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length;</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true); // 创建一个新String对象来存储拼接之后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不可变性设计的初衷"><a class="markdownIt-Anchor" href="#不可变性设计的初衷"></a> 不可变性设计的初衷</h2>
<ol>
<li>字符串常量池的需要。String对象的不可变性为字符串常量池的实现提供了基础，使得常量池便于管理和优化。</li>
<li>多线程安全。同一个字符串对象可以被多个线程共享。</li>
<li>安全性考虑。字符串应用场景众多，设计成不可变性可以有效防止字符串被有意篡改。</li>
<li>由于String对象的不可变性，可以对其HashCode进行缓存，可以作为HashMap，HashTable等集合的key 值。</li>
</ol>
<h2 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h2>
<p>很多文章都提及到字符串常量池是String对象的集合，这种说法很接近了，但是更准确来说，它是 <strong>String 对象引用的集合</strong> （网上关于这个众说纷纭，我更加倾向于存储的是引用的集合~ 若有错误了请指出! 谢谢~ ps: 又看了一遍书，发现在JDK 6以前，永久代中的字符串常量池是存放String 对象实例的，但是JDK 7之后，字符串常量池移到了堆中，String 对象实例也是在堆中的，那字符串常量池只需要保存String 对象的引用就行啦~ 详见《深入理解Java虚拟机》 P63）。 虽说String 是不变的，但是它还是和Java中的其他对象一样，是分配在堆中的，所以说 <strong>String 对象存在于堆中，字符串常量池存放了它们的引用</strong>。因为 String 对象是不可变的，所以多个引用 “共享” 同一个String 对象是安全的，这种安全性就是 字符串常量池所带来的。</p>
<h3 id="字面量的形式创建字符串"><a class="markdownIt-Anchor" href="#字面量的形式创建字符串"></a> 字面量的形式创建字符串</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;; // 1</span><br><span class="line">        String two = &quot;someString&quot;; // 2</span><br><span class="line"></span><br><span class="line">        System.out.println(one.equals(two));  // String 对象是否相同内容</span><br><span class="line">        System.out.println(one == two);  // String 对象是否相同的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>执行完上面的第一句代码之后，会在堆上创建一个String 对象，并把String 对象的引用存放到字符串常量池中，并把引用返回给 one，那当第二句代码执行时，字符串常量池已经有对应内容的引用了，直接返回对象引用给 two。one.equals(two) / one == two 都为true。 图形化如下所示：<img src="/小小String对象大大奥秘/stringLiterals1.jpg" title="stringLiterals1"></p>
<h3 id="new-创建字符串"><a class="markdownIt-Anchor" href="#new-创建字符串"></a> new 创建字符串</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(one.equals(two));</span><br><span class="line">        System.out.println(one == two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>在使用 new关键字时的情况会有稍微不同，关于这两个字符串的引用任然会存放字符串常量池中，但是关键字 new使得虚拟机在运行时会创建一个新的String对象，而不是使用字符串常量池中已经存在的引用，此时 two 指向 堆中这个新创建的对象，而one 是常量池中的引用。 one.equals(two) 为 true，而 one == two 都为false。<img src="/小小String对象大大奥秘/stringLiterals2.jpg" title="stringLiterals2"></p>
<p>如果想要one，two都引用同一个对象，则可以使用 String:: intern()方法 - 当调用intern()方法时，如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中它的引用，如果没有，那就将它的引用保存一份到字符串常量池中，然后直接返回这个引用。这个方法是有返回值的，是返回引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String one = &quot;someString&quot;;</span><br><span class="line">String two = new String(&quot;someString&quot;); // 仍指向堆中new 出的新对象</span><br><span class="line">String three = two.intern(); </span><br><span class="line">System.out.println(one.equals(two)); // true</span><br><span class="line">System.out.println(one == two); // false </span><br><span class="line">System.out.println(one == three); // true</span><br><span class="line">System.out.println(two == three); // false</span><br></pre></td></tr></table></figure>
<h3 id="垃圾收集"><a class="markdownIt-Anchor" href="#垃圾收集"></a> 垃圾收集</h3>
<p>当一个对象没有引用指向时，垃圾收集器便会对它进行收集操作。看下面的一个事例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        one = two = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 one = two = null时，只有一个对象会被回收，String 对象总是有来自字符串常量池的引用，所以不会被回收<img src="/小小String对象大大奥秘/stringLiterals3.jpg" title="stringLiterals3"></p>
<h2 id="string-对象的创建和字符串常量池的放入"><a class="markdownIt-Anchor" href="#string-对象的创建和字符串常量池的放入"></a> String 对象的创建和字符串常量池的放入</h2>
<p>上面嘀咕了那么久，那到底什么时候会创建String 对象？什么时候引用放入到字符串常量池中呢？先需要提出三个常量池的概念：</p>
<ol>
<li>静态常量池：常量池表（Constant Pool table，存放在Class文件中），也可称作为静态常量池，里面存放编译器生成的各种字面量和符号引用。其中有两个重要的常量类型为CONSTANT_String_info和CONSTANT_Utf8_info类型（具体描述可以看看《深入理解Java虚拟机》的p 219 啦~）</li>
<li>运行时常量池：运行时常量池属于方法区的一部分，常量池表中的内容会在类加载时存放在方法区的运行时常量池，运行时常量池相比于Class文件常量池一个重要特征是 动态性，运行期间也可以将新的常量放入到 运行时常量池中</li>
<li>字符串常量池：在HotSpot 虚拟机中，使用StringTable来存储 String 对象的引用，即来实现字符串常量池，StringTable 本质上是HashSet<string>，所以里面的内容是不可以重复的。一般来说，说一个字符串存储到了字符串常量池也就是说在StringTable中保存了对这个String 对象的引用</string></li>
</ol>
<h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3>
<p>有了上面的概念之后，便可来描述下述过程了<br>
首先给出结论，<strong>“在类的解析阶段，虚拟机便会在创建String 对象，并把String对象的引用存储到字符串常量池中”。</strong></p>
<ol>
<li>当*.java 文件 编译为*.class 文件时，字符串会像其他常量一样存储到class 文件中的常量池表中，对应于CONSTANT_String_info和CONSTANT_Utf8_info类型；</li>
<li>类加载时，会把静态常量池中的内容存放到方法区中的运行时常量池中，其中CONSTANT_Utf8_info类型在类加载的时候就会全部被创建出来，即说明了加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，但是此时StringTable（字符串常量池）并没有相应的引用，在堆中也没有相应的对象产生；</li>
<li>遇到ldc字节码指令（该指令将int、float或String型常量值从常量池中推送至栈顶）之前会触发解析阶段，进入到解析阶段，若在解析的过程中发现StringTable已经有与CONSTANT_String_info一样的引用，则返回该引用，若没有，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；</li>
</ol>
<h3 id="具体示例"><a class="markdownIt-Anchor" href="#具体示例"></a> 具体示例</h3>
<p>下面给出几个具体实例，来说下这个过程：</p>
<ul>
<li><strong>字面量的形式创建字符串</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    String name = &quot;HB&quot;;</span><br><span class="line">    String name2 = &quot;HB&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过javap 反编译后的字节码代码如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 = String  #14 </span><br><span class="line">#14 = utf8    HB</span><br><span class="line">……</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=3, args_size=1</span><br><span class="line">         0: ldc           #2  // String HB</span><br><span class="line">         2: astore_1     </span><br><span class="line">         3: ldc           #2  // String HB</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>当编译成字节码文件后，字面量&quot;HB&quot; 会存储到常量类型 CONSTANT_Utf8_info中，类加载时，其也会随之加载到方法区中的运行时常量池中，接下来可以用此来在StringTable查询是否有匹配的String 对象引用（当然只是简化的说法，具体CONSTANT_Utf8_info还指向一个Symbol对象~）；遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；astore_1指令把返回的引用存到本地变量name； 遇到二个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）已经有与CONSTANT_String_info一样的引用，则直接返回即可，并通过astore_2 指令将其返回的引用保存到本地变量 name2中</p>
<ul>
<li><strong>new 创建字符串</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test2&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    String name = new String(&quot;HB&quot;);</span><br><span class="line">    String name2 = new String(&quot;HB&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过javap 反编译后的字节码代码如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: new           #2  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3 // String HB</span><br><span class="line">         6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #2 // class java/lang/String</span><br><span class="line">        13: dup</span><br><span class="line">        14: ldc           #3 // String HB</span><br><span class="line">        16: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure>
<p>使用了关键字new后，会有稍微不同，new 指令会在堆中创建一个新的String 对象，并将其引用值压入栈顶，通过dup指令 复制栈顶的新对象的引用值并把复制值压入栈顶，本地变量name 所保存的值就为该引用值；接下来在遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用, 所以在运行时，会创建两个String对象哦~接下来的过程和前面的差不多，就不一一叙述啦！</p>
<ul>
<li><strong>其他重要值得关注的示例</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;hb&quot;);</span><br><span class="line">String s2 = &quot;hb&quot;;</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line">String s3 = s1.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s2 == s3);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s5 = &quot;hb&quot; + &quot;haha&quot;;  // 虚拟机会优化进行优化, 当成一个整体 &quot;hbhaha&quot;成立, 而不会用StringBuild::append()处理</span><br><span class="line">String s6 = &quot;hbhaha&quot;;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String temp = &quot;hb&quot;;</span><br><span class="line">String s7 = temp + &quot;haha&quot;; // 采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s7 == s6);  // false</span><br><span class="line">String s8 = s7.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s8 == s6); // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s9 = new String(&quot;hb&quot;) + new String(&quot;haha&quot;);  //采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s9 == s6); // false</span><br><span class="line">String s10 = s9.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s10 == s6); // true</span><br><span class="line"></span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s11 = new StringBuilder(&quot;hello&quot;).append(&quot; world&quot;).toString();</span><br><span class="line">System.out.println(s11 == s11.intern()); // true - 一个很特殊的例子, intern()方法会把s11引用放入到字符串常量池中</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s12 = new StringBuilder(&quot;hello&quot;).append(&quot; java&quot;).toString();</span><br><span class="line">String s13 = &quot;hello java&quot;;</span><br><span class="line">System.out.println(s12 == s12.intern()); // false - 一个很特殊的例子, intern()方法返回s13 在常量池中的引用</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>String 对象存在于堆中，字符串常量池存放了它们的引用</li>
<li>字符串常量池存储String对象的引用，且是全局共享的，相同的字符串都将指向同一个字符串对象</li>
<li>运行时创建的字符串（new）关键字 和 “” (字面量形式) 创建的字符串存在不同</li>
<li>检查字符串是否相同的最好方法是 equal()</li>
<li>可以通过String:: intern() 方法从常量池中得到String对象的引用，或 将String 对象的引用存入到 字符串常量池中</li>
<li>上述所有的实验都是在JDK 8 HotSpot虚拟机下进行的，在JDK 7 中HotSpot，字符串常量池移到了堆中哦~，所以不同JDK版本，不同虚拟机下可能存在差异</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>[1] <a href="https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html" rel="external nofollow noopener noreferrer" target="_blank">https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>
[2] <a href="https://www.iteye.com/blog/rednaxelafx-774673#comments" rel="external nofollow noopener noreferrer" target="_blank">https://www.iteye.com/blog/rednaxelafx-774673#comments</a><br>
[3] <a href="https://www.zhihu.com/question/55994121/answer/408891707" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/55994121/answer/408891707</a><br>
[4] <a href="https://www.cnblogs.com/Kidezyq/p/8040338.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/Kidezyq/p/8040338.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/小小String对象大大奥秘.html">http://www.huangbin.fun/小小String对象大大奥秘.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/重新认识时间复杂度.html"><i class="fa fa-chevron-left">  </i><span>重新认识时间复杂度</span></a></div><div class="next-post pull-right"><a href="/Redis-缓存设计-缓存穿透-雪崩-击穿.html"><span>Redis 缓存设计 - 缓存穿透/雪崩/击穿</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>