<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[转] J.U.C之线程池"><meta name="keywords" content="J.U.C"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>[转] J.U.C之线程池 | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text"> 背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#普通方式创建线程弊端"><span class="toc-number">1.1.</span> <span class="toc-text"> 普通方式创建线程弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的优势"><span class="toc-number">1.2.</span> <span class="toc-text"> 线程池的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池概述"><span class="toc-number">2.</span> <span class="toc-text"> 线程池概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池创建参数"><span class="toc-number">2.1.</span> <span class="toc-text"> 线程池创建参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池执行流程"><span class="toc-number">2.2.</span> <span class="toc-text"> 线程池执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池源码分析"><span class="toc-number">3.</span> <span class="toc-text"> 线程池源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主要变量"><span class="toc-number">4.</span> <span class="toc-text"> 主要变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execute方法"><span class="toc-number">4.1.</span> <span class="toc-text"> execute方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker内部类"><span class="toc-number">4.2.</span> <span class="toc-text"> Worker内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addworker方法"><span class="toc-number">4.3.</span> <span class="toc-text"> addWorker方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addworkerfailed方法"><span class="toc-number">4.4.</span> <span class="toc-text"> addWorkerFailed方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryterminate方法"><span class="toc-number">4.5.</span> <span class="toc-text"> tryTerminate方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runworker方法"><span class="toc-number">4.6.</span> <span class="toc-text"> runWorker方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gettask方法"><span class="toc-number">4.7.</span> <span class="toc-text"> getTask方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processworkerexit方法"><span class="toc-number">4.8.</span> <span class="toc-text"> processWorkerExit方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">[转] J.U.C之线程池</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Concurrency/">Concurrency</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6.7k</span><span class="post-meta__separator">|</span><span>Reading time: 24 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>线程池化主要因为普通方式创建线程的弊端以及线程池的优势：</p>
<h3 id="普通方式创建线程弊端"><a class="markdownIt-Anchor" href="#普通方式创建线程弊端"></a> 普通方式创建线程弊端</h3>
<ol>
<li>每次new Thread新建对象，性能差；</li>
<li>线程缺乏统一的管理，可能无限制创建线程，相互竞争，有可能占用过多的系统资源导致OOM；</li>
<li>缺乏更多的功能，例如定期执行，线程中断。</li>
</ol>
<h3 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势"></a> 线程池的优势</h3>
<ol>
<li>资源可控性：使用线程池可以避免创建大量线程而导致内存的消耗，还可以有效控制最大并发线程数，提高系统利用率；</li>
<li>提高响应速度：线程池的创建实际上是很消耗时间和性能的，但是线程池创建好之后有任务就运行，提升响应速度；</li>
<li>便于管理：池化技术最突出的一个特点就是可以帮助我们对线程池里的资源进行管理，由线程池统一分配和管理；</li>
<li>功能丰富：提供了定时执行，定期执行，单线程和并发数控制等功能。</li>
</ol>
<h2 id="线程池概述"><a class="markdownIt-Anchor" href="#线程池概述"></a> 线程池概述</h2>
<h3 id="线程池创建参数"><a class="markdownIt-Anchor" href="#线程池创建参数"></a> 线程池创建参数</h3>
<p>Executors的工厂方法就给我们提供了创建多种不同线程池的方法。因为这个类只是一个创建对象的工厂，并没有涉及到很多的具体实现，具体的实现由 ThreadPoolExecutor实现。<br>
就拿newFixedThreadPool来说明线程池创建所需要的参数。newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<ol>
<li>corePoolSize（核心线程池大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，当任务数大于核心线程数的时候就不会再创建。在这里要注意一点，线程池刚创建的时候，其中并没有创建任何线程，而是等任务来才去创建线程，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法 ，这样才会预先创建好corePoolSize个线程或者一个线程；</li>
<li>maximumPoolSize（线程池最大线程数）：线程池允许创建的最大线程数，如果阻塞队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界队列，此参数就没有意义了。</li>
<li>poolSize（线程池中已有线程数量），corePoolSize，maximumPoolSize三者关系
<ul>
<li>poolSize &lt; corePoolSize，新增一个线程处理任务；</li>
<li>poolSize = corePoolSize，将任务放到阻塞队列中等待执行；</li>
<li>阻塞队列已满，且poolSize &lt; maximumPoolSize，新增一个线程处理任务；</li>
<li>阻塞队列已满，且poolSize = maximumPoolSize，线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务。</li>
</ul>
</li>
<li>handler（饱和策略）：当线程池和队列都满了，说明线程池已经处于饱和状态了，那么必须采取一种策略来处理还在提交过来的新任务。这个饱和策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。共有四种饱和策略提供，我们也可以选择自己实现饱和策略。
<ul>
<li>AbortPolicy：直接丢弃并且抛出RejectedExecutionException异常；</li>
<li>CallerRunsPolicy：调用当前线程池的所在的线程去执行被拒绝的任务；</li>
<li>DiscardOldestPolicy：当任务被拒绝时，会抛弃任务队列中最旧的任务，也就是最先加入队列的，再把这个新任务添加进去；</li>
<li>DiscardPolicy：被线程池拒绝的任务直接丢弃，并且不抛出异常。<br>
参考链接：<a href="https://www.jianshu.com/p/9fec2424de54" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/9fec2424de54</a></li>
</ul>
</li>
<li>keepAliveTime（线程活动保持时间）：此参数默认在线程数大于corePoolSize的情况下才会起作用， 当线程的空闲时间达到keepAliveTime的时候就会终止，直至线程数目小于corePoolSize。不过如果调用了allowCoreThreadTimeOut方法，则当线程数目小于corePoolSize的时候也会起作用。</li>
<li>unit(keelAliveTime的时间单位)：keelAliveTime的时间单位，一共有7种。</li>
<li>workQueue（阻塞队列）：阻塞队列，用来存储等待执行的任务，主要以下几个阻塞队列。
<ul>
<li>ArrayBlockingQueue：这是一个基于数组结构的有界阻塞队列，此队列按照FIFO的原则对元素进行排序；</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按照FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()就是使用了这个队列；</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()就使用了这个队列；</li>
<li>PriorityBlockingQueue：一个具有优先级的阻塞队列。</li>
</ul>
</li>
</ol>
<h3 id="线程池执行流程"><a class="markdownIt-Anchor" href="#线程池执行流程"></a> 线程池执行流程</h3>
<p>线程池的执行大致执行流程如下：</p>
<img src="/J-U-C之线程池-转/线程池执行流程.jpg" title="线程池执行流程">
<h2 id="线程池源码分析"><a class="markdownIt-Anchor" href="#线程池源码分析"></a> 线程池源码分析</h2>
<p>线程池的关键方法实现都是ThreadPoolExecutor来完成的，所以具体的源码分析集中对ThreadPoolExecutor类的分析。</p>
<h2 id="主要变量"><a class="markdownIt-Anchor" href="#主要变量"></a> 主要变量</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ctl使用32位来表示一组复合变量：</span><br><span class="line">// 前3位：线程池的运行状态</span><br><span class="line">// 后29位：线程池中有效的线程个数</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">// 表示线程池数量的位数,Iteger.SIZE - 3 = 29</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">//线程池最大数量，2^29 - 1</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">/// 线程池状态由ctl的高三位进行存储, 共有5中状态</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// 计算线程池状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// 计算线程池线程数量</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// 根据线程池状态和线程个数计算ctl</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">//用于存放线程任务的阻塞队列</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">//重入锁 - 保证向线程池中添加线程是线程同步的</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 线程池当中的线程集合,只有当拥有mainLock锁的时候，才可以进行访问</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">// 支持对线程进行条件性的阻塞和唤醒</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">//创建新线程的线程工厂</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">// 饱和拒绝策略</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure>
<p>上面的很多计算都涉及位运算，下面对一些运算进行说明：</p>
<ol>
<li>
<p>CAPACITY计算</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// 1 &lt;&lt; COUNT_BITS</span><br><span class="line"></span><br><span class="line">// 1的32位2进制是</span><br><span class="line">// 00000000 00000000 00000000 00000001</span><br><span class="line"></span><br><span class="line">// 左移29位的话就是</span><br><span class="line">// 00100000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">// 再进行减一的操作</span><br><span class="line">// 000 11111 11111111 11111111 11111111</span><br><span class="line"></span><br><span class="line">// 也就是说线程池最大数目就是</span><br><span class="line">// 000 11111 11111111 11111111 11111111</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>RunState计算<br>
在计算机底层使用补码来进行表示符号数。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以接受新任务并且处理已经在阻塞队列的任务 - 高三位全是1</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 不接受新任务，但是处理已经在阻塞队列的任务 - 高三位全是0</span><br><span class="line">private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 不接受新任务，也不处理阻塞队列里的任务，并且会中断正在处理的任务 - 高三位001</span><br><span class="line">private static final int STOP = 1 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 所有任务都被中止，workerCount为0，线程状态转化为TIDYING并且调用terminated()钩子方法 - 高3位是010</span><br><span class="line">private static final int TIDYING    = 2 &lt;&lt; COUNT_BITS;</span><br><span class="line">// 线程已经终止, terminated()钩子方法已经完成 - 高三位011</span><br><span class="line">private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// 以RUNNING为例进行计算</span><br><span class="line">// -1 &lt;&lt; COUNT_BITS</span><br><span class="line">     ​</span><br><span class="line">// -1的原码</span><br><span class="line">                  ​</span><br><span class="line">// -1的反码,负数的反码是将原码除符号位以外全部取反</span><br><span class="line">// 11111111 11111111 11111111 11111110</span><br><span class="line">                  ​</span><br><span class="line">// -1的补码,负数的补码就是将反码+1</span><br><span class="line">// 11111111 11111111 11111111 11111111</span><br><span class="line">                 ​</span><br><span class="line">// 往左移29位,所以高3位全是1就是RUNNING状态</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>runStateOf方法<br>
获取当前线程池的运行状态。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// c &amp; ~CAPACITY</span><br><span class="line">// ~是按位取反的意思</span><br><span class="line">//&amp;是按位与的意思</span><br><span class="line">                    ​</span><br><span class="line">// 而CAPACITY是，高位3个0，低29位都是1，所以是</span><br><span class="line">000 11111 11111111 11111111 11111111</span><br><span class="line">                   ​</span><br><span class="line">// 取反的话就是</span><br><span class="line">111 00000 00000000 00000000 00000000</span><br><span class="line">                  ​</span><br><span class="line">// 传进来的c参数与取反的CAPACITY进行按位与操作</span><br><span class="line">// 1、低位29个0进行按位与，还是29个0</span><br><span class="line">// 2、高位3个1，既保持c参数的高3位</span><br><span class="line">// 既高位保持原样，低29位都是0，这也就获得了线程池的运行状态runState</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>workerCountOf方法<br>
获取线程池的当前有效线程数目。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// CAPACITY的32位2进制是</span><br><span class="line">000 11111 11111111 11111111 11111111</span><br><span class="line">                   ​</span><br><span class="line">// 用入参c跟CAPACITY进行按位与操作</span><br><span class="line">// 1、低29位都是1，所以保留c的低29位，也就是有效线程数</span><br><span class="line">// 2、高3位都是0，所以c的高3位也是0</span><br><span class="line">// 这样获取出来的便是workerCount的值</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ctlOf方法<br>
初始化ctl变量。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">                 ​</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">// RUNNING是</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br><span class="line">                    ​</span><br><span class="line">// ctlOf是将rs和wc进行按位或的操作</span><br><span class="line">                  ​</span><br><span class="line">// 初始化的时候是将RUNNING和0进行按位或</span><br><span class="line">// 0的32位2进制是</span><br><span class="line">// 00000000 00000000 00000000 00000000</span><br><span class="line">                   ​</span><br><span class="line">// 所以初始化的ctl是</span><br><span class="line">// 111 00000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="execute方法"><a class="markdownIt-Anchor" href="#execute方法"></a> execute方法</h3>
<p>execute方法提交了一个任务给线程池进行执行，可能是根据任务创建一个worker对象执行，或者将任务加入到阻塞队列中等待执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    //需要执行的任务command为空,抛出空指针异常</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    // 执行的流程实际上分为三步</span><br><span class="line">    // 1. 如果运行的线程小于corePoolSize，以用户给定的Runable对象新开一个线程去执行</span><br><span class="line">    // 并且执行addWorker方法会以原子性操作去检查runState和workerCount，以防止出现线程安全性问题</span><br><span class="line">    // 2. 如果任务能够成功添加到队列当中，我们仍需要对添加的线程进行双重检查，有可能添加的线程在 前一次检查时已经死亡，又或者在进入该方法的时候线程池关闭了</span><br><span class="line">    // 所以我们需要复查状态，并有必要的话需要在停止时回滚入列操作，或者在没有线程的时候新开一个线程</span><br><span class="line">    //3.  如果任务无法入列，那我们需要尝试新增一个线程，如果新建线程失败了，我们就知道线程可能关闭了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //获取线程池的运行状态</span><br><span class="line">    int c = ctl.get(); </span><br><span class="line"></span><br><span class="line">    //通过workCountOf方法算workerCount值, 若小于corePoolSize,</span><br><span class="line">    // 则新建一个线程来执行当前任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        //添加任务到worker集合当中</span><br><span class="line">        if (addWorker(command, true)) </span><br><span class="line">            //成功返回</span><br><span class="line">            return;</span><br><span class="line">        //失败的话再次获取线程池的运行状态</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 判断线程池是否正处于RUNNING状态, 是的话添加Runnable对象到workQueue队列当中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">         //再次获取线程池的状态</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        //再次检查状态</span><br><span class="line">        //线程池不处于RUNNING状态, 将任务从workQueue队列中移除, 进行回滚</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            //拒绝任务</span><br><span class="line">            reject(command);</span><br><span class="line">            //workerCount等于0, 创建线程来执行阻塞队列中的任务</span><br><span class="line">        else if (workerCountOf(recheck) == 0)  </span><br><span class="line">            //添加worker</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    //加入阻塞队列失败, 则尝试以线程池最大线程数新开线程去执行该任务</span><br><span class="line">    else if (!addWorker(command, false)</span><br><span class="line">        //拒绝任务</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行流程如下：</p>
<ol>
<li>首先判断任务是否为空，空则抛出空指针异常；</li>
<li>不为空则获取线程池控制状态，判断是否小于corePoolSize，若小于，则添加到worker集合当中执行，如成功，则返回，如果失败的话再接着获取线程池控制状态，因为只有状态变了才会失败（失败的原因可能是WorkerCount改变，使得其大于corePoolSize），所以重新获取线程池状态；</li>
<li>判断线程池是否处于运行状态，是的话则添加任务到阻塞队列，加入时也会再次获取状态并且检测状态是否处于运行状态，不处于的话则将任务从阻塞队列移除，并且拒绝任务；</li>
<li>如果线程池里没有了线程，则创建新的线程去阻塞队列中获取任务执行；</li>
<li>如果以上都没执行成功，则需要开启最大线程池里的线程来执行任务，失败的话就丢弃。</li>
</ol>
<img src="/J-U-C之线程池-转/线程池执行流程2.jpg" title="线程池执行流程2">
<h3 id="worker内部类"><a class="markdownIt-Anchor" href="#worker内部类"></a> Worker内部类</h3>
<p>Worker内部类是对执行任务线程和执行任务的封装。它继承AQS同步器并且实现了Runnable接口，所以Worker很明显就是一个可执行任务并且又可以控制中断和锁效果的类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer</span><br><span class="line">implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">       </span><br><span class="line">    private static final long serialVersionUID = 6138294804551838833L;</span><br><span class="line"></span><br><span class="line">    // 工作线程</span><br><span class="line">    final Thread thread;</span><br><span class="line">    // 初始化任务，可能为空</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    // 已完成任务数量</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 创建并初始化第一个任务, 使用线程工厂来创建线程</span><br><span class="line">    // 初始化有3步</span><br><span class="line">    // 1. 设置AQS的同步状态为-1, 表示该对象需要被唤醒</span><br><span class="line">    // 2. 初始化第一个任务</span><br><span class="line">    // 3.调用ThreadFactory来使自身创建一个线程, 并赋值给worker的成员变量thread</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-1); </span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">        this.thread = getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">    // 重写Runnable的run方法</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //调用ThreadPoolExecutor的runWorker方法来执行任务</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //代表是否独占锁，0-非独占  1-独占</span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写AQS的tryAcquire方法尝试获取锁</span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        //尝试将AQS的同步状态从0改为1</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            //如果改变成，则将当前独占模式的线程设置为当前线程并返回true</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写AQS的tryRelease尝试释放锁</span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        //设置当前独占模式的线程为null</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        //设置AQS同步状态为0</span><br><span class="line">        setState(0);</span><br><span class="line">        //返回true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取锁</span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    //尝试获取锁</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    //释放锁</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    //是否被独占</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addworker方法"><a class="markdownIt-Anchor" href="#addworker方法"></a> addWorker方法</h3>
<p>addWorker方法主要用来生成worker对象，该对象包括了要执行了任务和执行任务的线程，并向workers集合中添加worker对象，并且启动线程，开始任务的执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    //外部循环标记</span><br><span class="line">    retry:</span><br><span class="line">    // 最外层自旋</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //获取线程运行状态</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 1. 如果线程池runState至少已经是SHUTDOWN</span><br><span class="line">        // 2. 有一个是false则addWorker失败</span><br><span class="line">        // - runState == SHUTDOWN, 即状态已经大于SHUTDOWN了</span><br><span class="line">        // - firstTask == null, 即传进来的任务为空, 结合上面就是runState是SHUTDOWN, 但是</span><br><span class="line">        // firstTask不为空, 代表线程池已经关闭了还在传任务进来</span><br><span class="line">        // - 队列为空, 既然任务已经为空, 队列为空, 就不需要往线程池添加任务了</span><br><span class="line"></span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;  </span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;  </span><br><span class="line">        firstTask == null &amp;&amp;  </span><br><span class="line">        ! workQueue.isEmpty()))  </span><br><span class="line">            return false;</span><br><span class="line">        ​</span><br><span class="line">        //内层自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取线程池的workerCount数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            //如果workerCount超出最大值或者大于corePoolSize/maximumPoolSize</span><br><span class="line">            //返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">            wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            //通过CAS操作，使workerCount数量+1，成功则跳出循环，回到retry标记</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line"></span><br><span class="line">            //CAS操作失败，再次获取线程池的控制状态</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            //如果当前runState不等于刚开始获取的runState，则跳出内层循环，继续外层循环</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            //CAS由于更改workerCount而失败，继续内层循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    //通过以上循环，能执行到这是workerCount成功+1了</span><br><span class="line">    //worker开始标记</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    //worker添加标记</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    //初始化worker为null</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //初始化一个当前Runnable对象的worker对象</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        //获取该worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        //如果线程不为null</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            //初始线程池的锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            //获取锁，保证添加worker的同步线程安全</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取锁后再次检查，获取线程池runState</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                ​</span><br><span class="line">                //当runState小于SHUTDOWN或者runState等于SHUTDOWN并且firstTask为null</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line"></span><br><span class="line">                    //线程已存活</span><br><span class="line">                    if (t.isAlive()) </span><br><span class="line">                        //线程未启动就存活，抛出IllegalThreadStateException异常</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                    //将worker对象添加到workers集合当中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    //获取workers集合的大小</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //如果大小超过largestPoolSize</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        //重新设置largestPoolSize</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    //标记worker已经被添加</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            //如果worker添加成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                //启动线程，开始执行任务</span><br><span class="line">                t.start();</span><br><span class="line">                //标记worker已经启动</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    //如果worker没有启动成功</span><br><span class="line">    if (! workerStarted)</span><br><span class="line">        //workerCount-1的操作</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回worker是否启动的标记</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行流程如下：</p>
<ol>
<li>获取线程池的控制状态，进行判断，不符合则返回false，符合则下一步；</li>
<li>进行一个内层的自旋操作，判断workerCount是否大于上限，或者大于corePoolSize/maximumPoolSize，若不符合要求则返回false，否则对workerCount+1操作；</li>
<li>若workerCount + 1操作失败，再次获取线程池的控制状态，获取runState与刚开始获取的runState相比，不一致则跳出内层循环继续外层循环，否则继续内层循环；</li>
<li>workerCount + 1操作成功后，使用重入锁ReentrantLock来保证往workers当中添加worker实例的线程安全性，添加成功就启动该实例。</li>
</ol>
<img src="/J-U-C之线程池-转/线程池执行流程3.jpg" title="线程池执行流程">
<h3 id="addworkerfailed方法"><a class="markdownIt-Anchor" href="#addworkerfailed方法"></a> addWorkerFailed方法</h3>
<p>addWorker方法添加worker失败，并且没有成功启动任务的时候，就会调用此方法，将任务从workers中移除，并且workerCount - 1操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    //重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //如果worker不为null</span><br><span class="line">        if (w != null)</span><br><span class="line">            //workers移除worker</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        //通过CAS操作，workerCount-1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        // 执行tryTerminate尝试终止线程池</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="tryterminate方法"><a class="markdownIt-Anchor" href="#tryterminate方法"></a> tryTerminate方法</h3>
<p>当对线程池执行了非正常成功逻辑的操作时，都会需要执行tryTerminate尝试终止线程池。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finavoid tryTerminate() &#123;</span><br><span class="line">     //自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line"></span><br><span class="line">        // 线程池处于RUNNING状态</span><br><span class="line">        // 线程池状态最小大于TIDYING, 已经终止</span><br><span class="line">        // 线程池==SHUTDOWN并且workQUeue不为空</span><br><span class="line">        // 直接return, 不能终止</span><br><span class="line">         </span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">        runStateAtLeast(c, TIDYING) ||</span><br><span class="line">        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        //如果workerCount不为0,且runState为STOP, 中断正在处理的任务</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; </span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取线程池的锁, 开始终止线程池</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        //获取锁</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过CAS操作，设置线程池状态为TIDYING</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //设置线程池的状态为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    //发送释放信号给在termination条件上等待的线程</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runworker方法"><a class="markdownIt-Anchor" href="#runworker方法"></a> runWorker方法</h3>
<p>runWorker由worker对象的run方法调用，达到真正执行任务的作用。执行的任务可能来自worker对象本身，或者来自阻塞队列。该方法使用一个while循环不断从阻塞队列中获取任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    //获取当前线程</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    //获取worker里的任务</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    //将worker实例的任务赋值为null</span><br><span class="line">    w.firstTask = null;</span><br><span class="line"></span><br><span class="line">    // unlock方法会调用AQS的release方法</span><br><span class="line">    // release方法会调用具体实现类也就是Worker的tryRelease方法</span><br><span class="line">    // 也就是将AQS状态置为0, 允许中断</span><br><span class="line">    w.unlock(); </span><br><span class="line">    //是否突然完成</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // worker实例的task不为空, 或者通过getTask获取的不为空</span><br><span class="line">        // getTask方法会从阻塞队列获取任务进行执行</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            //获取锁</span><br><span class="line">            w.lock();</span><br><span class="line">                       </span><br><span class="line">            // 满足下面两个条件将中断该线程</span><br><span class="line">            // 1. 获取线程池的控制状态，至少要大于STOP状态</span><br><span class="line">            // 2. 检查当前线程是否中断并清除中断状态，并且再次检查线程池状态是否大于STOP</span><br><span class="line">            // 如果上述满足，检查该对象是否处于中断状态，不清除中断标记</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">            (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">            !wt.isInterrupted())</span><br><span class="line">                //中断该线程</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                //执行任务之前调用的方法, 由子类具体实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //执行任务</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //执行任务之后调用的方法, 也是由子类具体实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ////执行完后, 设置task为null</span><br><span class="line">                task = null;</span><br><span class="line">                //已完成任务数+1</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                //释放锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //处理并退出当前worker</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的执行流程如下：</p>
<ol>
<li>首先执行了w.unlock()，这是为了将AQS的状态改为0，因为只有getState() &gt;= 0的时候，线程才可以被中断；</li>
<li>判断firstTask是否为空，为空则通过getTask()取阻塞对象中获取任务，不为空接着往下执行；</li>
<li>判断是否符合中断状态，符合的话设置中断标记；</li>
<li>执行beforeExecute()，task.run()，afterExecute()方法；</li>
<li>任何一个出异常都会导致任务执行的终止，进入processWorkerExit来退出任务；</li>
<li>正常执行的话会接着回到步骤2，继续向下执行任务。</li>
</ol>
<img src="/J-U-C之线程池-转/线程池执行流程4.jpg" title="线程池执行流程4">
<h3 id="gettask方法"><a class="markdownIt-Anchor" href="#gettask方法"></a> getTask方法</h3>
<p>当firstTask为空的时候，会通过该方法去阻塞队列来接着获取任务去执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    //标志是否获取任务超时</span><br><span class="line">    boolean timedOut = false; </span><br><span class="line">    //自旋操作</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取线程池的控制状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //获取线程池的runState</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 判断线程池的状态，出现以下两种情况</span><br><span class="line">        // 1. runState大于等于SHUTDOWN状态</span><br><span class="line">        // 2. runState大于等于STOP或者阻塞队列为空</span><br><span class="line">        // 将会通过CAS操作，进行workerCount - 1并返回null</span><br><span class="line"></span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取线程池的workerCount</span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // allowCoreThreadTimeOut：是否允许core Thread超时, 默认false</span><br><span class="line">        // workerCount是否大于核心核心线程池, 除了core thread外, 其他线程会有超时操作</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        // 1. wc大于maximumPoolSize或者已超时</span><br><span class="line">        // 2. 队列不为空时保证至少有一个任务</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">        &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">             </span><br><span class="line">            // 通过CAS操作，workerCount - 1</span><br><span class="line">            //能进行-1操作，证明wc大于maximumPoolSize或者已经超时</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                //workCount - 1操作成功，返回null</span><br><span class="line">                return null;</span><br><span class="line">            // workCount - 1操作失败，继续循环</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            // 是否允许超时将会调用不同的方法来获取任务</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">            workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            //判断任务不为空返回任务</span><br><span class="line">            if (r != null)</span><br><span class="line">            return r;</span><br><span class="line">            //获取一段时间没有获取到，获取超时</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的执行流程如下：</p>
<ol>
<li>获取线程池控制状态和runState，判断线程池是否已经关闭或者正在关闭，是的话则workerCount - 1操作并返回null；</li>
<li>获取workerCount判断是否大于核心线程池，并且根据allowCoreThreadTimeOut和 wc &gt; corePoolSize判断是否允许超时操作；</li>
<li>判断workerCount是否大于最大线程池数目或者已经超时，是的话进行workerCount - 1操作，操作成功则返回null，不成功则回到步骤1重新继续；</li>
<li>根据timed采用何种方法来获取任务，timed 位true 则用poll方法从队列获取任务，否则用take方法从队列获取任务；</li>
<li>判断任务是否为空，不为空则返回获取的任务，否则回到步骤1重新继续。</li>
</ol>
<img src="/J-U-C之线程池-转/线程池执行流程5.jpg" title="线程池执行流程5">
<h3 id="processworkerexit方法"><a class="markdownIt-Anchor" href="#processworkerexit方法"></a> processWorkerExit方法</h3>
<p>任务执行完成或出现异常中断执行的时候，调用processWorkerExit方法进行相对应的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // completedAbruptly:在runWorker出现, 代表是否突然完成的意思</span><br><span class="line">    // 也就是在执行任务过程当中出现异常，就会突然完成，设置为true</span><br><span class="line">      </span><br><span class="line">    // 如果是突然完成，需要通过CAS操作, workerCount - 1</span><br><span class="line">    // 不是突然完成，则不需要 - 1, 因为getTask方法当中已经-1</span><br><span class="line">    if (completedAbruptly) </span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    //生成重入锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //获取锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //线程池统计的完成任务数completedTaskCount加上worker当中完成的任务数</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        //从HashSet&lt;Worker&gt;中移除</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //因为上述操作是释放任务或线程, 所以会判断线程池状态,尝试终止线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    //获取线程池的控制状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line"></span><br><span class="line">    //判断runState是否小于STOP，即是RUNNING或者SHUTDOWN</span><br><span class="line">    //如果是RUNNING或者SHUTDOWN, 代表没有成功终止线程池</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            </span><br><span class="line">        // 是否突然完成</span><br><span class="line">        // 如若不是, 代表已经没有任务可获取完成, 因为getTask当中是while循环</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line"></span><br><span class="line">            // allowCoreThreadTimeOut: 是否允许core thread超时，默认false</span><br><span class="line">            // min-默认是corePoolSize</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line"></span><br><span class="line">            //允许core thread超时并且队列不为空</span><br><span class="line">            //min为0, 即允许core thread超时, 这样就不需要维护核心核心线程池了</span><br><span class="line">            //如果workQueue不为空，则至少保持一个线程存活</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">             </span><br><span class="line">            //如果workerCount大于min, 则表示满足所需, 可以直接返回</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; </span><br><span class="line">        &#125;</span><br><span class="line">        //如果是突然完成，添加一个空任务的worker线程</span><br><span class="line">        addWorker(null, false); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的执行流程如下：</p>
<ol>
<li>首先判断线程是否突然终止，如果是突然终止，则workerCount - 1；</li>
<li>统计线程池完成任务数，并将worker从workers当中移除；</li>
<li>判断线程池状态，尝试终止线程池；</li>
<li>线程池没有成功终止，判断是否突然完成任务，不是则进行下一步
<ul>
<li>如允许核心线程超时，队列不为空，则至少保证一个线程存活；</li>
<li>添加一个空任务的worker线程。</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>[1] <a href="https://www.cnblogs.com/KingJack/p/9595621.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/KingJack/p/9595621.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/J-U-C之线程池-转.html">http://www.huangbin.fun/J-U-C之线程池-转.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J-U-C/">J.U.C</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/转-Fork-Join框架.html"><i class="fa fa-chevron-left">  </i><span>[转] Fork/Join框架</span></a></div><div class="next-post pull-right"><a href="/J-U-C-之阻塞队列.html"><span>J.U.C 之阻塞队列</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>