<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HB&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangbin.fun/"/>
  <updated>2020-11-23T12:57:35.324Z</updated>
  <id>http://www.huangbin.fun/</id>
  
  <author>
    <name>HB</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://www.huangbin.fun/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/经典排序算法.html</id>
    <published>2020-05-29T14:41:32.000Z</published>
    <updated>2020-11-23T12:57:35.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述"><a class="markdownIt-Anchor" href="#排序算法概述"></a> 排序算法概述</h2><h3 id="算法分类"><a class="markdownIt-Anchor" href="#算法分类"></a> 算法分类</h3><ol><li><p>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；</p></li><li><p>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p></li></ol><p>以下是常用的十一种排序算法：</p><img src="/经典排序算法/totalSort.png" title="totalSort"><h3 id="算法时间复杂度"><a class="markdownIt-Anchor" href="#算法时间复杂度"></a> 算法时间复杂度</h3><img src="/经典排序算法/time.png" title="time"><h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3><ol><li>稳定：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，且a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ol><h2 id="排序算法实现"><a class="markdownIt-Anchor" href="#排序算法实现"></a> 排序算法实现</h2><h3 id="公共代码实现"><a class="markdownIt-Anchor" href="#公共代码实现"></a> 公共代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 交换两个元素值</span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 得到最大值</span><br><span class="line">private int getMaxValue (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (maxValue &lt; nums[i]) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最小值</span><br><span class="line">private int getMinValue (int[] nums) &#123;</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (minValue &gt; nums[i]) &#123;</span><br><span class="line">           minValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#冒泡排序bubble-sort"></a> 冒泡排序（Bubble Sort）</h3><ol><li><p>概述<br>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;数列的顶端。</p></li><li><p>算法思路</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；</li><li>针对所有的元素重复以上的步骤，最后已排序好的元素不需要再次比较；</li><li>重复步骤1~3，直到排序完成。</li></ol> <img src="/经典排序算法/bubbleSort.gif" title="bubbleSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bubbleSort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 当最外层循环遍历完毕, 则代表着数组有序</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 从头开始依次两两比较, 比较结束条件为len - i - 1</span><br><span class="line">        for(int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">            // 比较相邻的两个元素, 若前者大于后者, 则进行交换</span><br><span class="line">            if (nums[j] &gt; nums[j + 1])&#123;</span><br><span class="line">                swap(nums, j + 1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序quick-sort"><a class="markdownIt-Anchor" href="#快速排序quick-sort"></a> 快速排序（Quick Sort）</h3><ol><li><p>概述<br>快速排序的基本思想是：通过一趟排序以基准元素为基础将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序（分别进行划分），整个排序过程可以递归进行，使整个数据变成有序序列。</p></li><li><p>算法思路</p><ol><li>数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置，该位置称为 K ；</li><li>根据第2步得到的基准元素位置 K，递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列进行1~2步的分区操作。</li></ol> <img src="/经典排序算法/QuickSort.gif" title="QuickSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sort (int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    quickSort(nums, 0, len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 - left &gt;= right时</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 2. 递进操作</span><br><span class="line">        // 递归排序分区, 返回基准元素所在位置</span><br><span class="line">        int partitionIndex = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, partitionIndex - 1);</span><br><span class="line">        quickSort(nums, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 选择最左边的数为基准元素</span><br><span class="line">    int pivot = left;</span><br><span class="line">    // 以基准元素为比较元素开始分区操作</span><br><span class="line">    int index = pivot + 1;</span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行 </span><br><span class="line">    index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, pivot, index - 1);</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排序优化<br>快速排序的运行时间与划分是否对称有关。最坏情况下，每次划分过程产生两个区域分别包含n-1个元素和1个元素，其时间复杂度会达到O(n^2)。在最好的情况下，每次划分所取的基准都恰好是中值，即每次划分都产生两个大小为n/2的区域。此时，快排的时间复杂度为O(nlogn)。所以基准的选择对快排而言至关重要。<br>如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。<br>为了解决上述问题，可以采用随机基准的方式来应对上述特殊情况。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">     </span><br><span class="line">    // 将随机选择一个元素作为基准元素</span><br><span class="line">    // Math.Random()函数能够返回带正号的double值, 该值大于等于0.0且小于1.0</span><br><span class="line">    int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 将随机索引处的元素与left处进行交换</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量index，其[pivot + 1,index)范围内的元素小于基准元素</span><br><span class="line">    int index = left + 1;</span><br><span class="line"></span><br><span class="line">    // 从 左-&gt;右开始扫描, 若基准元素值nums[pivot] &gt; nums[i], 则进行</span><br><span class="line">    // index 与 i 交换, 否则不进行交换, 保持不变   </span><br><span class="line">    // 2. 定义变量i，其[index, i - 1]范围内的元素大于基准元素</span><br><span class="line">    for(int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        // 3. 触发index变量转移条件，保证循环不变量定义正确</span><br><span class="line">        if (nums[i] &lt; nums[left]) &#123;</span><br><span class="line">            swap(nums, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放在正确的位置, 并返回基准元素的位置</span><br><span class="line">    swap(nums, left, index - 1);</span><br><span class="line">    // 4. 返回结果</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二路快速排序quick-sort-2-ways"><a class="markdownIt-Anchor" href="#二路快速排序quick-sort-2-ways"></a> 二路快速排序（Quick Sort 2 Ways）</h3><ol><li><p>概述<br>二路快速排序的时间和空间复杂度同随机化快速排序。 但是对于有大量重复元素的数组，如果使用随机化快速排序效率是非常低的，导致 partition 后大于基点或者小于基点数据的子数组长度会极度不平衡，甚至会退化成 O(n^2)时间复杂度的算法，对这种情况可以使用双路快速排序算法。</p></li><li><p>算法思路<br>双路快速排序算法是随机化快速排序的改进版本，partition 过程使用两个索引值（i、j）用来遍历数组，将  &lt;= V 的元素放在索引i所指向位置的左边，而将 &gt;= V的元素放在索引 j 所指向位置的右边，V 代表标定值，平衡左右两边子数组。</p> <img src="/经典排序算法/quickSort2.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void quickSort2ways (int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件</span><br><span class="line">    if (left &gt; right)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int index = partition2(nums, left, right);</span><br><span class="line">    quickSort3Ways(nums, left, index - 1);</span><br><span class="line">    quickSort3Ways(nums, index + 1, right);</span><br><span class="line"></span><br><span class="line">    // 3. 递归返回值 - 暂无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partition2(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 随机选择一个基准</span><br><span class="line">    int randomIndex = (int) (Math.random() * (right - left + 1) + left);</span><br><span class="line">    // 交换left和randomIndex的位置</span><br><span class="line">    swap(nums, left, randomIndex);</span><br><span class="line">    int v = nums[left];</span><br><span class="line"></span><br><span class="line">    // 1. 定义变量i, 其在[left + 1, i)范围中的元素 &lt;= v</span><br><span class="line">    //    定义变量j, 其在(j, right] 范围中的元素 &gt;= v</span><br><span class="line">    int i = left + 1, j = right;</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量i改变条件</span><br><span class="line">        while (i &lt;= right &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 触发循环不变量j改变条件</span><br><span class="line">        while (j &gt;= left + 1 &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 循坏退出条件</span><br><span class="line">        if (i &gt; j)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // 交换 i, j索引处元素</span><br><span class="line">        // 此时若 nums[i] == nums[j] == v, 也会进行交换</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将基准元素放置到正确位置上</span><br><span class="line">    swap(nums, left, j);</span><br><span class="line"></span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三路快速排序quick-sort-3-ways"><a class="markdownIt-Anchor" href="#三路快速排序quick-sort-3-ways"></a> 三路快速排序（Quick Sort 3 Ways）</h3><ol><li><p>概述<br>三路快速排序时间和空间复杂度同随机化快速排序。三路快速排序算法是使用三路划分策略对数组进行划分，对处理大量重复元素的数组非常有效提高快速排序的过程。它增加了处理等于基准元素值的逻辑，将所有等于基准元素的值集中在一起。</p></li><li><p>算法思路<br>三路快速排序是双路快速排序的进一步改进版本，三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，等于 v 的数据在下次递归中不再需要排序，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优。</p> <img src="/经典排序算法/quickSort3.png" title="quickSort3"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort3Ways(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 1. 递归结束条件 left &gt;= right</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        // 随机选择一个基准</span><br><span class="line">        int randomIndex = (int)(Math.random() * (right - left + 1) + left);</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        int curr = nums[left];</span><br><span class="line"></span><br><span class="line">        // 1. 定义lt为[left + 1, lt]中的元素小于curr</span><br><span class="line">        int lt = left;</span><br><span class="line">        // 1. 定义gt为[gt, r]中的元素大于curr</span><br><span class="line">        int gt = right + 1;</span><br><span class="line">        // 1. 定义[lt + 1, i) 中的元素等于curr</span><br><span class="line">        int i = left + 1;</span><br><span class="line"></span><br><span class="line">        // 2. 递归结束条件, i碰到了gt边界</span><br><span class="line">        while (i &lt; gt) &#123;</span><br><span class="line">            if (nums[i] &lt; curr) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                // 3. 触发变量</span><br><span class="line">                swap(nums, lt, i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (nums[i] &gt; curr) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums, i, gt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将基准元素放置在正确位置上</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line"></span><br><span class="line">        // 对[left, lt - 1] 进行处理</span><br><span class="line">        quickSort3Ways(nums, left, lt - 1);</span><br><span class="line">        // 对[gt, right] 进行处理</span><br><span class="line">        quickSort3Ways(nums, gt, right);</span><br><span class="line"></span><br><span class="line">        // 4. 返回结果 - 暂无</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入排序insertion-sort"><a class="markdownIt-Anchor" href="#插入排序insertion-sort"></a> 插入排序（Insertion Sort）</h3><ol><li><p>概述<br>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>算法思路</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出有序序列的下一个元素，作为待插入的新元素，在已经排序的元素序列中从后向前扫描；</li><li>如果有序序列中的元素大于新元素，则从后向前继续比较有序序列中的元素；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol> <img src="/经典排序算法/InsertionSort.gif" title="InsertionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void insertSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 从下标为1的元素开始选择合适的位置插入, 因为下标0默认是有序的</span><br><span class="line">    for(int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        // 需要插入的新元素</span><br><span class="line">        int curr = nums[i];</span><br><span class="line">        // 从已经排序的序列的最右-&gt;左开始比较</span><br><span class="line">        int j = i;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; curr) &#123;</span><br><span class="line">            // 进行数组的移动</span><br><span class="line">            nums[j] = nums[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到了插入位置</span><br><span class="line">    if(j != i)</span><br><span class="line">        nums[j] = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序shell-sort"><a class="markdownIt-Anchor" href="#希尔排序shell-sort"></a> 希尔排序（Shell Sort）</h3><ol><li><p>概述<br>希尔排序是简单插入排序的改进版，是基于插入排序的以下两点性质而提出的一种排序方法：</p><ol><li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  —&gt; 希尔排序会优先比较距离较远的元素，从而达到更远的移动距离；</li><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 —&gt; 希尔排序在整个序列&quot;基本有序&quot;的时候，直接采用插入排序来进行一次比较。<br>希尔排序又叫缩小增量排序。</li></ol></li><li><p>算法思路</p><ol><li>选择一个增量序列t1，t2，…，ti，tj，….tk，其中ti&gt;tj，tk=1，增量序列在排序的过程中不断递减；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各个子序列进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol> <img src="/经典排序算法/ShellSort.gif" title="ShellSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    int gap = 1;</span><br><span class="line">    </span><br><span class="line">    // 选择合适的初始值, 如果直接用len/3的话, 后面可能无法递减为1</span><br><span class="line">    while (gap &lt; len / 3)</span><br><span class="line">        gap = gap * 3 + 1;  // 1, 4, 13, 40, 121....  // Tk, Tk-1,.....,T1</span><br><span class="line">    </span><br><span class="line">    // 对序列进行k趟排序</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        // 从下标为gap的元素(从后往前)开始选择合适的位置插入, 因为子序列的第一个元素默认是有序的</span><br><span class="line">        for(int i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            int cur = nums[i];</span><br><span class="line">            int j = i - gap;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; nums[j] &gt; cur) &#123;</span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将新元素放置到正确位置, j + gap是因为while循环中最后进行了一次j = j - gap</span><br><span class="line">            nums[j + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        // 缩小增量</span><br><span class="line">        gap = gap / 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="选择排序shell-sort"><a class="markdownIt-Anchor" href="#选择排序shell-sort"></a> 选择排序（Shell Sort）</h3><ol><li><p>概述<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li><li><p>算法思路</p><ol><li>初始未排序区域为nums[0…nums.length - 1]</li><li>从未排序区域找到元素值最小的元素，将它和数组中第一个元素交换位置；未排序区域更新为nums[1…nums.length - 1]，从该区域找到第二个元素值最小的元素，将它和数组中第二个元素交换位置，如此反复，直到整个数组排序完成。</li></ol> <img src="/经典排序算法/SelectionSort.gif" title="SelectionSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void selectionSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 将nums[i] 与 nums[i+1..len - 1]中最小的元素交换</span><br><span class="line">        int min = i;</span><br><span class="line">        // 从无序区域找到一个最小的元素</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序heap-sort"><a class="markdownIt-Anchor" href="#堆排序heap-sort"></a> 堆排序（Heap Sort）</h3><ol><li><p>概述<br>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></li><li><p>算法思路</p><ol><li>初始化堆：堆将待排序序列构造成一个大顶堆/小顶堆（升序 - 大顶堆，降序 - 小顶堆），此时，整个序列的最大值就是堆顶的根节点；</li><li>将根节点与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n 个元素的次大值；</li><li>如此反复执行，便能得到一个有序序列。</li></ol> <img src="/经典排序算法/HeapSort.gif" title="HeapSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 堆排序算法</span><br><span class="line">public void heapSort(int[]arr)&#123;</span><br><span class="line">     //1.初始化堆,从最后一个非叶子节点从右向左,从下向上依次进行&quot;堆化&quot;</span><br><span class="line">    for(int i=(arr.length/2)-1; i&gt;=0; i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.依次交换栈顶元素和末尾元素和重新调整堆</span><br><span class="line">    for(int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);</span><br><span class="line">        adjustHeap(arr,0,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整堆</span><br><span class="line">public void adjustHeap(int[]arr,int i,int len)&#123;</span><br><span class="line">    //取出当前元素</span><br><span class="line">    int curr = arr[i];</span><br><span class="line">    //从当前节点的左节点开始比较</span><br><span class="line">    for(intk=i*2+1;k&lt;len;k=k*2+1)&#123;</span><br><span class="line">        //若右节点存在且大于左节点,则切换到左节点进行操作</span><br><span class="line">        if(k+1&lt;len&amp;&amp;arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">            k=k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子节点的值大于父节点</span><br><span class="line">        if(arr[k]&gt;curr)&#123;</span><br><span class="line">            //交换元素值</span><br><span class="line">            arr[i]=arr[k];</span><br><span class="line">            //以孩子节点作为父节点继续进行调整</span><br><span class="line">            i=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i]=curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><ol><li><p>概述<br>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li>自上而下的递归；</li><li>自下而上的迭代。</li></ol></li><li><p>算法思路</p><ol><li><p>递归法<br>在每一层递归上分为三个步骤：<br>a. 分解（Divide）：将n个元素分为 n / 2 个元素的子序列，然后一直递归分解，直到只剩一个元素；<br>b. 解决（Conquer）：用合并排序法对两个子序列进行排序；<br>c. 合并（Combine）：合并两个已排序的子序列得到当前递归层的排序结果。</p></li><li><p>迭代法<br>先归并那些微型的数组，然后再成对归并得到的子数组，如此这般，直到将整个数组归并完成。<br>a. 先进行两两归并（归并子数组长度为1），得到一个&quot;部分有序&quot;（两两相邻有序）的数组；<br>b. 然后对第一步得到的数组进行四四归并（将两个大小为2的数组归并为一个有四个元素的子数组），又得到一个相比于第一步更加有序的数组；<br>c. 然后是八八归并，一直归并下去，直到整个数组有序；<br>d. 注意对最后一个子数组的处理，其长度可能小于归并的默认长度。</p></li></ol> <img src="/经典排序算法/MergeSort.gif" title="MergeSort"></li><li><p>代码实现</p><ol><li><p>公共代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将nums数组进行归并, 将nums[start..end]和data[mid+1, end]归并成一个更大的有序数组, 其中nums[start..mid],</span><br><span class="line">// nums[mid+1,end]已有序</span><br><span class="line">private void mergeResult(int[] nums, int start, int mid, int end) &#123;</span><br><span class="line">    int i = start, j = mid + 1, len = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 归并所需要的辅助数组</span><br><span class="line">    int[] temp = new int[len];</span><br><span class="line"></span><br><span class="line">    // 辅助数组</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        temp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在temp数组上进行大小比较, 然后temp中的值放回到nums中,返回过程中进行排序</span><br><span class="line">    // 比较方法 - nums[start..mid]和data[mid+1, end]依次开始比较</span><br><span class="line">    for (int k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        // nums[start..mid]的数据排序完成</span><br><span class="line">        if (i &gt; mid) &#123;</span><br><span class="line">            nums[k] = temp[j++];</span><br><span class="line">        // nums[mid + 1..end]的数据排序完成</span><br><span class="line">        &#125; else if (j &gt; end) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else if (temp[i] &lt; temp[j]) &#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            nums[k]= temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    merge(nums, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge (int[] nums, int start, int end) &#123;</span><br><span class="line">    // 1. 递归结束条件 -只有一个元素</span><br><span class="line">    if (start == end)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 2. 递进操作</span><br><span class="line">    int mid = (start + end) / 2;</span><br><span class="line">    // 对左边进行排序</span><br><span class="line">    merge(nums, start, mid);</span><br><span class="line">    // 对右边进行排序</span><br><span class="line">    merge(nums, mid + 1, end);</span><br><span class="line">    // 对上述排序结果进行合并</span><br><span class="line">    mergeResult(nums, start, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代法代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mergeSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // sz表示子数组的长度</span><br><span class="line">    for (int sz = 1; sz &lt; len; sz = sz + sz) &#123;</span><br><span class="line">        // 以sz为基准, 把nums分为若干个长度为2sz的子数组, 对其进行归并排序                                  </span><br><span class="line">        //  若下一个子数组的起始位置大于等于len-sz则表示剩余的元素小于sz个，则不需要再进行合并排序了（上一个归并已经处理了）</span><br><span class="line">        for (int lo = 0; lo &lt; len - sz; lo += sz + sz) &#123;</span><br><span class="line">            // 后面的Math.min(lo + sz + sz - 1, len - 1) 是为了保证对未能组成两个归并数组的处理</span><br><span class="line">            mergeResult(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, len - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="多路归并排序merge-sort"><a class="markdownIt-Anchor" href="#多路归并排序merge-sort"></a> 多路归并排序（Merge Sort）</h3><p>插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要外部排序算法来解决。<br>外部排序算法由两个阶段构成：</p><ol><li>按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为&quot;归并段&quot;或者&quot;顺段&quot;），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li><li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li></ol><p>对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。<br>想要达到减少访问外存的次数（归并次数）从而提高算法效率的目的，可以从两个角度实现：</p><ol><li>增加 k-路平衡归并中的 k 值 — 多路归并算法；</li><li>尽量减少初始归并段的数量 m，即增加每个归并段的容量 — 置换-选择排序算法；</li></ol><h3 id="计数排序counting-sort"><a class="markdownIt-Anchor" href="#计数排序counting-sort"></a> 计数排序（Counting Sort）</h3><ol><li><p>概述<br>在于将输入的数据值转化为键（数组索引）存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。<br>额外开辟的数组空间的长度为输入数组的最大值+1，这也意味着计数排序对于数据范围很大的输入数据，它需要很大的空间来用来进行计数，所以计数排序是一种典型的空间换时间的算法。</p></li><li><p>算法思路</p><ol><li>找出待排序数组的最大值，开辟一个额外数组，其长度为最大值+1；</li><li>遍历待排序数组，计算数组中每个元素的出现次数，并且将元素值作为索引，出现的次数作为值存入到额外数组中；</li><li>遍历额外数组，若其元素值（出现次数）大于0，则将其索引作为元素值回写到待排序数组中，并且出现次数-1，直到完成排序；</li></ol> <img src="/经典排序算法/CountSort.gif" title="countSort"><p>如果按照上述的算法（朴素的计数排序）思路来进行排序的话，还存在着如下两个问题：</p><ol><li><p>额外数组在某些情况下利用率低。例如待排序数组范围 90 ~ 99，那么额外数组的长度为99+1，这造成前0~89个数组空间的浪费。<br>要解决这个问题，可以使用（maxValue - minValue）+ 1作为额外数组的长度，以minValue作为偏移量，nums[i] - minValue来定位nums[i] 在额外数组中的位置；</p></li><li><p>朴素的计数排序不是稳定的排序，它只是简单遍历的额外数组，然后对于值不为0的元素输出其下标，若待排序数组有nums[i] == nums[j]（i &lt; j），排序之后，nums[i] == nums[j]（i &gt; j）。若是单纯的进行整数排序，排序之后交换了位置也没关系，但是如果面临现实业务（比如考试分数的排序）中，就行不通了。<br>要解决这个问题，需要对额外数组进一步操作，依次将当前位置的值和前一个位置的值相加（代码描述为：countNums[i] += countNums[i - 1]），这样额外数组中存储的值代表了元素的最终排序位置。</p> <img src="/经典排序算法/countSort.png" title="countSort"><p>输入待排序数组为[4,0,9,5,5]，经过计数之后得到上述图片的上半部分，进行处理后得到下半部分，那么下标为9的的值为5，则代表中元素9最终排序的位置为5。</p></li></ol></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[maxValue + 1];</span><br><span class="line"></span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历额外数组countNums, 将其索引回写到nums数组中</span><br><span class="line">    int sortIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        while (countNums[i] &gt; 0) &#123;</span><br><span class="line">            nums[sortIndex++] = i;</span><br><span class="line">            countNums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化之后的代码如下:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void countingSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值</span><br><span class="line">    int maxValue = getMaxValue(nums);</span><br><span class="line">    // 得到最小值</span><br><span class="line">    int minValue = getMinValue(nums);</span><br><span class="line">    // 开辟额外数组</span><br><span class="line">    int[] countNums = new int[(maxValue - minValue) + 1];</span><br><span class="line">    // 计算数组中每个元素出现的次数, 并且将元素值 - 偏移量(minValue)作为索引, 出现次数作为值存到countNums中</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[value - minValue]++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // countNums[nums[i] - minValue]为 nums[i]的最终位置</span><br><span class="line">        sortArray[countNums[nums[i] - minValue] - 1] = nums[i];</span><br><span class="line">        countNums[nums[i] - minValue]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums = sortArray.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><ol><li><p>概述<br>桶排序是计数排序的升级版，降低了额外空间的大小和提高了额外空间的利用率。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定，对于桶的内部，选择何种内部排序算法也对性能有着重要的影响。为了使桶排序更加高效，需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量；</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ol></li><li><p>算法思路</p><ol><li>根据待排序数组中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数<br>，设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>选择一种排序算法，对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol> <img src="/经典排序算法/bucketSort.png" title="bucketSort"> <img src="/经典排序算法/bucketSort2.png" title="bucketSort2"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void bucketSort (int[] nums) &#123;</span><br><span class="line">    bucketSort(nums, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void bucketSort(int[] nums, int bucketSize) &#123;</span><br><span class="line">    // 根据最大值和最小值计算需要的桶的个数 - 映射规则(可以选择不同的映射规则)</span><br><span class="line">    int minValue = nums[0];</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue = value;</span><br><span class="line">        &#125; else if (value &lt; minValue) &#123;</span><br><span class="line">            minValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到所需桶个数</span><br><span class="line">    int bucketCount = (int) (Math.floor((maxValue - minValue) / bucketSize) + 1);</span><br><span class="line">    // 创建桶</span><br><span class="line">    int[][] buckets = new int[bucketCount][0];</span><br><span class="line"></span><br><span class="line">    // 利用映射函数将数据分配到桶中</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int index = (int) Math.floor((nums[i] - minValue) / bucketSize);</span><br><span class="line">        buckets[index] = numsAppend(buckets[index], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int[] bucket : buckets) &#123;</span><br><span class="line">        if (bucket.length &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对每个桶中元素进行排序 - 采用插入排序, 可使用其他排序算法</span><br><span class="line">        bucket = insertSort(bucket);</span><br><span class="line">        // 将已经排序完的元素回写到数组中</span><br><span class="line">        for (int value : bucket) &#123;</span><br><span class="line">            nums[index++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将数据添加到桶中</span><br><span class="line">private int[] numsAppend (int[] bucketNums, int value) &#123;</span><br><span class="line">    bucketNums = Arrays.copyOf(bucketNums, bucketNums.length + 1);</span><br><span class="line">    bucketNums[bucketNums.length - 1] = value;</span><br><span class="line">    return bucketNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort）</h3><ol><li><p>概述<br>基数排序是一种非比较型整数排序算法，其原理是将整数按位数（通常是低位-&gt;高位进行分割）切割成不同的数字，然后将分割之后的数字分配到不同桶中，对桶中元素进行排序，然后依次输出桶中元素，接着按照下一个位数进行分割，反复进行上述操作，直到整个数组有序。<br>若待排序数组分割之后的位数的数值范围较小，可以不利用桶来收集分割之后的元素，可以直接采用计数排序。比如对于整数的基数排序，只需要分配固定十个桶（位数范围0~9），则直接可以基于计数排序进行。<br>基数排序既可以从高位优先进行排序（Most Significant Digit first，简称MSD），也可以从低位优先进行排序（Least Significant Digit first，简称LSD）。</p></li><li><p>算法思路</p><ol><li>得到待排序数据中的最大值，并得到最大值的位数digit；</li><li>从低位到高位依次待排序数组进行计数排序，计数排序的次数为digit；</li><li>重复第二步，直到整个数组有序。</li></ol> <img src="/经典排序算法/RadixSort.gif" title="RadixSort"></li><li><p>代码实现</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void radixSort (int[] nums) &#123;</span><br><span class="line">    // 得到最大值的长度(位数), 通过这个就知道需要进行几次基数排序</span><br><span class="line">    int maxDigit = getMaxDigit(nums);</span><br><span class="line">    sort(nums, maxDigit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sort (int[] nums, int maxDigit) &#123;</span><br><span class="line">    int exp = 1;</span><br><span class="line">    // 最大值的位数为maxDigit, 则代表要进行maxDigit次计数排序</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, exp *= 10) &#123;</span><br><span class="line">        countingSort(nums, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对基数排序的每位进行计数排序</span><br><span class="line">private static void countingSort (int[] nums, int exp) &#123;</span><br><span class="line">    // 开辟额外数组存在每个数字出现次数</span><br><span class="line">    int[] countNums = new int[10];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        countNums[(value / exp) % 10]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对额外数组进行处理</span><br><span class="line">    for (int i = 1; i &lt; countNums.length; i++) &#123;</span><br><span class="line">        countNums[i] += countNums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 倒序遍历(才能保证稳定)待排序数组, 从额外数组countNums中找到每个元素属于自己的排序位置</span><br><span class="line">    // 开辟一个数组来保存排序结果, 如果原地进行的话会覆盖还未排序的元素</span><br><span class="line">    int[] sortArray = new int[nums.length];</span><br><span class="line">    for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        sortArray[countNums[(nums[i] / exp) % 10] - 1] = nums[i];</span><br><span class="line">        countNums[(nums[i] / exp) % 10]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为需要基于nums再进行若干次计数排序, 所以将sortArray 赋值给nums</span><br><span class="line">    for (int i = 0; i &lt; sortArray.length; i++) &#123;</span><br><span class="line">        nums[i] = sortArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得到最大值的位数</span><br><span class="line">private static int getMaxDigit (int[] nums) &#123;</span><br><span class="line">    int maxValue = nums[0];</span><br><span class="line">    for (int value : nums) &#123;</span><br><span class="line">        if (maxValue &lt; value)</span><br><span class="line">        maxValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    // 得到最大值的位数</span><br><span class="line">    int length = 0;</span><br><span class="line">    while (maxValue != 0) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        maxValue = maxValue / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653200371&amp;idx=1&amp;sn=94c1882b9156bd96fa6da20c7995850e&amp;chksm=8c99ed29bbee643f292c3d06995825a657d0c93cbabc4cc41a1a4f4073fdb663ecdc6d1d9685&amp;scene=21#wechat_redirect</a><br>[2] <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/onepixel/articles/7674659.html</a><br>[3] <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195533&amp;idx=1&amp;sn=02918dc51b07837ce1119f00d7900dbc&amp;chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#排序算法概述&quot;&gt;&lt;/a&gt; 排序算法概述&lt;/h2&gt;
&lt;h3 id=&quot;算法分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法分类&quot;&gt;&lt;/a&gt; 算法
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>重新认识时间复杂度</title>
    <link href="http://www.huangbin.fun/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html"/>
    <id>http://www.huangbin.fun/重新认识时间复杂度.html</id>
    <published>2020-05-19T13:40:22.000Z</published>
    <updated>2020-11-19T14:39:43.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大o符号表示法"><a class="markdownIt-Anchor" href="#大o符号表示法"></a> 大O符号表示法</h2><p>我们假设计算机运行一行基础代码需要执行一次运算。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(void)&#123;</span><br><span class="line">    printf(&quot;Hello,World!\n&quot;);  //需要执行1次</span><br><span class="line">    return 0;  //需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面这段代码执行的总运算次数为2次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int aFunc(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;  //需要执行(n+1)次, 从0 -&gt; n</span><br><span class="line">        printf(&quot;Hello,World!\n&quot;);  //需要执行n次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//需要执行1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行的总次数为 n + 1 + n + 1次。<br>使用 T(n) 来表示算法需要执行的总的运算次数，T(n) 为一个关于输入次数n的函数。    例如上面的两段代码中：第一段代码 T(n) = 2； 第二段代码 T(n) = 2n + 2。<br>但是仅仅有T(n) 是不够的，为了估算算法需要的运行时间和简化算法分析，再一次引入时间复杂度的概念。</p><blockquote><p>定义：存在一个常数C和f(n)，使得当n &gt;= C时，有T(n) &lt;= f(n)，表示为T(n) = O(f(n))</p></blockquote><p>就那T(n) = 2n 举例来说，存在C=2，且 n&gt;=C时，总有f(n) = 2n+1 &gt; T(n) = 2n，我们可以说说f(n)的增长速度是大于或等于T(n)的，也就是说f(n)为T(n)的上界，我们就可以用f(n)的增长速度来度量T(n)的增长速度，可以表示为 T(n) = O(f(n)) = O(2n + 1)，所以我们可以说这个算法的时间复杂度为O(f(n)) = O(2n+1)，O(f(n))表示运行算法所需要执行的指令数和f(n)成正比，n表示数据规模。<br>这个f(n) 并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间随着输入n的增大的增长变化趋势，所以常数1 和 与n相乘的常数2 对增长速度的影响不明显，所以可以省略，所以时间复杂度可以简化为 O(n)。</p><img src="/重新认识时间复杂度/Defination.jpg" title="Defination"><p>显然T(n) = O(f(n)) = O(3n+1)，T(n) = O(f(n)) = O(n^2)…… 都是成立，但是T(n) = O(f(n)) = O(2n+1)的增长速度相比其他是更加接近的，所以选择了它。<br>上面所提到的T(n) = O(f(n)) 也称为&quot;大O符号表示法&quot;。<br>下面可以用一个图来展示时间复杂度随着输入n的增大的增长变化趋势。从下图可知，常数对于时间复杂度的决定性总是微乎其微的，并且描述了一个事实，当数据规模n到达了某个零界点之后，时间复杂度低的算法的执行效率一定比时间复杂度高的执行效率更高。</p><img src="/重新认识时间复杂度/comparation.png" title="comparation"><h2 id="时间复杂度推导规律"><a class="markdownIt-Anchor" href="#时间复杂度推导规律"></a> 时间复杂度推导规律</h2><ol><li>推导T(n)<ol><li>对于一个循环，假设循环体的运算执行次数为 n ，循环次数为 m，则这个循环的总执行次数为 T(n) = n * m。</li><li>对于多个循环，假设循环体的运算执行次数为 n，各个循环的循环次数分别是a，b， c…，则这个循环的总执行次数为T(n) =  n * a * b * c…。分析的时候应该由里向外分析这些循环。</li><li>对于顺序执行的语句或者算法，总的运算执行次数等于其中最大的运算执行次数。</li><li>对于条件执行的语句或者算法，总的运算执行次数等于其中路径中最大的运算执行次数。<br>综合说：从内向外进行分析，如果遇到函数调用，进行调用函数进行分析。</li></ol></li><li>T(n) -&gt; O(f(n))<br>假设我们已经得到了T(N)，即一个算法的执行次数，那么可以通过以下几个规律来简单推导：<ol><li>常数项对于函数增长速度的影响并不明显，忽略常数项。<br>T(n) = c = O(1)，c为常数；<br>T(n) = n + 1 = 1 = O(n)；</li><li>高次项对于函数的增长速度的影响是最大的，保留最高次项，忽略低次项，若最高次项有常数相乘，忽略它；<br>T(n) = n^3 + n^2 + n = O(n^3)；<br>T(n) = 3 n^3 = O(n^3)；<br>Ps：忽略低次项只适合于规模n属于同一个的情况。若某个时间复杂度为O(logn + m)，n和m属于两个不同的数据规模，则不可忽略其他任何一部分。</li></ol></li></ol><p>综合说：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。</p><h2 id="时间复杂度实例"><a class="markdownIt-Anchor" href="#时间复杂度实例"></a> 时间复杂度实例</h2><ol><li><p>O(1)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum(int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for(int i = 0; i &lt;= n; i++) </span><br><span class="line">        result += i;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">void reverse(String s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    for(int i = 0; i &lt; n / 2; i++)</span><br><span class="line">        swap(s.charAt(i), s.charAt(n - 1 - i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(n^2)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void selectionSort(int[] arr, int n) &#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">        for(int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内层if语句的执行次数为 (n - 1) +  (n - 2) +  (n - 3) …. + 0 = (0 + n - 1) * n / 2 =&gt; O(n^2)。</p></li><li><p>O(logn)时间复杂度实例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int n, int target) &#123;</span><br><span class="line">    int l = 0, r = n - 1;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (arr[mid] == target) return mid;</span><br><span class="line">        if (arr[mid] &gt; target) r = mid - 1;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>① 在n个元素中查找<br>② 在 n / 2个元素中查找<br>③ 在 n / 4 个元素中查找<br>…….<br>④ 在1个元素中查找<br>n经过几次&quot;除以2&quot;操作后，等于1？ log(2)n = O(logn)<br>也可以这样计算，设操作次数为t，则 2^t &lt;= n，t = log(2)n，得出为 O(logn)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String intToString(int num) &#123;</span><br><span class="line">    String s = &quot;&quot;;</span><br><span class="line">    while(num &gt; 0) &#123;</span><br><span class="line">        s += &quot;0&quot; + num % 10;</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    s = reverse(s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>n经过几次&quot;除以10&quot;操作后，等于1？ log(10)n = O(logn)<br>为什么log(10)n和 log(2)n 的时间复杂度都可以视为O(logn)呢？ 主要是因为对数换底公式：</p> <img src="/重新认识时间复杂度/fomula.png" title="fomula"><p>所以具体对数底是如何并不重要。</p></li><li><p>O(nlogn)时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hello (int n) &#123;</span><br><span class="line">    for(int sz = 1; sz &lt; n; sz += sz)</span><br><span class="line">        for(int i = 1; i &lt; n; i++) </span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>O(sqrt(n))时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isPrime(int n) &#123;</span><br><span class="line">    for(int x = 2; x * x &lt;= n; x++) &#123;</span><br><span class="line">        if(n % x == 0)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>X初始化为2，每次增加1，直到遍历到sqrt(n)就退出循环。</p></li><li><p>递归调用时间复杂度实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] arr, int l, int r, int target) &#123;</span><br><span class="line">    if(l &gt; r)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        if (arr[mid] == target)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (arr[mid] &gt; target) </span><br><span class="line">            return binarySearch(arr, l, mid - 1, target);</span><br><span class="line">        else </span><br><span class="line">            return binarySearch(arr, mid + 1, r, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，最多只进行一次递归调用，这时我们需要计算中递归调用的最大深度是多少，由实例4可知，由n-&gt;1，递归的最大深度为logn，则时间复杂度为O(logn)。<br>总结如下：如果在递归函数中，只进行一次递归调用，递归深度为depth，在每个递归函数中，时间复杂度为T，则总体的时间复杂度为O(T*depth)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    if (n == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    return f(n - 1) + f(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在每一个递归调用中，会进行两次递归调用，此时应该更加关注的是计算调用的次数，通常可以通过画递归树的方式来计算调用次数。时间复杂度为O(2^n)。</p> <img src="/重新认识时间复杂度/tree.png" title="tree"><p>递归树层数为4，2^0 + 2^1+ 2^2 + 2^3 = 2^n -1 =15</p></li><li><p>均摊复杂度分析实例</p><p>例如对于Java中ArrayList数组，它是一个动态数组，此类的动态数组在每个的插入操作为O(1)的时间复杂度，但是当超过当前数组容量时会进行数组扩容操作，扩容操作的时间复杂度为O(n)，但是就算在插入操作中存在着O(n)时间复杂度的扩容操作，也不能够说插入操作的时间复杂度为O(n)，它仍然是O(1)的时间复杂度，因为O(n)时间复杂度的扩容操作均摊到了前面n次的O(1)操作之中了。</p> <img src="/重新认识时间复杂度/resize.png" title="resize"><p>每个的删除操作为O(1)的时间复杂度，那么假设当剩余元素为当前数组容量的一半时会进行数组缩小操作，那么此时也可以使用如上所说明的均摊复杂度分析。</p> <img src="/重新认识时间复杂度/resize2.png" title="resize2"><p>但是如上可能会存在复杂度震荡问题，即当在数据扩容和缩小的零界点交替进行添加和删除操作会使得时间复杂度退化为O(n)。</p> <img src="/重新认识时间复杂度/resize3.png" title="resize3"></li><li><p>有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符数组按照字典序排序，整个操作的时间复杂为？<br>解析：<br>假设最长的字符串长度为s；整个数组中有n个字符串。<br>对每个字符串排序时间复杂度为O(slogs)，将数组中的每一个字符串按照字母序排序：O(n<em>slogs)，将整个字符串数组按照字典序排序：O(s</em>nlogn)，其中s<em>nlogn为排序所需要的比较次数。<br>综上所述，整个时间复杂度为：O(n</em>slogs) + O(s<em>nlogn) = O(n</em>slogs + s<em>nlogn) =<br>O(ns</em>(logs + logn))</p></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li><p>&quot;O&quot;是渐进上界符号（Big-oh - 欧米可荣），用它评估算法的复杂度得到的只是问题规模充分大时的一个上界，但是这个定义是严格的学术定义，按照该定义来说，归并排序算法的时间复杂度是O(nlogn)，并且是O(n^2)，这种说法是正确的，因为O(n^2)也是满足条件的一个上界。但是通常来讲，我们使用&quot;O&quot;来表示算法执行的最低上界。</p></li><li><p>下图展示了不同时间复杂度随着数据规模n的增长的所需要执行指令数的增长速度。<img src="/重新认识时间复杂度/comparation2.png" title="comparation2"></p></li><li><p>数据规模的概念<br>如果想要在1s之内解决问题：<br>O(n^2) 的算法可以处理大约10^4级别的数据；<br>O(n)的算法可以处理大约10^8级别的数据；<br>O(nlogn)的算法可以处理大约10^7级别的数据。</p></li><li><p>空间复杂度<br>多开一个辅助数据：O(n)；多开一个辅助的二维数组：O(n^2)；多开常数空间：O(1)；递归调用具有空间代价</p></li></ol><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://www.jianshu.com/p/f4cca5ce055a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f4cca5ce055a</a><br>[2] <a href="https://blog.csdn.net/so_geili/article/details/53353593" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/so_geili/article/details/53353593</a><br>[3] <a href="https://coding.imooc.com/class/chapter/82.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/chapter/82.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大o符号表示法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大o符号表示法&quot;&gt;&lt;/a&gt; 大O符号表示法&lt;/h2&gt;
&lt;p&gt;我们假设计算机运行一行基础代码需要执行一次运算。&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>小小String对象大大奥秘</title>
    <link href="http://www.huangbin.fun/%E5%B0%8F%E5%B0%8FString%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%A4%A7%E5%A5%A5%E7%A7%98.html"/>
    <id>http://www.huangbin.fun/小小String对象大大奥秘.html</id>
    <published>2020-05-05T07:40:48.000Z</published>
    <updated>2020-05-06T11:05:00.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字符串"><a class="markdownIt-Anchor" href="#什么是字符串"></a> 什么是字符串？</h2><p>字符串是由引号所括起来的一系列字符序列。例如&quot;String&quot;，&quot;Hello&quot;就为一个字符串</p><h2 id="string-的不可变性"><a class="markdownIt-Anchor" href="#string-的不可变性"></a> String 的不可变性</h2><p>&quot;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何操作都会生成新的对象“。</p><ol><li>固定不变 - 从String 对象的源码中可以看出，String 类声明为 final，且它的属性和方法都被 final 所修饰</li><li>任何操作都会生成新对象 - String:: subString()，String::concat() 等方法都会生成一个新的String对象，不会在原对象上进行操作<br>从下面String源码部分中很容易得到上面的结论：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** String 类源码 */</span><br><span class="line">public final class String </span><br><span class="line">     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    /** Cache the hash code for the string */</span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line">     *</span><br><span class="line">     * A String instance is written into an ObjectOutputStream according to</span><br><span class="line">     * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line">     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line">     */</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用一段代码来揭示这个过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String start = &quot;Hello&quot;;  // 1</span><br><span class="line">        String end = start.concat(&quot; World!&quot;); // 2</span><br><span class="line">          //String end = start + &quot; World!&quot;  </span><br><span class="line">        System.out.println(end); // 3</span><br><span class="line">             System.out.println(start); // 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">Hello World!</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>在这段代码中，没有改变任何对象。首先在第一个代码中，会在堆内存中创建一个新的String 对象，并把它的引用赋值给 start，接着在第二个调用String:: concat()方法对字符串进行拼接，<strong>此时会创建一个新的String 对象，该对象是&quot;Hello&quot; 和 “World” 的串联</strong>。就如String:: concat() 源码所示，第三个/四个代码的输出结果分别为：“Hello World!”, “World”。并且操作符 &quot; + &quot;完成了和String:: concat() 类似的事 - &gt; 操作符 “+” 算是一个语法糖，查看编译之后的字节码可以知道最终会调用StringBuilder:: append() 来完成字符串的拼接。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** concat() 源码 */</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length();  // 拼接的字符串参数长度为0, 返回本身</span><br><span class="line">        if (otherLen == 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length;</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true); // 创建一个新String对象来存储拼接之后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可变性设计的初衷"><a class="markdownIt-Anchor" href="#不可变性设计的初衷"></a> 不可变性设计的初衷</h2><ol><li>字符串常量池的需要。String对象的不可变性为字符串常量池的实现提供了基础，使得常量池便于管理和优化。</li><li>多线程安全。同一个字符串对象可以被多个线程共享。</li><li>安全性考虑。字符串应用场景众多，设计成不可变性可以有效防止字符串被有意篡改。</li><li>由于String对象的不可变性，可以对其HashCode进行缓存，可以作为HashMap，HashTable等集合的key 值。</li></ol><h2 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h2><p>很多文章都提及到字符串常量池是String对象的集合，这种说法很接近了，但是更准确来说，它是 <strong>String 对象引用的集合</strong> （网上关于这个众说纷纭，我更加倾向于存储的是引用的集合~ 若有错误了请指出! 谢谢~ ps: 又看了一遍书，发现在JDK 6以前，永久代中的字符串常量池是存放String 对象实例的，但是JDK 7之后，字符串常量池移到了堆中，String 对象实例也是在堆中的，那字符串常量池只需要保存String 对象的引用就行啦~ 详见《深入理解Java虚拟机》 P63）。 虽说String 是不变的，但是它还是和Java中的其他对象一样，是分配在堆中的，所以说 <strong>String 对象存在于堆中，字符串常量池存放了它们的引用</strong>。因为 String 对象是不可变的，所以多个引用 “共享” 同一个String 对象是安全的，这种安全性就是 字符串常量池所带来的。</p><h3 id="字面量的形式创建字符串"><a class="markdownIt-Anchor" href="#字面量的形式创建字符串"></a> 字面量的形式创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;; // 1</span><br><span class="line">        String two = &quot;someString&quot;; // 2</span><br><span class="line"></span><br><span class="line">        System.out.println(one.equals(two));  // String 对象是否相同内容</span><br><span class="line">        System.out.println(one == two);  // String 对象是否相同的引用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>执行完上面的第一句代码之后，会在堆上创建一个String 对象，并把String 对象的引用存放到字符串常量池中，并把引用返回给 one，那当第二句代码执行时，字符串常量池已经有对应内容的引用了，直接返回对象引用给 two。one.equals(two) / one == two 都为true。 图形化如下所示：<img src="/小小String对象大大奥秘/stringLiterals1.jpg" title="stringLiterals1"></p><h3 id="new-创建字符串"><a class="markdownIt-Anchor" href="#new-创建字符串"></a> new 创建字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(one.equals(two));</span><br><span class="line">        System.out.println(one == two);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>在使用 new关键字时的情况会有稍微不同，关于这两个字符串的引用任然会存放字符串常量池中，但是关键字 new使得虚拟机在运行时会创建一个新的String对象，而不是使用字符串常量池中已经存在的引用，此时 two 指向 堆中这个新创建的对象，而one 是常量池中的引用。 one.equals(two) 为 true，而 one == two 都为false。<img src="/小小String对象大大奥秘/stringLiterals2.jpg" title="stringLiterals2"></p><p>如果想要one，two都引用同一个对象，则可以使用 String:: intern()方法 - 当调用intern()方法时，如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中它的引用，如果没有，那就将它的引用保存一份到字符串常量池中，然后直接返回这个引用。这个方法是有返回值的，是返回引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String one = &quot;someString&quot;;</span><br><span class="line">String two = new String(&quot;someString&quot;); // 仍指向堆中new 出的新对象</span><br><span class="line">String three = two.intern(); </span><br><span class="line">System.out.println(one.equals(two)); // true</span><br><span class="line">System.out.println(one == two); // false </span><br><span class="line">System.out.println(one == three); // true</span><br><span class="line">System.out.println(two == three); // false</span><br></pre></td></tr></table></figure><h3 id="垃圾收集"><a class="markdownIt-Anchor" href="#垃圾收集"></a> 垃圾收集</h3><p>当一个对象没有引用指向时，垃圾收集器便会对它进行收集操作。看下面的一个事例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableStrings</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String one = &quot;someString&quot;;</span><br><span class="line">        String two = new String(&quot;someString&quot;);</span><br><span class="line">        </span><br><span class="line">        one = two = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 one = two = null时，只有一个对象会被回收，String 对象总是有来自字符串常量池的引用，所以不会被回收<img src="/小小String对象大大奥秘/stringLiterals3.jpg" title="stringLiterals3"></p><h2 id="string-对象的创建和字符串常量池的放入"><a class="markdownIt-Anchor" href="#string-对象的创建和字符串常量池的放入"></a> String 对象的创建和字符串常量池的放入</h2><p>上面嘀咕了那么久，那到底什么时候会创建String 对象？什么时候引用放入到字符串常量池中呢？先需要提出三个常量池的概念：</p><ol><li>静态常量池：常量池表（Constant Pool table，存放在Class文件中），也可称作为静态常量池，里面存放编译器生成的各种字面量和符号引用。其中有两个重要的常量类型为CONSTANT_String_info和CONSTANT_Utf8_info类型（具体描述可以看看《深入理解Java虚拟机》的p 219 啦~）</li><li>运行时常量池：运行时常量池属于方法区的一部分，常量池表中的内容会在类加载时存放在方法区的运行时常量池，运行时常量池相比于Class文件常量池一个重要特征是 动态性，运行期间也可以将新的常量放入到 运行时常量池中</li><li>字符串常量池：在HotSpot 虚拟机中，使用StringTable来存储 String 对象的引用，即来实现字符串常量池，StringTable 本质上是HashSet<string>，所以里面的内容是不可以重复的。一般来说，说一个字符串存储到了字符串常量池也就是说在StringTable中保存了对这个String 对象的引用</string></li></ol><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>有了上面的概念之后，便可来描述下述过程了<br>首先给出结论，<strong>“在类的解析阶段，虚拟机便会在创建String 对象，并把String对象的引用存储到字符串常量池中”。</strong></p><ol><li>当*.java 文件 编译为*.class 文件时，字符串会像其他常量一样存储到class 文件中的常量池表中，对应于CONSTANT_String_info和CONSTANT_Utf8_info类型；</li><li>类加载时，会把静态常量池中的内容存放到方法区中的运行时常量池中，其中CONSTANT_Utf8_info类型在类加载的时候就会全部被创建出来，即说明了加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，但是此时StringTable（字符串常量池）并没有相应的引用，在堆中也没有相应的对象产生；</li><li>遇到ldc字节码指令（该指令将int、float或String型常量值从常量池中推送至栈顶）之前会触发解析阶段，进入到解析阶段，若在解析的过程中发现StringTable已经有与CONSTANT_String_info一样的引用，则返回该引用，若没有，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；</li></ol><h3 id="具体示例"><a class="markdownIt-Anchor" href="#具体示例"></a> 具体示例</h3><p>下面给出几个具体实例，来说下这个过程：</p><ul><li><strong>字面量的形式创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    String name = &quot;HB&quot;;</span><br><span class="line">    String name2 = &quot;HB&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 = String  #14 </span><br><span class="line">#14 = utf8    HB</span><br><span class="line">……</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=3, args_size=1</span><br><span class="line">         0: ldc           #2  // String HB</span><br><span class="line">         2: astore_1     </span><br><span class="line">         3: ldc           #2  // String HB</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>当编译成字节码文件后，字面量&quot;HB&quot; 会存储到常量类型 CONSTANT_Utf8_info中，类加载时，其也会随之加载到方法区中的运行时常量池中，接下来可以用此来在StringTable查询是否有匹配的String 对象引用（当然只是简化的说法，具体CONSTANT_Utf8_info还指向一个Symbol对象~）；遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用，然后返回；astore_1指令把返回的引用存到本地变量name； 遇到二个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）已经有与CONSTANT_String_info一样的引用，则直接返回即可，并通过astore_2 指令将其返回的引用保存到本地变量 name2中</p><ul><li><strong>new 创建字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test2&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    String name = new String(&quot;HB&quot;);</span><br><span class="line">    String name2 = new String(&quot;HB&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译后的字节码代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: new           #2  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3 // String HB</span><br><span class="line">         6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #2 // class java/lang/String</span><br><span class="line">        13: dup</span><br><span class="line">        14: ldc           #3 // String HB</span><br><span class="line">        16: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure><p>使用了关键字new后，会有稍微不同，new 指令会在堆中创建一个新的String 对象，并将其引用值压入栈顶，通过dup指令 复制栈顶的新对象的引用值并把复制值压入栈顶，本地变量name 所保存的值就为该引用值；接下来在遇到第一个ldc字节码指令之前，解析过程中发现StringTable（字符串常量池）还没有与CONSTANT_String_info一样的引用，则在堆中创建一个对应内容的String对象，并在StringTable中保存创建的对象的引用, 所以在运行时，会创建两个String对象哦~接下来的过程和前面的差不多，就不一一叙述啦！</p><ul><li><strong>其他重要值得关注的示例</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 = new String(&quot;hb&quot;);</span><br><span class="line">String s2 = &quot;hb&quot;;</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line">String s3 = s1.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s2 == s3);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s5 = &quot;hb&quot; + &quot;haha&quot;;  // 虚拟机会优化进行优化, 当成一个整体 &quot;hbhaha&quot;成立, 而不会用StringBuild::append()处理</span><br><span class="line">String s6 = &quot;hbhaha&quot;;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String temp = &quot;hb&quot;;</span><br><span class="line">String s7 = temp + &quot;haha&quot;; // 采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s7 == s6);  // false</span><br><span class="line">String s8 = s7.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s8 == s6); // true</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s9 = new String(&quot;hb&quot;) + new String(&quot;haha&quot;);  //采用StringBuilder::append()处理</span><br><span class="line">System.out.println(s9 == s6); // false</span><br><span class="line">String s10 = s9.intern(); // 从字符串串常量池中得到相应引用</span><br><span class="line">System.out.println(s10 == s6); // true</span><br><span class="line"></span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s11 = new StringBuilder(&quot;hello&quot;).append(&quot; world&quot;).toString();</span><br><span class="line">System.out.println(s11 == s11.intern()); // true - 一个很特殊的例子, intern()方法会把s11引用放入到字符串常量池中</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot; ===== 分割线 =====  &quot;);</span><br><span class="line">String s12 = new StringBuilder(&quot;hello&quot;).append(&quot; java&quot;).toString();</span><br><span class="line">String s13 = &quot;hello java&quot;;</span><br><span class="line">System.out.println(s12 == s12.intern()); // false - 一个很特殊的例子, intern()方法返回s13 在常量池中的引用</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>String 对象存在于堆中，字符串常量池存放了它们的引用</li><li>字符串常量池存储String对象的引用，且是全局共享的，相同的字符串都将指向同一个字符串对象</li><li>运行时创建的字符串（new）关键字 和 “” (字面量形式) 创建的字符串存在不同</li><li>检查字符串是否相同的最好方法是 equal()</li><li>可以通过String:: intern() 方法从常量池中得到String对象的引用，或 将String 对象的引用存入到 字符串常量池中</li><li>上述所有的实验都是在JDK 8 HotSpot虚拟机下进行的，在JDK 7 中HotSpot，字符串常量池移到了堆中哦~，所以不同JDK版本，不同虚拟机下可能存在差异</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html" rel="external nofollow noopener noreferrer" target="_blank">https://javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html</a><br>[2] <a href="https://www.iteye.com/blog/rednaxelafx-774673#comments" rel="external nofollow noopener noreferrer" target="_blank">https://www.iteye.com/blog/rednaxelafx-774673#comments</a><br>[3] <a href="https://www.zhihu.com/question/55994121/answer/408891707" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/55994121/answer/408891707</a><br>[4] <a href="https://www.cnblogs.com/Kidezyq/p/8040338.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/Kidezyq/p/8040338.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是字符串&quot;&gt;&lt;/a&gt; 什么是字符串？&lt;/h2&gt;
&lt;p&gt;字符串是由引号所括起来的一系列字符序列。例如&amp;quot;String&amp;quot;，&amp;quot;Hello&amp;quot;就
      
    
    </summary>
    
      <category term="Java学习" scheme="http://www.huangbin.fun/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.huangbin.fun/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存设计 - 缓存穿透/雪崩/击穿</title>
    <link href="http://www.huangbin.fun/Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF.html"/>
    <id>http://www.huangbin.fun/Redis-缓存设计-缓存穿透-雪崩-击穿.html</id>
    <published>2020-05-01T06:26:45.000Z</published>
    <updated>2020-05-01T06:49:51.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存收益和成本"><a class="markdownIt-Anchor" href="#缓存收益和成本"></a> 缓存收益和成本</h2><ol><li>缓存收益</li></ol><ul><li>加速读写</li><li>减低后端负载</li></ul><ol start="2"><li>缓存成本</li></ol><ul><li>数据不一致问题：缓冲层和数据层保存的数据可能不一致</li><li>代码维护成本变高，多了一层缓存逻辑</li><li>运维成本，例如 Redis cluster的维护</li></ul><ol start="3"><li>使用场景</li></ol><ul><li>减低后端负载：对高消耗的SQL结果进行缓存，例如join结果集/分组统计结果</li><li>加速请求响应</li><li>大量写合并为批量写，如计数器先Redis累加再批量写到DB</li></ul><h2 id="缓存更新策略"><a class="markdownIt-Anchor" href="#缓存更新策略"></a> 缓存更新策略</h2><ol><li>LRU(Least Recently Used)，根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，则延迟其淘汰时间” - <a href="https://blog.csdn.net/yunhua_lee/article/details/7599671" rel="external nofollow noopener noreferrer" target="_blank">LRU缓存更新</a></li><li>LFU(Least Frequently Used)根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”- <a href="https://blog.csdn.net/yunhua_lee/article/details/7648549" rel="external nofollow noopener noreferrer" target="_blank">LFU缓存更新</a></li><li>FIFO ，根据&quot;先进先出&quot; 思想来更新缓存数据</li><li>超时剔除 - expire</li><li>主动更新 - 开发控制生命周期</li><li>扩展：缓存污染 - 缓存污染降低了缓存的使用率，把不常用的数据读取到缓存，同时会把常用的数据移出缓存，这样会直接降低系统的数据命中率</li></ol><h2 id="缓存穿透问题"><a class="markdownIt-Anchor" href="#缓存穿透问题"></a> 缓存穿透问题</h2><ol><li><p>定义：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询），导致大量请求发到了数据库上。<img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/缓存穿透.png" title="缓存穿透"></p></li><li><p>解决方法</p></li></ol><ul><li>缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，不超过5分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库。<br><strong>存在的问题：</strong><br>（1）需要更多的键，所以通常设置较短过期时间<br>（2）缓存层和存储层数据&quot;短期&quot;不一致</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/设置NULL.jpg" title="设置NULL"><ul><li>布隆过滤器拦截：<br>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。例如Redis可以使用bitMap来实现布隆过滤器</li></ul><img src="/Redis-缓存设计-缓存穿透-雪崩-击穿/布隆过滤器.jpg" title="布隆过滤器"><h2 id="缓存雪崩问题"><a class="markdownIt-Anchor" href="#缓存雪崩问题"></a> 缓存雪崩问题</h2><ol><li>定义：缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务（可能是机器宕机或大量的缓存(key)在同一时间失效 - 过期），于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</li><li>解决方法</li></ol><ul><li>保证缓存层服务高可用性：即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，比如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</li><li>依赖隔离组件为后端限流并降级：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>数据预热：可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul><h2 id="缓存击穿问题"><a class="markdownIt-Anchor" href="#缓存击穿问题"></a> 缓存击穿问题</h2><ol><li>定义：一个存在的热点key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到数据库，造成瞬时数据库请求量大压力骤增。</li><li>解决方法</li></ol><ul><li>互斥锁</li><li>永不过期</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a><br>[2] <a href="https://www.cnblogs.com/George1994/p/10668889.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/George1994/p/10668889.html</a><br>[3] <a href="https://www.jianshu.com/p/b57d0773ee96" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b57d0773ee96</a><br>[4] <a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存收益和成本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#缓存收益和成本&quot;&gt;&lt;/a&gt; 缓存收益和成本&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;缓存收益&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;加速读写&lt;/li&gt;
&lt;li&gt;减低后端负载&lt;/li&gt;

      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 故障转移</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-故障转移.html</id>
    <published>2020-04-30T06:25:11.000Z</published>
    <updated>2020-05-01T07:06:04.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障发现"><a class="markdownIt-Anchor" href="#故障发现"></a> 故障发现</h2><ol><li>通过ping/pong消息来实现故障发现：不需要sentinel</li><li>主观下线：某个节点认为另一个节点不可用，“偏见” <img src="/Redis-Cluster-故障转移/主观下线.png" title="主观下线"></li><li>客观下线：当半数以上持有槽的主节点都标记了某节点主观下线<img src="/Redis-Cluster-故障转移/客观下线.png" title="客观下线"></li></ol><ul><li>故障链表可以维护了每个节点对其他节点的&quot;看法&quot;，即认为主观下线与否</li><li>尝试客观下线流程如下：<img src="/Redis-Cluster-故障转移/客观下线流程.png" title="客观下线流程"></li></ul><h2 id="故障恢复"><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h2><ol><li>资格检查<br>检查每个从节点与故障主节点的断线时间。超过cluster-node-timeout * cluster-slave-validity-factor(默认10)则取消资格。</li><li>准备选举时间<br>准备选举时间，偏移量更大的从节点拥有延迟更小的选举时间，尽量保证从节点与主节点的数据一致性<img src="/Redis-Cluster-故障转移/选举时间.png" title="选举时间"></li><li>选举投票<img src="/Redis-Cluster-故障转移/选举投票.png" title="选举投票"></li><li>替换主节点</li></ol><ul><li>当前从节点取消复制变为主节点（slaveof no one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给新的主节点</li><li>向集群广播自己的pong消息，表明已经替换了故障主节点</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;故障发现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#故障发现&quot;&gt;&lt;/a&gt; 故障发现&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过ping/pong消息来实现故障发现：不需要sentinel&lt;/li&gt;
&lt;li&gt;主观下线：某个节点认为另一个节点不可
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 重定向问题 - Moved/Ask重定向</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98-Moved-Ask%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-重定向问题-Moved-Ask重定向.html</id>
    <published>2020-04-28T06:20:16.000Z</published>
    <updated>2020-05-01T07:05:54.788Z</updated>
    
    <content type="html"><![CDATA[<p>相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。</p><h2 id="moved-重定向"><a class="markdownIt-Anchor" href="#moved-重定向"></a> Moved 重定向</h2><img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved.png" title="Moved"><ol><li>槽命中：直接返回结果</li><li>槽不命中：即当前键命令所请求的键不在当前请求的节点中，则当前节点会向客户端发送一个Moved 重定向，客户端根据Moved 重定向所包含的内容找到目标节点，再一次发送命令。<br>从下面可以看出 php 的槽位9244不在当前节点中，所以会重定向到节点 192.168.2.23:7001中。redis-cli会帮你自动重定向（如果没有集群方式启动，即没加参数 -c，redis-cli不会自动重定向），并且编写程序时，寻找目标节点的逻辑需要交予程序员手动完成。<br><em>cluster keyslot keyName</em>  # 得到keyName的槽<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/Moved2.png" title="Moved2"></li></ol><h2 id="ask-重定向"><a class="markdownIt-Anchor" href="#ask-重定向"></a> ASK 重定向</h2><p>Ask重定向发生于集群伸缩时，集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向来解决此种情况。<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/ASK.png" title="ASK"></p><h2 id="smart客户端"><a class="markdownIt-Anchor" href="#smart客户端"></a> smart客户端</h2><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来减低复杂性，追求更好的性能。客户端内部负责计算/维护键-&gt; 槽 -&gt; 节点映射，用于快速定位目标节点。<br>实现原理：</p><ol><li>从集群中选取一个可运行节点，使用 cluster slots得到槽和节点的映射关系<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/映射关系.png" title="映射关系"></li><li>将上述映射关系存到本地，通过映射关系就可以直接对目标节点进行操作（CRC16(key) -&gt; slot -&gt; node），很好地避免了Moved重定向，并为每个节点创建JedisPool</li><li>至此就可以用来进行命令操作<img src="/Redis-Cluster-重定向问题-Moved-Ask重定向/命令操作流程.png" title="命令操作流程"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比于单机redis或使用sentinel来管理的redis主从复制的客户端，Redis cluster的客户端连接更加复杂，需要进行额外的处理。&lt;/p&gt;
&lt;h2 id=&quot;moved-重定向&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#move
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster 集群伸缩</title>
    <link href="http://www.huangbin.fun/Redis-Cluster-%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster-集群伸缩.html</id>
    <published>2020-04-26T06:05:21.000Z</published>
    <updated>2020-05-01T07:05:41.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群伸缩"><a class="markdownIt-Anchor" href="#集群伸缩"></a> 集群伸缩</h2><p>在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动</p><h2 id="集群扩容"><a class="markdownIt-Anchor" href="#集群扩容"></a> 集群扩容</h2><ol><li>准备新节点，把新节点配置为集群模式，相关配置信息和其他节点统一，启动后新节点是孤立节点，和集群之间还没有联系</li><li>使用 <em>cluster meet newNodeIP newNodePort</em> 把新节点加入到集群中，当然也可以使用官方的 redis-trib.rb的 相关命令来加入新节点（需要配置Ruby 环境~）。节点加入集群后，可以有两个作用：1. 为它迁移槽和数据实现扩容 ；2. 作为从节点负责故障转移</li><li>若新加入的节点大于一个，还可以进行主从分配， <em>cluster replicate nodeId</em></li><li>迁移槽和数据</li></ol><ul><li>制订迁移计划，每个节点要迁移多少个槽给新节点</li></ul><img src="/Redis-Cluster-集群伸缩/集群扩容.png" title="集群扩容"><ul><li>开始迁移操作<br> a. 对目标节点： <em>cluster setslot {slot} importing {sourceNodeId}</em>  让目标节点准备导入槽的数据<br> b. 对源节点： <em>cluster setslot {slot} migrating {targetNodeId}</em> 让源节点准备迁出槽的数据<br> c. 源节点循环执行  <em>cluster getkeysinslot {slot} {count}</em> 每次获取count个属于槽的键<br> d. 在源节点执行 <em>migrate {targetIp} {targetPort} key 0 {timeout}</em> 命令把指定key迁移，0 表示数据库0<br> e. 重复执行步骤 3 ~ 4直到槽下所有的键数据迁移到目标节点<br> f. 向集群内所有主节点发送  <em>cluster setslot {slot} node {targetNodeId}</em> 命令，告诉所有主节点 槽分配给了目标节点   <img src="/Redis-Cluster-集群伸缩/slot迁移.png" title="slot迁移"></li></ul><p>  上述的迁移操作很是繁琐，可以使用官方提供的redis-trib.rb的相关命令进行操作。使用 redis-trib.rb reshard IP:Port 进行交互模式来完成槽的移动  - <a href="https://www.jianshu.com/p/21f67bd739cc" rel="external nofollow noopener noreferrer" target="_blank">redis-trib工具使用</a></p><h2 id="集群收缩"><a class="markdownIt-Anchor" href="#集群收缩"></a> 集群收缩</h2><ol><li>下线集群节点之前，需要看节点是否持有槽，即是否有数据，若有，则需要迁移到其他节点<br><em>redis-trib.rb reshard --from {downNodeId} --to {migrateNodeId} --slots {slotNumber}  IP:Port</em>，其中的 IP:Port，任意一个节点的 IP:Port都行哦~<img src="/Redis-Cluster-集群伸缩/集群收缩.png" title="集群收缩"></li><li>通知其他所有节点忘记下线节点，<em>cluster forget {downNodeId}</em>_ 或者 <em>redis-trib.rb del-node IP:Port {forgetNodeId}</em> 。若有主从复制，要先下线从节点哦~ <img src="/Redis-Cluster-集群伸缩/集群收缩2.png" title="集群收缩2"></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群伸缩&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集群伸缩&quot;&gt;&lt;/a&gt; 集群伸缩&lt;/h2&gt;
&lt;p&gt;在已存在的集群中添加和删除集群节点，在集群伸缩的过程中伴随着虚拟槽在节点中的移动&lt;/p&gt;
&lt;h2 id=&quot;集群扩容&quot;&gt;&lt;a clas
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法 - 基于《算法》第四版</title>
    <link href="http://www.huangbin.fun/KMP%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.html"/>
    <id>http://www.huangbin.fun/KMP算法-基于《算法》第四版.html</id>
    <published>2020-04-20T13:01:18.000Z</published>
    <updated>2020-04-20T13:43:29.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2><ol><li>规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)</li><li>基本思想：当出现不匹配时，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配），根据这些已经知晓的内容决定  <strong>在出现不匹配时，模式应在处于哪个位置和文本的下一个字符比较 - 即找到已知晓内容和模式的最长公共前缀（利用模式去匹配已知晓的内容）</strong></li></ol><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><p>看《算法》的时候，有点部分真的太简洁了，看的晦涩难懂( 是我太菜了~ /(ㄒoㄒ)/~~） ，关注一下几个要点，要结合书中内容看可能会有新的理解</p><ol><li><p>指向文本的指针 i 永远不会回退，不会重复扫描文本，只有模式的指针 j 会进行回退。</p></li><li><p>有限状态机（DFA）只和 模式 有关，所以只要计算出了一个 模式的有限状态机（DFA），就可以匹配不同的文本。</p></li><li><p>DFA[txt.charAt(i)][j] = next， 表示 当前状态 j 时，遇到 文本字符 txt.charAt(i) （即 txt.charAt(i) 和 pat.charAt(j)进行比较）后的下一个状态是 next ( 即模式的指针 j 需要回退/前进到 next 处 和 文本字符 txt.charAt(i + 1)进行比较) 。</p></li><li><p>在一个状态中，要确定状态会进行何种转移，需要知道 <strong>当前状态</strong> 和 <strong>遇到的字符</strong>。</p></li><li><p>构造DFA：匹配成功时，即txt.charAt(i) == pat.charAt(j)，DFA[txt.charAt(i)][j] = j +1； 匹配失败时，模式指针 j 的回退也不是盲目回退， 它会根据 <strong>部分已经匹配成功的字符串与模式进行匹配后所处的状态（即书上所说的 X 重启状态）</strong> 以及 <strong>当前匹配失败的输入</strong> 来决定回退到哪个位置<img src="/KMP算法-基于《算法》第四版/匹配图.png" title="匹配图">在箭头处出现了不匹配，那此时pat 指针 j 应该回退到哪个地方在和 txt 的下一个字符 A 比较呢？<br>知道 状态 j 遇到了 字符D 发生了不匹配，意味着pat的前 j  个字符串 (0… j-1)和文本的 (i - j, i - 1)是相匹配的， 就像上述所示，但是我们不用理会 txt.charAt(i-j)，因为 i - j处已经不可能出现匹配，所以  <strong>部分已经匹配成功的字符串</strong> 就为 B A B A （pat[1… j - 1]）。<br>现我们考虑 B A B A 和 模式 进行匹配会到达什么状态（所到达的状态也是书中所提到的 <strong>重启状态 X</strong>），这个过程我们也可以看成是找 <strong>部分已经匹配成功的字符串</strong>  和 <strong>模式</strong> 的 <strong>最长公共前缀</strong> 的过程。<img src="/KMP算法-基于《算法》第四版/匹配图2.png" title="匹配图2">可以看到 B A B A 和 模式 进行匹配之后到达了 状态 3，即 X =3。则可以知道 DFA[D][5] = DFA[D][3]，即在状态 5 遇到 字符 D发生不匹配时应该回退的位置 就是在状态 3 遇到 字符 D 时 应该到达的位置。 这可以对应到书中代码 DFA[C][j] = DFA[C][X]。</p></li><li><p>困扰我很久的一个 X 如何进行求得，可以将其看成一个 X[] 数组，记录了模式与 部分匹配成功的字符串（pat[1…j -1]）所达到的所有状态（书本P765，图5.3.8很好的表达了此点）。它们之间关系是一个递推关系，X[i+1]为X[j]状态 遇到 pat.charAt(j)时所到达的状态，即 X[j + 1] = DFA[pat.charAt(j)][x[j]]，X[0]初始化状态为0。 这也便是书中代码中的 X = DFA[pat.charAt(j)][X]。理解了上述6,7之后，就可以写出构造DFA的过程（当然，我对于上述6，7的说明都是基于你已经看过了《算法》中字符串查找部分哦~）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] DFA;</span><br><span class="line">public void generateDFA(String pat)&#123;</span><br><span class="line">        int M = pat.length();</span><br><span class="line">        int R = 256;  // ASCII字符不会操过256种</span><br><span class="line">        DFA = new int[R][M];</span><br><span class="line">        // 初始化状态0, 在状态0只有遇到了pat.charAt(0)才会向前推进, 遇到其他为0(java默认初始化数组为0)</span><br><span class="line">        DFA[pat.charAt(0)][0] = 1;</span><br><span class="line">        int X = 0;  // 初始化重启状态为0</span><br><span class="line">        for (int j = 1; j &lt; M; j++)&#123;  // 构造DFA数组过程</span><br><span class="line">           for (int c = 0; c &lt; R; c++)</span><br><span class="line">          // 状态j遇到字符c不匹配时,把重启状态X遇到字符c到达哪个状态赋值DFA[c][j]</span><br><span class="line">                DFA[c][j] = DFA[c][X];</span><br><span class="line">           DFA[pat.charAt(j)][j] = j + 1;  // 匹配成功, 状态向前推进</span><br><span class="line">           X = DFA[pat.charAt(j)][X];  // 部分已经成功匹配字符串中增加了pat.charAt(i), 需要更新重启状态X,即它们的最长重叠字符会发生变化</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>我们已经计算出了DFA，下面是利用DFA来搜索文本的算法 - 结合书本P498 图5.3.7理解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int search(String txt) &#123;</span><br><span class="line">   int M = pat.length();</span><br><span class="line">   int N = txt.length();</span><br><span class="line">   int i,j;</span><br><span class="line">    // pat 的初始态为 0 - 模拟有限状态机运行</span><br><span class="line">   for (i = 0,j = 0; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">        // 当前是状态 j，遇到字符 txt[i]，</span><br><span class="line">        // pat 应该转移到哪个状态？</span><br><span class="line">        j = dp[txt.charAt(i)][j];</span><br><span class="line">        // 如果达到终止态，返回匹配开头的索引</span><br><span class="line">        if (j == M) return i - M;</span><br><span class="line">   &#125;</span><br><span class="line">   // 没到达终止态，匹配失败</span><br><span class="line">   return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>结合上面两部分就可以得到具体的KMP算法啦！ （ 具体参考书籍上的算法哦</p></li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>要使用KMP算法进行匹配，重要的是求出 DFA 数组，而要求出正确的得到DFA数组，格外需要关注（难理解）的是重启状态X和重启状态X的转移，即为每次发生匹配时，模式 和 pat[1…j]的最长公共前缀。只要得到了DFA数组之后，模拟有限状态机运行就可以进行匹配操作了。</li><li>对于长度为M的模式字符串和长度为N的文本，KMP查找算法访问字符串不会超过 N + M个。</li><li>就算书上所提的一样，KMP算法为最坏情况提供的线性级别运行时间保证的一个理论成果，在实际运用中，它比暴力算法的速度优势并不明显</li></ol><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p>[1] <a href="https://judes.me/tech/2016/04/10/kmp.html" rel="external nofollow noopener noreferrer" target="_blank">https://judes.me/tech/2016/04/10/kmp.html</a><br>[2] <a href="https://book.douban.com/subject/19952400/discussion/59623403/" rel="external nofollow noopener noreferrer" target="_blank">https://book.douban.com/subject/19952400/discussion/59623403/</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/83334559" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/83334559</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本思想&quot;&gt;&lt;/a&gt; 基本思想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;规定：匹配字符串 - 模式串(pat)， 匹配文本 - 文本(txt)&lt;/li&gt;
&lt;li&gt;基本思想：当出现不匹配时，就能
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="KMP" scheme="http://www.huangbin.fun/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster学习</title>
    <link href="http://www.huangbin.fun/Redis-Cluster%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Cluster学习.html</id>
    <published>2020-04-18T02:57:05.000Z</published>
    <updated>2020-04-18T03:29:21.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称当个Redis可以使用10万并发），高可用问题（部分节点不可达能继续处理命令）。 Redis 集群常常和主从复制结合使用。</p><h2 id="分布式数据库-数据分区"><a class="markdownIt-Anchor" href="#分布式数据库-数据分区"></a> 分布式数据库 - 数据分区</h2><img src="/Redis-Cluster学习/数据分区.png" title="数据分区"><h3 id="哈希分区"><a class="markdownIt-Anchor" href="#哈希分区"></a> 哈希分区</h3><p>假如有1~100条数据，按照哈希函数（例如 hash(key)%3），把数据分区到不同的三个数据库</p><ol><li>节点取余分区： hash(key) % nodes。若增加/减少节点，会进行大量数据迁移，例如当前有3个节点，增加了一个节点，按照新的hash(key) % 4进行计算时，很多数据需要进行移动。 建议进行 多倍扩容，例如当前有3个节点，可以扩容到6个节点，减少数据迁移量。节点取余也成为 不一致性哈希。比较适合缓存的场景</li><li>一致性哈希分区<br>能保证最小迁移数据，比较适合缓存的场景 - <a href="http://blog.codinglabs.org/articles/consistent-hashing.html" rel="external nofollow noopener noreferrer" target="_blank">一致性哈希分区</a></li><li>虚拟槽分区：Redis cluster采用此种分区方式，预设虚拟槽（slot），每个虚拟槽映射一个数据子集，每个节点管理一定数量的虚拟槽，redis 虚拟槽范围 0 ~ 16383。<br>使用分散函数（例如CRC16(keys) % slots ）计算出 keys 属于哪个槽，再根据节点所管理的槽的范围，从而确定数据属于哪个节点（节点中共享信息，若一个虚拟槽不属于当前节点，会告诉虚拟操去哪个节点去存储）</li></ol><img src="/Redis-Cluster学习/虚拟槽分区.png" title="虚拟槽分区"><h3 id="顺序分区"><a class="markdownIt-Anchor" href="#顺序分区"></a> 顺序分区</h3><p>假如有1 ~ 100条数据，按照顺序分区规则，可以把1 ~ 33，34 ~ 66，67 ~ 100分区到三个不同的三个数据库</p><h3 id="方式对比"><a class="markdownIt-Anchor" href="#方式对比"></a> 方式对比</h3><img src="/Redis-Cluster学习/分区比较.png" title="分区比较"><h2 id="cluster-架构"><a class="markdownIt-Anchor" href="#cluster-架构"></a> Cluster 架构</h2><img src="/Redis-Cluster学习/cluster架构.png" title="cluster架构"><ol><li>通过配置文件 cluster-enabled yes 将一个节点设置为一个集群节点</li><li>节点之间通过gossip协议进行通信，了解彼此的信息</li><li>将虚拟槽指派给上述节点</li><li>客户端通过 CRC16( key ) % 16383 并可知道对应的key应该到哪个虚拟槽的哪个节点进行处理</li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="配置集群节点"><a class="markdownIt-Anchor" href="#配置集群节点"></a> 配置集群节点</h3><ol><li><em>cluster-enabled yes</em>  # 配置当前节点为集群节点</li><li><em>cluster-config-file nodes-${port}.conf</em>  # 配置cluster节点自身配置文件</li><li><em>cluster-node-timeout 15000</em>  # 集群中各个节点相互通讯（ping）时，允许&quot;失联&quot;的最大毫秒数，如果超过这个时间没有得到响应，会认为该节点故障，若节点是主节点，则会进行故障转移</li><li><em>cluster-require-full-coverage yes</em>  # 若配置为 yes，则当集群中有节点不可用时，整个集群都不能提供服务，通常设置为 no</li></ol><h3 id="通过meet把每个集群节点组合成集群-集群发现"><a class="markdownIt-Anchor" href="#通过meet把每个集群节点组合成集群-集群发现"></a> 通过meet把每个集群节点组合成集群 - 集群发现</h3><ol><li><em>cluster meet ip port</em>  #当前节点去发现新的集群节点</li></ol><img src="/Redis-Cluster学习/发现集群.png" title="发现集群"><h3 id="分配槽"><a class="markdownIt-Anchor" href="#分配槽"></a> 分配槽</h3><ol><li><em>cluster addslots slot [slot…]</em>   # 为当前节点分配槽</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># addslots.sh</span><br><span class="line"># 开始槽</span><br><span class="line">start=$1</span><br><span class="line"># 结束槽</span><br><span class="line">end=$2</span><br><span class="line"># 分配端口</span><br><span class="line">port=$3</span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">   echo &quot;slot:$&#123;slot&#125;&quot;</span><br><span class="line">   redis-cli -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 分配操作</span><br><span class="line">sh addslots 0 5461 7000</span><br><span class="line">sh addslots 5462 10923 7001</span><br><span class="line">sh addslots 10923 16383 7002</span><br></pre></td></tr></table></figure><p>在第二步中配置了6个集群节点，但是只为7000 ~ 7002分配槽，7000 ~ 7002作为master，其余作为slave节点</p><h3 id="配置主从关系"><a class="markdownIt-Anchor" href="#配置主从关系"></a> 配置主从关系</h3><ol><li><em>cluster replicate node-id</em>  # 对 node-id节点进行复制，node-id在集群启动时会进行分配。</li><li><em>cluster nodes</em>  # 查看node-id</li></ol><img src="/Redis-Cluster学习/配置主从关系.png" title="配置主从关系"><h3 id="ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"><a class="markdownIt-Anchor" href="#ruby配置集群-除了上述安装方式官方提供了脚本进行快速集群配置"></a> Ruby配置集群 -除了上述安装方式，官方提供了脚本进行快速集群配置</h3><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>Gossip 协议：所有节点都保存了一份元数据，当节点发生伸缩或更新时，会将最新的元数据信息传播给所有节点。 - <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">gossip协议</a><br>Redis 使用Gossip协议时采用了meet，ping，pong，fail消息进行通信</li></ol><img src="/Redis-Cluster学习/gossip协议.png" title="gossip协议"><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p>[1] <a href="https://blog.csdn.net/makyan/article/details/104798725" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/makyan/article/details/104798725</a><br>[2] <a href="https://www.jianshu.com/p/8279d6fd65bb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/8279d6fd65bb</a><br>[3] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis Cluster 将数据分布到不同的节点当中，以解决Redis使用过程中的容量问题（单个Redis内存无法无限扩充），并发问题（官方称
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长回文子串</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长回文子串.html</id>
    <published>2020-04-13T10:40:48.000Z</published>
    <updated>2020-04-14T02:30:32.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>我们目标是得到一个字符串的最长回文子串，假设字符串S=“axbacabyd”（x，y表示未知字符），则可以定义出最优子结构，假设字符串子串 bacab是回文子串，则当前字符串的最长回文子串有如下两种最优子结构：</p><ol><li>若x == y，则最长回文子串为xbacaby</li><li>若x != y，则最长回文子串为bacab</li></ol><p>通过题目可知边界条件为</p><ol><li>字符串为单个字符时，此时最长回文子串为自身</li><li>字符串为两个字符时，若两个字符相等，则最长回文子串为自身，否则不存在最长回文子串</li></ol><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>定义 <em>F(i , j)</em> 为如下，</p><ol><li>若 <em>F(i , j) = true</em> , Si…Sj是回文子串</li><li>若 <em>F(i , j) = false</em>, 其他情况</li></ol><p>基于 <em>F(i , j)</em> 定义，可通过解析得到数学模型，即状态转移方程：<br>  <em>F(i , j) = true（F(i + 1, j -1) == true &amp;&amp; S[i] == S[j]）</em><br>  <em>F(i , j) = false （F(i + 1, j -1) == false || S[i] != S[j]）</em><br>  <em>F(i , i) = true</em><br>  <em>F(i , i + 1) = true （S[i] == S[i + 1]）</em></p><h2 id="动态规划实现"><a class="markdownIt-Anchor" href="#动态规划实现"></a> 动态规划实现</h2><p>接下来使用一个简单的例子，利用上述的数据建模，把求解最长回文子串的过程通过表格形式展示出来。<br>假设一个字符串str = “abcacfa”，回文子串求解过程如下：</p><ol><li><p>当下标为i=j=0时，<em>F(0 ,0) = true</em> ，遂标为T；当下标为i=0，j=1时，此时 <em>F(0 , 1) = false（S[0] != S[1]）</em> ，遂标为F； 当下标为i=j=1时， <em>F(1 , 1) = true</em> ，遂标为T；当下标为i=0，j=2时， <em>F(0 , 2) = false （F(1 , 1 ) == true &amp;&amp; str[0] != str[2])</em> ，遂标为F； 当下标为i=1，j=2时，此时 <em>F(1 , 2) = false（S[1] != S[2]）</em> ，遂标为F，当下标为i=j=2时， <em>F(2 , 2) = true</em> ，遂标为T<img src="/LeetCode-最长回文子串/过程图1.png" title="过程图1"></p></li><li><p>根据第一步的方法 ，可以补全整个表格如下，补全上半部分即可，i=2, j =4 与 i = 4, j =2表达的是同一个子串，可得到最长回文子串的cac。<img src="/LeetCode-最长回文子串/过程图2.png" title="过程图2"></p></li><li><p>通过完整表格可知，要判断一个i，j范围的子串是否是回文子串，只需判断 <em>（F(i + 1) == true &amp;&amp; str[i] == str[j]）</em> 是否为true即可，如下面红色所示。我们在进行代码编写时，也只需要保存上一次的计算结果即可。<img src="/LeetCode-最长回文子串/过程图3.png" title="过程图3"></p></li><li><p>代码实现</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getLongPalindromicSubstring(String str)&#123;</span><br><span class="line">            // 字符串为空或只有一个字符直接返回</span><br><span class="line">              if (str.length() == 0 || str.length() &lt; 2)</span><br><span class="line">                return str;</span><br><span class="line">            int len = str.length();</span><br><span class="line">            // TreeMap&lt;Integer,String&gt; PSMap = new TreeMap&lt;Integer, String&gt;(); </span><br><span class="line">            boolean [] preResult = new boolean[len];  // 存储上一次的计算结果</span><br><span class="line">            int start = 0, end = 0, maxLen = 0;  // 记录最长的回文子串的起始和结束索引</span><br><span class="line">            for (int j = 0; j &lt; str.length(); j++)&#123;</span><br><span class="line">                for (int i = 0; i &lt;= j; i++)&#123;</span><br><span class="line">                    // 对应数学模型 - F(i , i) = true</span><br><span class="line">                    if (i == j) &#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(1, String.valueOf(str.charAt(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, i + 1) = true （S[i] == S[i+1]）</span><br><span class="line">                    else if (j == i + 1 &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (2 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // PSMap.put(2,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 对应数学模型 - F(i, j) = true （F(i + 1, j -1) &amp;&amp; S[i] == S[j]）</span><br><span class="line">                    else if (preResult[i+1] &amp;&amp; str.charAt(i) == str.charAt(j))&#123;</span><br><span class="line">                        preResult[i] = true;</span><br><span class="line">                        if (j-i+1 &gt; maxLen)&#123;</span><br><span class="line">                            start = i;</span><br><span class="line">                            end = j;</span><br><span class="line">                            maxLen = j-i+1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //PSMap.put(j-i+1,str.substring(i,j+1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        preResult[i] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //String result = PSMap.lastEntry().getValue();</span><br><span class="line">            String result = str.substring(start, end + 1);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h3><ol><li>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li><li>注释的代码是用TreeMap存储已知的回文子串（treeMap能根据键的自然顺序进行排序），直接取最后一个key-value返回即可。但是需要花费额外的空间来存储，为了效率问题，采用了start，end来记录当前最长回文子串，虽然多了很多行代码，但是效率得到了一定的提高。</li><li>挖个小坑 - 中心扩散算法求解，有时间来填 /(ㄒoㄒ)/~~</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;br&gt;
示例 1：&lt;br&gt;
输入: “ba
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://www.huangbin.fun/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>初探动态规划算法</title>
    <link href="http://www.huangbin.fun/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.huangbin.fun/初探动态规划算法.html</id>
    <published>2020-04-13T09:18:28.000Z</published>
    <updated>2020-04-14T02:30:30.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>维基百科的定义如下：</p><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p></blockquote><p>从中我们知道动态规划关注三点：</p><ol><li>把一个问题划分为若干相似的子问题</li><li>所有的子问题只需要解决一次</li><li>存储子问题的解</li></ol><p>动态规划所涉及的几个重要概念也如下所示：</p><ol><li>最优子结构：每个阶段的最优状态可以从之前某个阶段的某个或某些状态得到。即思考大问题的最优解是如何由小问题的最优解得到的。</li><li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受此阶段以前各段状态的影响 - “未来和过去无关”</li><li>边界：通常是问题的结束条件</li><li>状态转移公式：说明了问题的每一阶段与上一个/一些阶段的相互关系</li><li>子问题重叠性质：在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法对此进行了优化，对每个子问题只需要计算一次，把计算结果存储在表格中，便于下次使用</li></ol><h1 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h1><p>一个动态规划算法基本可以分为以下步骤：</p><ol><li>从题目中确定最优子结构是什么</li><li>确定问题的边界条件</li><li>根据上述两步构建数学模型，得到相应的状态转移方程</li><li>根据数学模型进行代码编写</li></ol><h1 id="例题一"><a class="markdownIt-Anchor" href="#例题一"></a> 例题一</h1><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h2><p>假设0-9级台阶共有X个走法，0-8级台阶共有Y个走法，则总共的走法共有X+Y个走法，如下图所示：</p><img src="/初探动态规划算法/台阶示意图.png" title="台阶示意图"><p>对于8级台阶到10台阶，只存在跨越2步这个可能，因为若到了8级台阶之后，每次跨越1步，就到了9级台阶，此种走法包含到了9级台阶的X走法之中。<br>综上可知，到9级台阶的所有走法由到第8级台阶和第7级台阶组成….，以此类推。<br>无后效性体现在8级台阶之后的所有走法不受以前各级走法的影响。</p><h2 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模"></a> 数学建模</h2><p>使用数学公式可表示为 <em>F (10) = F (9) + F (8)</em> ，其可以看作为最优子结构，则以此类推 <em>F (9) =  F (8) + F (7)…</em>, 从而可以得到如下公式：<br>  <em>F (1) = 1</em>;<br>     <em>F (2) = 2</em>;<br>    <em>F (n) = F (n-1) + F (n-2)</em>;<br>从上面的公式可以看出 <em>F (1) = 1</em>，<em>F (2) = 2</em> 称为问题的边界，若一个问题没有边界，则永远无法得到有限的结果，<em>F (n) = F (n-1) + F (n-2)</em>  是状态转移方程，说明了问题的每一阶段与上一个/一些阶段的相互关系。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return getClimbingWays(n-1) + getClimbingWays(n - 2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下图递归的次数类似形成如下二叉树，每个节点表示递归方法所计算的次数，二叉树高度为N-1，节点个数接近2的N-1次方个，随递归方法的时间复杂度为O(N^2)。</p><img src="/初探动态规划算法/递归图.png" title="递归图"><p><strong>2. 备忘录算法</strong></p><p>使用递归算法有大量的重复计算，就像下图所示，</p><img src="/初探动态规划算法/递归图2.png" title="递归图"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getClimbingWays(int n, HashMap&lt;Integer, Integer&gt; memo)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memo.containsKey(n))&#123;</span><br><span class="line">            return memo.get(n);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int value =  getClimbingWays(n -1,memo) + getClimbingWays(n -2, memo);</span><br><span class="line">            memo.put(n,value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时的时间和空间复杂度都为O(N)</p><p><strong>3. 动态规划算法</strong></p><p>就算备忘录算法对算法进行了优化，但是其还是要保持所有的子状态，造成空间复杂度过高，并且递归算法和备忘录算法都是自顶向下进行处理，即从 <em>F (N)</em> 慢慢迭代到 <em>F (1)</em> 和 <em>F (2)</em> ，现尝试自底向上进行求解，只保存当前状态的前两个状态。分析过程如下：</p><ol><li><p>F (1)和F (2)为已知道结果，第一次迭代后，台阶数为3，走法数量为3，可知 <em>F (3)</em> 只依赖 <em>F (2)</em> 和 <em>F (2)</em>，可得下表<img src="/初探动态规划算法/第一次迭代.png" title="第一次迭代"></p></li><li><p>第二次迭代后，台阶数为4，走法为5，可知 <em>F (4)</em> 只依赖于 <em>F (3)</em> 和 <em>F (2)</em> <img src="/初探动态规划算法/第二次迭代.png" title="第二次迭代"></p></li></ol><p>其他迭代也如上所示，可知在每次迭代过程中，只需要保存前两个状态即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int getClimbingWays(int n)&#123;</span><br><span class="line">        if (n &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int ResultWays = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            ResultWays = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ResultWays;</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultWays;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态规划算法的时间复杂度为O(N)，空间复杂度为O(1)。</p><h1 id="例题二"><a class="markdownIt-Anchor" href="#例题二"></a> 例题二</h1><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br>其中金矿1：400金/5人，金矿2：500金/5人，金矿3：200金/3人，金矿4：300金/4人，金矿5：350金/3人</p><h2 id="解析-2"><a class="markdownIt-Anchor" href="#解析-2"></a> 解析</h2><p>我们的最终要求解的问题是：10人5金矿时的最优选择，我们可以先假设最优子结构为10个人4个金矿挖出最多黄金，但是第五个金矿存在挖或者不挖的可能性，遂可进行扩展分为两个最优子结构：</p><ol><li>第五个金矿不挖，最优子结构为10个人4个金矿挖出最多黄金</li><li>第五个金矿挖，最优子结构为10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量</li></ol><p>则五个金矿的最优选择就是（10个人4个金矿的最优选择）和（10 - 第五个金矿所需人数时挖4个金矿的最优选择 + 第五个金矿的黄金储量）的最大值。<br>边界分为两种情况，说明如下：</p><ol><li>只有一个金矿，并且工人数满足金矿所需人数要求，遂得到黄金数量为第<br>一个金矿的储量</li><li>只有一个金矿，若工人数不满足金矿所需人数要求，则得到的黄金数量为0</li></ol><h2 id="数学建模-2"><a class="markdownIt-Anchor" href="#数学建模-2"></a> 数学建模</h2><p>金矿数量 = <em>N</em> ，工人数量 = <em>W</em> ，金矿黄金量 <em>G []</em> ，每个金矿的用工数量 <em>P []</em> 。数组下标都从0开始，则5座金矿和4座金矿的最优选择之间存在如下关系： <em>F (5,10) = MAX (F (4,10), F (4,10-P [4]) +G (4) )</em> 。可以得到如下状态转移方程：<br>  <em>F (N W ) =0 (N &lt;= 1, W &lt; P [0])</em> ;   // 金矿数量小于1或一个金矿但是人数不足<br>  <em>F (N,W ) = G [0] (N == 1, W &gt;= P [0])</em> ;  // 金矿数量为1个，需要挖矿人数符合<br>  <em>F (N,W ) = F (N-1, W) (N &gt; 1, W &lt; P [N-1])</em> ;  //金矿数量大于一个，但是剩余的挖矿人数已经不满足继续挖矿<br>  <em>F (N,W ) = MAX (F (N-1,W ), F (N-1,W-P [N-1]) +G (N -1) )</em> ; //金矿数量大于一个，剩余的挖矿人数满足继续挖矿要求</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><p><strong>1. 递归实现</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getMostGold(int n, int w, int g[], int p[])&#123;</span><br><span class="line">        if (n == 1)&#123;</span><br><span class="line">            return w &lt; p[n-1] ? 0 : g[n-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (w &lt; p[n - 1])&#123;</span><br><span class="line">            return getMostGold(n-1,w,g,p);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(getMostGold(n-1,w,g,p), getMostGold(n-1, w - p[n-1],g,p) + g[n-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现的时间复杂度为O(2^N)。</p><p><strong>2. 动态规划实现</strong></p><p>给出一个表格，表格的列表示金矿（ <em>N</em> ），行表示工人数（ <em>W</em> ），相对应的值给定 <em>N</em> 和 <em>W</em> 之后获得的黄金数量。</p><ol><li><p>得到第一行数据如下：<img src="/初探动态规划算法/第一行数据.png" title="第一行数据"></p></li><li><p>当工人数在5-9期间时，设 <em>S</em> =5~9，<em>F (2, S ) = MAX (F (1, S ), F (1, S -5) +500)</em> , 其中都因为 <em>S -5 &lt; 5</em> ，则5~9格子中，黄金量为500。而当 _W = 10 _时，<em>F (2, 10) = MAX (F (1, 10), F (1, 5) + 500)</em> 为900。<img src="/初探动态规划算法/第二行数据.png" title="第二行数据"></p></li><li><p>第三个金矿200储量，需要3人，第四金矿300储量，需要4人，第五金矿350<br>储量，需要3人，依次计算可得下表：<img src="/初探动态规划算法/结果表.png" title="结果表"></p></li></ol><p>综上可得出规律，每个格子的黄金量都是都前一行的一个或者两个格子推导而来，例如3金矿8工人时，就来自于2金矿5工人+第三个金矿储量和2金矿8工人，即MAX (F (2, 8 ), F (2, 5) +200) =  MAX (500, 200 + 500) = 700。所以我们只需要存储前一行的数据，就可以推导出新的一行。<img src="/初探动态规划算法/规律图.png" title="规律表"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void getMostGold(int n, int w, int[] g, int[] p)&#123;</span><br><span class="line">        int[] preResult = new int [w]; // 保存前一行结果</span><br><span class="line">        int[] results = new int [w];  // 保存当前结果</span><br><span class="line">        // 填充第一个金矿的数据</span><br><span class="line">        for (int i = 0; i &lt; w; i++)&#123;</span><br><span class="line">            if (i+1 &lt; p[0])&#123;</span><br><span class="line">                preResult[i] = 0;  // 对应数学模型 F(N W)=0 (N&lt;=1,W&lt;P[0]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                preResult[i] = g[0];  // 对应数学模型 F(N,W)=G[0] (N==1,W&gt;=P[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showResults(preResult);  // 展示第一行的数据</span><br><span class="line">   </span><br><span class="line">        //对其他金矿进行处理，从第二个金矿开始,外层循环时金矿数量，内层循环时工人数</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;   </span><br><span class="line">            for (int j = 0; j &lt; w; j++)&#123;</span><br><span class="line">                if (j + 1 &lt; p[i])&#123;</span><br><span class="line">                    results[j] = preResult[j]; // 对应数学模型 F(N,W)=F(N-1,W) (N&gt;1,W&lt;P[N-1]);</span><br><span class="line">                &#125;else if (j + 1 == p[i])&#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],0 + g[i]); // 特殊情况,拥有工人数刚好与要挖的下一个金矿的所需工人数相同 若要挖下一个金矿，则挖前一个金矿的人数为0</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    results[j] = Math.max(preResult[j],preResult[j - p[i]] + g[i]); // 对应数学模型 F(N,W)=MAX(F(N-1,W),F(N-1,W-P[N-1]+G(N-1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            showResults(results);</span><br><span class="line">            preResult = results.clone();</span><br><span class="line">            // preResult = results; 不可直接进行引用的赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public void showResults(int[] results)&#123;</span><br><span class="line">        for(int i:results)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划实现的时间复杂度为O(N*W)，空间复杂度为O(W)。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>但是动态规划算法在有些情况下不一定是最好的选择，当5个金矿1000个工人时，因为动态规划的时间和空间复杂度与W成正比，而递归算法与W无关，其时间和空间复杂度都不如递归算法来的好。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]. <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>[2]. <a href="https://www.zhihu.com/question/23995189" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23995189</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h1&gt;
&lt;p&gt;维基百科的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dynamic programming is a method for solvi
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.huangbin.fun/categories/Algorithm/"/>
    
    
      <category term="Gynamic Programming" scheme="http://www.huangbin.fun/tags/Gynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel学习</title>
    <link href="http://www.huangbin.fun/Redis-Sentinel%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://www.huangbin.fun/Redis-Sentinel学习.html</id>
    <published>2020-04-10T14:10:33.000Z</published>
    <updated>2020-04-14T02:35:15.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sentinel生产可用。sentinel作为一个独立的进程，监控多个运行的Redis 数据库。<br>主要解决主从复制发生故障时，进行手动故障转移的复杂性问题，当主节点宕机后，需要手动选择一个从节点作为新的主数节点，其他作为从节点，而利用sentinel能自动完成故障转移过程。<br>sentinel也支持集群，因为使用单个sentinel进程了监控Redis是不可靠的，容易出现单点问题</p><ul><li>即使有一些sentinel进程宕掉了，依然可以进行Redis 集群的主从切换</li><li>如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现Redis 集群的主从切换</li><li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于Redis 集群中的信息</li></ul><h2 id="功能和架构"><a class="markdownIt-Anchor" href="#功能和架构"></a> 功能和架构</h2><ol><li>功能<ul><li>监控Redis的运行状况</li><li>当发生故障时实现主从切换。当一个master宕机之后，从它的多个slave中投票选举中一个新的master，剩余节点作为新的master的slave</li></ul></li><li>架构</li></ol><img src="/Redis-Sentinel学习/架构图.png" title="架构图"><p>在这个架构中，sentinel节点会监控master和slave的相关信息，主要值得关注的是client与sentinel之间的交互：</p><ol><li>client首先需要知道sentinel节点集合和mastername信息，通过遍历它所知道的sentinel集合，获取到一个可用的sentinel节点</li><li>找到可用的sentinel节点之后，client通过 sentinel get-master-addr-by-name masterName 命令的得到master节点的地址和端口</li><li>得到master相关信息之后，会进行一次role/role replication验证，master节点会返回验证信息，至此client可以对master进行写入和读取</li><li>sentine也会将redis数据节点的变化通知给客户端 - 使用发布订阅模式进行通知</li><li>上述过程不是通过代理模式实现的，即上述client和master建立关系的过程通常只需执行一次即可</li></ol><h2 id="故障转移过程"><a class="markdownIt-Anchor" href="#故障转移过程"></a> 故障转移过程</h2><ol><li>当一个sentinel检测master宕机并不会马上进行故障转移（主观下线），只有当后面的sentinel也都认为master不可用并达到一定数量时（客观下线），选举出一个领导者sentinel来进行故障转移操作</li><li>选出一个slave作为master，执行 slave of one 让其成为master节点</li><li>通知其余slave做为新的master的slave</li><li>等待老的master复活，若复活成功，成为新的master的slave</li><li>通知客户端发生了主从变化</li></ol><p>实现上述故障转移依靠三个定时任务：</p><ol><li>每10s每个sentinel对master和slave执行info操作<ul><li>发现slave操作</li><li>确认主从关系</li></ul></li><li>每2s每个sentinel通过master节点的channel交换信息<ul><li>发布订阅模式</li><li>通过_sentinel_:hello频道交互</li><li>交互对节点的&quot;看法&quot;和自身信息 - 可以知道其他sentinel的相关信息或投票来确定哪个sentinel来进行故障转移<img src="/Redis-Sentinel学习/sentinel发布订阅图.png" title="sentinel发布订阅图"></li></ul></li><li>每1s每个sentinel对其他sentinel和redis执行ping<ul><li>心跳检测，失败判定依据，比如可以作为客观下线的依据。</li></ul></li></ol><h2 id="sentinel配置和启动"><a class="markdownIt-Anchor" href="#sentinel配置和启动"></a> Sentinel配置和启动</h2><ol><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sentinel运行端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 守护进程启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># sentinel工作目录</span><br><span class="line">dir &quot;/usr/local/share/redis/redis-3.0.5/backs&quot;</span><br><span class="line"></span><br><span class="line"># sentinel 日志文件</span><br><span class="line">logfile &quot;sentinel-26379.log&quot;</span><br><span class="line"></span><br><span class="line"># sentinel监控的master信息 master-name ip port quorum - 当quorm个数sentinel节点认为maste</span><br><span class="line"># r失联,则执行故障转移</span><br><span class="line">sentinel monitor mymaster 192.168.2.23 6379 2</span><br><span class="line"></span><br><span class="line"># 一定时间内,master没有应答哨兵sentinel, sentinel认为master主观下线 默认30秒(ping 30 次没有ping通)</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 在进行主从切换时(故障转移),最多可以几个slave对新的master进行同步。若设置的值很小, 则同</span><br><span class="line">步需要花费很长时间, 值很大,则有很多slave应为同步复制而不可用, 也会降低master节点的性能</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移超时时间, 应用于以下情况</span><br><span class="line"># 1. 同一个sentinel对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2. 当一个slave从一个错误的master那里同步数据开始计算时间,直到slave被纠正为向正确的mast</span><br><span class="line"># er那里同步数据时</span><br><span class="line"># 3.当想要取消一个正在进行的failover所需要的时间  </span><br><span class="line"># 4.当进行failover时,配置所有slaves指向新的master所需的最大时间。不过，即使过了这个时间,</span><br><span class="line"># slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则进行处理</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>注：可以看到sentinel.conf配置文件主要是对master节点进行监控，通过master节点使用 info replecation 进行slave的相关信息获取，会将获取的slave信息自动添加到 sentinel.conf配置文件之中，在配置文件中的标识为：Generated by CONFIG REWRITE，需要注意的是，redis在添加slave信息的同时，也会对一些配置信息进行更改，例如sentinel down-after-milliseconds，sentinel parallel-syncs，sentinel failover-timeout会被移除，添加sentinel config-epoch，sentinel leader-epoch等配置 。</p><ol start="2"><li>启动</li></ol><p>  <em>redis-sentinel sentinel.conf</em>  # 启动sentinel<br>  <em>redis-cli -p 26379</em>  # 连接sentinel, sentinel也当成一个普通的Redis 节点来对待</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>主观下线：每个sentinel节点对Redis 节点失败的&quot;偏见&quot;，可能由于网络问题，Redis 节点不能在规定的时间内回应sentinel节点</li><li>客观下线：所有sentin节点对Redis 节点失败达成&quot;共识&quot;，即sentinel节点中认为Redis 节点可以进行客观下线的个数超过quorum的个数，此时可以真正进行故障转移操作。其中达成共识通过sentinel is-master-down-by-addr命令询问其他sentinel节点的&quot;意见&quot;来完成的</li><li>领导者选举<ul><li>原因：只需要一个sentinel节点来进行故障转移</li><li>如何：1. 每个做主观下线的sentinel节点通过sentinel is-master-down-by-addr 来询问其他sentinel节点的&quot;意见&quot;是否要对master节点进行客观下线的时候，通过也会要求将其设置为领导者；2. 收到命令的sentinel节点如果没有同意其他sentinel节点成为领导者的请求，那就同意，否则拒绝；3. 如果该sentinel节点发现自己的票数超过了sentinel集合半数且超过了quorum，那么它将成为领导者来进行故障处理；4. 如果有多个sentin节点成为领导者，则过一段时间再进行选举</li></ul></li><li>如何选择合适的slave让其成为master<ul><li>选择 slave-priority优先级最高的slave节点</li><li>若全部优先级相同，则选择复制偏移量最大（与以前的master节点数据最接近）的slave节点</li><li>若上述都不成立，则选择runId最小的节点，即启动最早的slave</li></ul></li></ol><h2 id="运维问题"><a class="markdownIt-Anchor" href="#运维问题"></a> 运维问题</h2><ol><li>主节点手动下线，进行故障转移<br>  <em>sentinel failover masterName</em></li><li>高可用的读写分离<br>sentinel只会对master节点进行故障转移，对于slave节点只有进行主观下线，所以要实现高可用的读写分离，客户端要关注slave节点的变化，例如关注以下三个消息: +switch-master: 从节点晋升为主节点，+conver-to-slave:  原主节点降为从节点，+sdown: 主观下线</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://segmentfault.com/a/1190000002680804" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002680804</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis sentinel称为哨兵模式，是Redis 高可用的实现方法，具有故障发现，故障自动转移，配置中心和客户端通知，2.8版本后sent
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.huangbin.fun/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://www.huangbin.fun/Redis主从复制.html</id>
    <published>2020-04-10T13:53:44.000Z</published>
    <updated>2020-04-14T02:33:00.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave）上，数据流向是单向的 - Master -&gt; Slave。通常主数据进行数据写入操作，从数据库进行读操作，实现数据的读写分离。</p><h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2><ol><li><p>命令方式</p><ul><li><em>slaveof  slavehost</em> # 将 slavehost 将复制为当前Redis数据库的从数据库，异步操作，会将数据库的数据进行清除。<br><em>e.g., 127.0.0.1: 6380 &gt; slaveof 127.0.0.1: 6379</em>  # 127.0.0.1: 6379将会成为127.0.0.1: 6380的主数据库</li><li><em>slaveof  no one</em> # 取消当前命令执行数据库的复制，以前主数据库已经同步的数据不会清除。</li><li><em>info replication</em>  # 当前数据库是主还是从数据库的相关信息</li></ul></li><li><p>配置 - redis.conf，配置之后需重启</p><ul><li><em>slaveof  masterip masterport</em></li><li><em>slave-read-only yes</em></li></ul></li></ol><h2 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h2><p>执行完全量复制之后，主从数据库之间数据库状态已经相同了。但这个状态并非一成不变，如果主数据库执行了写操作，那么主数据库的数据库状态就会修改，并导致主从数据库状态不再一致。所以为了让主从数据库再次回到一致状态，主数据库需要对从数据库执行命令传播操作：主数据库会将自己执行的写命令，也即是造成主从数据库不一致的那条写命令，发送给从数据库执行，当从数据库执行了相同的写命令之后，主从数据库将再次回到一致状态。</p><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><img src="/Redis主从复制/主从复制.png" title="全量复制"><ol><li>复制过程<ul><li>从数据库向主数据库发送PSYNC命令 - 从2.8开始，SYNC替换成PSYNC，提供了完整重同步和部分重同步</li><li>收到PSYNC命令后，主数据库将自身的runId和offset传给从数据库，之后主数据库执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li><li>当主数据库的BGSAVE命令执行完毕时，主数据库会将BGSAVE命令生成的RDB文件发送给从数据库，从数据库接收并载入这个RDB文件，将自己的数据库状态更新至主数据库执行BGSAVE命令时的数据库状态</li><li>主数据库将记录在缓冲区里面的所有写命令发送给从数据库，从数据库执行这些写命令，将自己的数据库状态更新至主数据库数据库当前所处的状态</li></ul></li><li>开销<ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>清空从数据库花费时间</li><li>从数据库加载RBD文件花费的时间，并且载入期间，从数据库可能因为阻塞而无法处理客户端请求</li></ul></li></ol><h2 id="部分复制"><a class="markdownIt-Anchor" href="#部分复制"></a> 部分复制</h2><img src="/Redis主从复制/部分复制.png" title="部分复制"> <ol><li>解决问题：处理从数据库断线后的重连问题。当从数据库在断线后重新连接主数据库时，如果条件允许，主数据库可以将主从数据库连接断开期间执行的写命令发送给从数据库，从数据库只要接收并执行这些写命令，就可以将数据库更新至主数据库当前所处的状态。而2.8以前，断连之后还要进行一次SYNC操作。</li><li>复制过程<ul><li>当从数据库断线后，主数据库会继续把写命令放入到复制积压缓冲区（replication backlog）中</li><li>当从数据库重新连上主数据库时，从数据库会通过PSYNC命令将自己的复制偏移量（replication offset）和主数据库的运行ID（run id）发送给主数据库，主数据库会根据这个复制偏移量和运行ID来决定对从数据库执行何种同步操作</li><li>如果从数据库发送的运行ID和当前连接的主数据库的运行ID相同，那么说明从数据库断线之前复制的就是当前连接的这个主数据库，主数据库可以继续尝试执行部分复制操作</li><li>相反，如果从数据库发送的运行ID和当前连接的主数据库的运行ID并不相同，主数据库将对从数据库执行全量复制操作</li><li>如果从数据库的复制偏移量之后的数据（也即是offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主数据库将对从数据库执行部分复制操作</li><li>相反，如果offset之后的数据已经不存在于复制积压缓冲区，那么主数据库将对从数据库执行全量复制操作</li></ul></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><ol><li>复制偏移量（replication offset）：主数据库和从数据库会分别维护一个复制偏移量：<ul><li>主数据库每次向从数据库传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从数据库每次收到主数据库传播来的N个字节的数据时，就将自己的复制偏移量的值加上N<br>对比主从数据库的复制偏移量，可知道主从数据库是否处于一致状态：</li><li>如果主从数据库处于一致状态，那么主从数据库两者的偏移量总是相同的</li><li>相反，如果主从数据库两者的偏移量并不相同，那么说明主从数据库并未处于一致状态</li></ul></li></ol><img src="/Redis主从复制/复制偏移量.png" title="复制偏移量"><ol start="2"><li><p>复制积压缓冲区（replication backlog）：复制积压缓冲区是由主数据库维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主数据库进行命令传播时，它不仅会将写命令发送给所有从数据库，还会将写命令入队到复制积压缓冲区里面。因此，主数据库的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量<img src="/Redis主从复制/复制积压缓冲区.png" title="复制积压缓冲区"><br>复制积压缓冲区默认大小为1MB，如果主数据库需要执行大量写命令，又或者主从数据库断线后重连接所需的时间比较长，那么Redis的部分复制功能可能会达不到想要的效果。复制积压缓冲区的最小大小可以根据公式 second*write_size_per_second 来估算：</p><ul><li>second为从数据库断线后重新连接上主数据库所需的平均时间（以秒计算）</li><li>write_size_per_second是主数据库平均每秒产生的写命令数据量。</li><li>例如，如果主数据库平均每秒产生1 MB的写数据，而从数据库断线之后平均要5秒才能重新连接上主数据库，那么复制积压缓冲区的大小就不能低于5MB。为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理，可以通过修改repl-backlog-size配置进行设置。</li></ul></li><li><p>数据库运行ID<br>每个Redis数据库，不论主数据库还是从服务，都会有自己的运行ID。运行ID在数据库启动时自动生成，由40个随机的十六进制字符组成，例53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。<br>当从数据库对主数据库进行初次复制时，主数据库会将自己的运行ID传送给从数据库，而从数据库则会将这个运行ID保存起来。当从数据库断线并重新连上一个主数据库时，从数据库将向当前连接的主数据库发送之前保存的运行ID。</p></li></ol><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li>读写分离<ul><li>数据复制延迟</li><li>读到过期数据</li><li>从数据库故障</li></ul></li><li>主从数据库配置不一致<ul><li>maxmemory不一致：丢失数据</li><li>数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致</li></ul></li><li>规避全量复制<ul><li>第一次全量复制不可避免 - 尽量低峰（夜间）进行</li><li>避免主数据库runId不匹配导致的全量复制</li><li>避免复制积压缓冲区不足导致的全量复制 - 修改rel_backlog_size配置</li></ul></li><li>规避复制风暴<ul><li>单主数据库复制风暴 - 主数据库重启，多从数据库复制</li><li>单机器复制风暴 - 机器有多个主数据库，机器宕机，大量全量复制。避免多个主数据库部署在一个机器上</li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;单个Redis数据库很容易出现单点故障和容量瓶颈问题，Redis支持将主数据库（Master）上的数据复制多份到在多个不同的从数据库（Slave
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化常见问题</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangbin.fun/Redis持久化常见问题.html</id>
    <published>2020-04-10T13:45:43.000Z</published>
    <updated>2020-04-14T02:35:04.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fork操作"><a class="markdownIt-Anchor" href="#fork操作"></a> Fork操作</h2><ol><li>定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这是一种内核机制，在创建子进程并不发生复制，创建子进程后父子进程共用数据，只有在修改数据是才会创建新的空间。</li><li>Redis中需要用到fork操作的相关命令：bgsave，bgrewriteaof，查看上一次fork消耗时间：info stats</li><li>同步操作 - 会对父进程执行的业务造成影响</li><li>与内存量息息相关 - 内存越大，耗时越长，同时也与机器类型相关</li><li>改善fork：<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存: maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1 。修改sysctl vm.overcommit_memory=1<br>  0  -  表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br> b1 -  表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>  2 -  表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>降低fork频率：例如放宽AOP重写的自动触发时机</li></ul></li></ol><h2 id="子进程的开销和优化"><a class="markdownIt-Anchor" href="#子进程的开销和优化"></a> 子进程的开销和优化</h2><ol><li>CPU<ul><li>开销: RDB和AOF文件的生成，属于CPU密集型</li><li>优化： 不做CPU绑定 ，不和CPU密集型一起部署</li></ul></li><li>内存<ul><li>开销: fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>硬盘<ul><li>开销：AOF和RDB文件写入，结合iostat，iotop分析</li><li>优化：不和高硬盘负载服务部署在一起，根据写入量决定磁盘类型。</li></ul></li><li>扩展：<ul><li>CPU绑定 - 进程和CPU的绑定是为了让应用获得更好的性能，进程的Affinity属性指明了进程调度器能够把这个进程调度到哪些CPU上。CPU Affinity分为2种，soft affinity和hard affinity。soft affinity仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的CPU上。hard affinity是调度器必须遵守的规则。</li><li>CPU密集型（CPU-bound），也叫计算密集型，系统运作时CPU的消耗接近100%，I/O读写可以在很短的时间完成，但是CPU的计算任务繁重。多重程序系统中，大部份时间用来做计算、逻辑判断等的程序称之CPU bound，一般而言，CPU bound的程序CPU占用率相当高。</li><li>I/O密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，CPU消耗并不高。I/O bound的程序需要大量的I/O操作。</li><li>Transparent hugepage默认是被开启的以便去改善操作系统的内存管理，但是在某种情况下会造成不可预知的节点重启和性能问题</li></ul></li></ol><h2 id="aof追加阻塞"><a class="markdownIt-Anchor" href="#aof追加阻塞"></a> AOF追加阻塞</h2><ol><li><p>定义：如果AOF文件同步时间与上次同步时间相比大于2s，Redis主进程就会阻塞，等待同步完成；如果AOF文件同步时间与上次同步时间相比小于2s，Redis主进程就会返回。其实这样做的目的是为了保证文件安全性的一种策略。 <img src="/Redis持久化常见问题/AOF追加阻塞.png" title="AOF追加阻塞"></p></li><li><p>问题：</p><ul><li>主线程阻塞造成业务受影响</li><li>虽然每秒everysec刷盘策略，但是实际上不是丢失1s数据，实际有可能丢失2s数据</li></ul></li><li><p>问题定位</p><ul><li><p>Redis日志<img src="/Redis持久化常见问题/Redis日志.png" title="Redis日志"></p></li><li><p>Info Persistence中的aof_delayed_fsync,同步延迟历史总数</p></li></ul></li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fork操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork操作&quot;&gt;&lt;/a&gt; Fork操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义：调用fork函数给当前正在运行的进程创建一个子进程。根据copy-on-write（写时复制）机制，这
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://www.huangbin.fun/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.huangbin.fun/Redis持久化.html</id>
    <published>2020-04-10T12:44:30.000Z</published>
    <updated>2020-04-14T02:35:09.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化</p><h2 id="rdb持久化"><a class="markdownIt-Anchor" href="#rdb持久化"></a> RDB持久化</h2><ol><li><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行了指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB生成的文件也可作为复制媒介使用。</p></li><li><p>触发方式</p><ul><li><em>save</em>  # 客户端发出命令后，redis会生成相应的dump.rdb文件（若存在老的RDB文件，则新替老）。该命令为同步命令，进行Save 命令时，其他命令不能执行，容易发生阻塞， O(n)</li><li><em>bgsave</em> #与Save 不同的是，该命令为异步命令，会开一个子进程进行处理， O(n)</li></ul> <img src="/Redis持久化/RDB持久化.png" title="RDB持久化"> <img src="/Redis持久化/RDB持久化2.png" title="RDB持久化2"> <ul><li>利用配置文件进行触发 - 采用 bgsave方式</li></ul> <img src="/Redis持久化/RDB持久化3.png" title="RDB持久化3"> <p>  <strong>重要配置项：</strong><br>   dbfilename dump.rdb  # 指定本地数据库名<br>   dir ./   # 指定本地数据库存放目录<br>   rdbcompression yes #默认开启数据压缩，redis采用LZF压缩方式，但占用了一点CPU的时间。<br>   stop-writes-on-bgsave-error yes #出现错误是否停止写入<br>   rdbchecksum yes #是否对RDB文件进行校验</p><ul><li>全量复制 - 主从复制时会自动生成RDB文件</li><li>debug reload - 也会生成RDB文件</li><li>shutdown - Redis也会RDB文件</li></ul></li><li><p>优缺点</p><ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li><li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了 - 不可控，丢失数据。</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件 - 耗时，耗性能</li></ul></li></ol><h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2><ol><li><p>Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></li><li><p>配置文件</p><ul><li>appendonly yes  # 开启AOF</li><li>appendfilename “appendonly-6379.aof” # 指定本地数据库名</li><li>appendfsysnc always/everysec/no # 指定更新日志条件<br>  - always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但是数据完整性比较好（慢，安全）<br>  - everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>  - no ：不同步，由OS决定何时把命令写入到文件中</li></ul> <img src="/Redis持久化/AOF持久化.png" title="AOF持久化">  <img src="/Redis持久化/AOF持久化2.png" title="AOF持久化2">  <img src="/Redis持久化/AOF持久化3.png" title="AOF持久化3"> <ul><li>为了缩小AOF文件的大小，提供了AOP重写,目的减少磁盘占用量（减少冗余）,加速恢复速度</li></ul> <img src="/Redis持久化/AOF持久化4.png" title="AOF持久化4"> <p>  <strong>重写原理</strong><br>  Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中，并没有读取旧文件，最后替换旧的aof文件。<br>  <strong>重写方式</strong><br>  a. bgrewriteaof  #异步，会开启一个子进程来进行处理<br>  b. 配置文件 - 执行bgrewriteaof<br>    auto-aof-rewrite-min-size #AOF文件重写需要的尺寸<br>    auto-aof-rewrite-percentage #AOF文件增加率<br>    当AOF文件大小是上次rewrite后大小的一倍（增加率）且文件大于64M（尺寸）时触发</p><ul><li>no-appendfsync-on-rewrite yes # 在重写时是否可以进行AOF持久化操作</li><li>aof-load-truncated yes # 在AOF文件出现错误时，是否忽略错误，尽量加载更多的数据</li><li>在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复</li></ul></li><li><p>优缺点</p><ul><li>更高的数据完整性和一致性</li><li>随着时间的增加，AOF文件会越来越大，数据恢复速度会越来越慢，可以通过重写解决</li></ul></li></ol><h2 id="持久化策略对比"><a class="markdownIt-Anchor" href="#持久化策略对比"></a> 持久化策略对比</h2><img src="/Redis持久化/持久化对比.png" title="持久化对比"> <h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://www.cnblogs.com/itdragon/p/7906481.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/itdragon/p/7906481.html</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;Redis所有数据保存在内存中，把内存中的数据保存在磁盘中，称之为持久化&lt;/p&gt;
&lt;h2 id=&quot;rdb持久化&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis其他特性和功能</title>
    <link href="http://www.huangbin.fun/Redis%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%92%8C%E5%8A%9F%E8%83%BD.html"/>
    <id>http://www.huangbin.fun/Redis其他特性和功能.html</id>
    <published>2020-04-10T12:26:49.000Z</published>
    <updated>2020-04-14T02:34:59.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询"></a> 慢查询</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来，可将其持久化到磁盘中供开发人员分析。</p><h3 id="客户端请求生命周期"><a class="markdownIt-Anchor" href="#客户端请求生命周期"></a> 客户端请求生命周期</h3><img src="/Redis其他特性和功能/请求生命周期.png" title="请求生命周期"><p>慢查询是一个先进先出的队列，该队列固定长度，保存在内存中。若一条命令在第三阶段的执行过程中被判断为慢查询，则会进行该队列。</p><h3 id="慢查询配置"><a class="markdownIt-Anchor" href="#慢查询配置"></a> 慢查询配置</h3><img src="/Redis其他特性和功能/慢查询.png" title="慢查询"><ol><li>slowlog-log-slower-than: 命令是否是慢查询的界定条件（阈值），单位微秒，例如超过10毫秒就认为该命令是慢查询，= 0 是代表记录所有命令，&lt; 0 不记录任何命令，默认：10000。</li><li>slowlog-max-len: 慢查询列表的固定长度，默认：128</li><li>slowlog list:  指明有哪些慢查询</li><li>参数配置：<ul><li>修改配置文件</li><li>动态配置：config set slowlog-max-len 1000</li></ul></li></ol><h3 id="慢查询命令"><a class="markdownIt-Anchor" href="#慢查询命令"></a> 慢查询命令</h3><ol><li><em>slowlog get [n]</em> # 获取慢查询队列， n 指明获取几个慢查询记录</li><li><em>slowlog len</em>  # 获取慢查询队列长度</li><li><em>slowlog reset</em> # 清空慢查询队列</li></ol><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>slowlog-max-len：线上环境建议调大慢查询日志的列表，记录慢查询日志时Redis会对长命令做截断操作，并不会占用大量内存。增大慢查询列表可以减缓慢查询被剔除出列表的可能性。例如线上可以设置为1000以上。</li><li>slowlog-log-lower-than：需要根据redis的并发量调整该值。由于redis采用单线程，对于高流量的场景，如果执行命令的时间在1毫秒以上，那么redis最多可支撑OPS（每秒操作次数）不到1000，因此高OPS场景的redis建议设置为1毫秒。</li><li>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行slow get命令将慢查询日志持久化到其他存储中，然后制作可视化界面查询。</li></ol><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> pipeline</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><p>利用pipeline可以一次从发送多条命令（打包），在服务端执行之后，在把结果一次性返回，节省了命令/结果在网络中的传输时间。若没有使用pipeline，n次命令的操作，要额外花费n-1网络时间，因为redis的命令执行都是微秒级别，所以网络时间通常是瓶颈所在。</p><img src="/Redis其他特性和功能/pipeline.png" title="pipeline"><img src="/Redis其他特性和功能/pipeline2.png" title="pipeline2"><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">pipeline.set(&quot;product&quot;,&quot;computer&quot;);</span><br><span class="line">pipeline.set(&quot;producttwo&quot;,&quot;microwave&quot;);</span><br><span class="line">pipeline.syncAndReturnAll();</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3><ol><li>注意每次pipeline携带数据量</li><li>pipeline每次只能作用在一个Redis节点上</li><li>M操作（mset）是原子操作，pipeline命令非原子操作。</li></ol><h2 id="发布订阅"><a class="markdownIt-Anchor" href="#发布订阅"></a> 发布订阅</h2><h3 id="发布订阅模型"><a class="markdownIt-Anchor" href="#发布订阅模型"></a> 发布订阅模型</h3><img src="/Redis其他特性和功能/发布订阅.png" title="发布订阅"><h3 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h3><ol><li><em>publish channel message</em> # 发布者向对应频道发布消息, 返回订阅者数量<br><em>e.g., publish sohu:tv “hello!”</em></li><li><em>subscribe [channel]</em>  # 订阅一个或多个频道</li><li><em>unsubscribe [channel]</em>  # 取消订阅一个或多个频道</li><li><em>psubscribe [pattern…]</em>  # 订阅一个或多个符合给定模式的频道<br>e.g., psubscribe it*   # 将会订阅以it开头的频道</li><li><em>punsubscribe [pattern…]</em>  # 取消订阅一个或多个符合给定模式的频道</li><li><em>pubsub channels</em>  # 列出至少有一个订阅者的频道</li><li><em>pubsub numsub [channels…]</em>  # 列出给定频道的订阅者数量</li></ol><h3 id="与消息队列的区别"><a class="markdownIt-Anchor" href="#与消息队列的区别"></a> 与消息队列的区别</h3><p>发布订阅时，所以订阅者都可以收到发布者的信息，而消息队列是消息订阅者从消息队列中取消息，不保证每个消息订阅者都可以得到消息。</p><h2 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h2><h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3><p>位图（也称为位数组，位向量等）是紧凑存储位的数组数据结构。redis提供了对位的操作。</p><img src="/Redis其他特性和功能/位图.png" title="位图"><h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3><p>位数组是自动扩展的，如果超出现有内容范围，它会自动将位数组进行零扩充。</p><img src="/Redis其他特性和功能/位图特征.png" title="位图特征"><h3 id="api-2"><a class="markdownIt-Anchor" href="#api-2"></a> API</h3><ol><li><em>setbit key offset value</em> # 给位图指定偏移量设置值</li><li><em>getbit key offset</em> #  得到指定偏移量的值</li><li><em>bitcount  key [start end]</em> #  获取位图指定范围(start - end, 单位为字节， 不指定则代表获取全部)位值位1的个数</li><li><em>bitop  op destkey key[key…]</em>  #  对多个位图进行 and (交集)，or(并集)，not(非)，xor(异或)操作，并把结果保存在 destkey 中</li><li><em>bitpos  key targetBit [start] [end]</em>   #计算位图指定范围(start-end, 单位为字节, 不指定则代表获取全部)第一个值等于 targetBit 的偏移量</li></ol><h3 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h3><ol><li>Type = String, 最大512MB</li><li>注意setbit时的偏移量，可能损耗大</li><li>活跃用户统计/用户的签到等等应用都有奇效</li></ol><h2 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h2><h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3><p>基于HyperLogLog算法，极小空间完成独立数量（基数）统计。本质还是字符串。<br>基数统计：一个集合（注意：这里集合的含义是 Object 的聚合，可以包含重复元素）中不重复元素的个数。例如集合 {1,2,3,1,2}，它有5个元素，但它的基数/Distinct 数为3。</p><h3 id="api-3"><a class="markdownIt-Anchor" href="#api-3"></a> API</h3><ol><li><em>pfadd key element [element…</em> # 向hyperloglog添加元素</li><li><em>pfcount key [key…</em> # 计算hyperloglog的独立总数</li><li><em>pfmerge destkey  sourcekey[sourcekey…</em> # 合并多个hyperloglog</li></ol><h3 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h3><ol><li>存在错误率 - 0.81%</li><li>不能取出单条数据</li><li>鉴于 HyperLogLog 不保存数据内容的特性，所以，它只适用于一些特定的场景。例如计算日活、月活数据等等</li></ol><h2 id="geo-redis-32支持"><a class="markdownIt-Anchor" href="#geo-redis-32支持"></a> GEO - redis 3.2+支持</h2><h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3><p>GEO: 地理信息定位，存储经纬度，计算两地距离，范围计算等。redis的geo实现采用数据结构为zset</p><h3 id="api-4"><a class="markdownIt-Anchor" href="#api-4"></a> API</h3><ol><li>geoadd key longitude latitude member [longitude latitude member… # 增加地理位置信息<br>e.g., geoadd city:location 116.28 39.55 bejing</li><li>geopos key member [member… # 获取地理位置信息</li><li>geolist key member1 member2 [unit] # 获取两个地理位置的距离 unit: m, km, mi, ft</li><li>georadius<img src="/Redis其他特性和功能/GEO.png" title="GEO"></li><li>zrem key member # edis的geo实现采用数据结构为 zset，遂可以使用zset API进行删除</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;慢查询&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#慢查询&quot;&gt;&lt;/a&gt; 慢查询&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h3&gt;
&lt;p&gt;慢查询日
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和相应操作</title>
    <link href="http://www.huangbin.fun/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%9B%B8%E5%BA%94%E6%93%8D%E4%BD%9C.html"/>
    <id>http://www.huangbin.fun/Redis数据结构和相应操作.html</id>
    <published>2020-04-10T12:00:59.000Z</published>
    <updated>2020-04-14T02:34:47.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis通用操作"><a class="markdownIt-Anchor" href="#redis通用操作"></a> Redis通用操作</h2><ol><li><em>Keys [pattern]</em> # 遍历出指定模式的key，可使用 <em>, ?等通配符 - 一般不在生产环境中使用，O(n)<br>  _Keys</em>_  # 遍历出所有key<br>  <em>Keys he[h-l]*</em>   # 遍历以 he 开头，第三个字符在 h-l 期间的匹配key</li><li><em>dbsize</em> # 计算 key 的总数，O(1)</li><li><em>exists key</em> # 检查 key 是否存在，O(1)级别时间复杂度</li><li><em>del key</em> # 删除指定 key ，O(1)</li><li><em>expire key seconds</em> #  key在 seconds 秒后过期 ，O(1)</li><li><em>ttl key</em> #  查看 key 剩余过期时间  -1 表达无过期时间  -2表示已过期，O(1)</li><li><em>persist key</em> #  去掉 key 的过期时间 ，O(1)</li><li><em>type key</em> # 返回 key 的类型 ，O(1)</li></ol><h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> String类型</h2><h3 id="string键值结构"><a class="markdownIt-Anchor" href="#string键值结构"></a> String键值结构</h3><img src="/Redis数据结构和相应操作/String数据结构.png" title="String数据结构"><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><em>get key</em> # 获取 key 对应value ，O(1)</li><li><em>set key value</em> # 设置 key-value ，已有相同 key 值，则进行覆盖，O(1)</li><li><em>setnx key value</em> # 设置 key-value ，key 不存在，才进行设置，O(1)</li><li><em>set key value</em> xx # 设置 key-value ，key 存在，才进行设置，O(1)</li><li><em>del key</em> # 删除 key-value ，O(1)</li><li><em>incr key</em> # key 自增1, 如果key不存在，自增都get(key)=1 ，O(1)</li><li><em>decr key</em> # key 自减1, 如果key不存在，自减都get(key)=-1 ，O(1)</li><li><em>incrby key k</em> # key 自增k, 如果key不存在，自增都get(key)=k ，O(1)</li><li><em>decrby key k</em> # key 自减k, 如果key不存在，自减都get(key)=-k，O(1)</li><li><em>mget key1 key2  key3…</em> # 批量获取key，原子操作，O(n)</li><li><em>mset key1 value1 key2 value2 key3 value3…</em> # 批量设置key-value，原子操作，O(n)</li><li><em>getset key newvalue</em>   #  set key newvalue并返回 oldvalue，O(1)</li><li><em>append key value</em>   #  将 value 将追加到  oldvalue，O(1)</li><li><em>strlen key</em>   #  返回字符串长度（注意中文） ，O(1)</li><li><em>incrbyfloat key floatValue</em>   #  增加key 对应的值 ，O(1)</li><li><em>getrange key start end</em>   #  获取字符串指定下标的所有值 ，O(1)</li><li><em>setrange key index value</em>   #  设置指定下标对应的值 ，O(1)</li></ol><h2 id="hash类型"><a class="markdownIt-Anchor" href="#hash类型"></a> Hash类型</h2><h3 id="hash键值结构"><a class="markdownIt-Anchor" href="#hash键值结构"></a> Hash键值结构</h3><img src="/Redis数据结构和相应操作/Hash数据结构.png" title="Hash数据结构"><p>注： field不能相同，value可以相同</p><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><ol><li><em>hget key field</em> # 获取 hash key 对应field 的 value ，O(1)</li><li><em>hset key field value</em> # 设置 hash key 对应field 的 value ，O(1)</li><li><em>hdel key field</em> # 删除 hash key 对应field 的 value ，O(1)</li><li><em>hexists key field</em> # 判断 hash key 是否有对应 field ，O(1)</li><li><em>hlen key</em> # 获取 hash key 的 field 数量，O(1)</li><li><em>hmget key field1 field2…</em>  # 批量获取hash-key的一批 field 对应值，O(n)</li><li><em>hmset key  field1 value1 field2 value2…</em> # 批量设置 hash-key的一批 field 对应值，O(n)</li><li><em>hgetall key</em>   # 返回 hash-key 对应所有的 field-value 值，O(n)</li><li><em>hvals key</em>   # 返回 hash-key 对应所有 field 的 value 值，O(n)</li><li><em>hkeys key</em>   # 返回 hash-key 对应所有 field ，O(n)</li><li><em>hincrby key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hincrbyfloat key field k</em>   # key field 自增 k ，如果key不存在，自增都hget(key, field)=k ，O(1)</li><li><em>hsetnx key field value</em> # 设置 hash key对应 field的 value ，field 不存在，才进行设置，O(1)</li></ol><h2 id="list类型"><a class="markdownIt-Anchor" href="#list类型"></a> List类型</h2><h3 id="list键值结构"><a class="markdownIt-Anchor" href="#list键值结构"></a> List键值结构</h3><img src="/Redis数据结构和相应操作/List数据结构.png" title="List数据结构"><p>注: 有序（由插入顺序决定遍历顺序），可以重复，左右两边插入弹出</p><h3 id="操作-3"><a class="markdownIt-Anchor" href="#操作-3"></a> 操作</h3><ol><li><em>rpush key value1 value2…</em> # 从列表的右端插入值 ，O(1~n)</li><li><em>lpush key value1 value2…</em> # 从列表的左端插入值 ，O(1~n)</li><li>linsert key before/after value newvalue # 在list指定的值前|后插入新值，O(n)</li><li><em>lpop key</em>  # 从列表的左端弹出一个值（删除） ，O(1)</li><li><em>rpop key</em>  # 从列表的右端弹出一个值（删除） ，O(1)</li><li><em>lrem key count value</em>  # 根据 count  值，从列表中删除所有 value  相等的项 ，O(n)<ul><li>count  &gt; 0 , 从左到右，删除最多 count  个 value  相等的项目</li><li>count  &lt; 0 , 从右到左，删除最多 Math.abs(count)  个 value  相等的项目</li><li>count  = 0 , 删除所有 value  相等的项目</li></ul></li><li><em>ltrim key start end</em>  # 按照索引范围(索引从 0 开始 ，-1 表示最后一个元素)修剪列表 ，O(n)</li><li><em>lrange key start end</em>  # 获取列表指定索引范围(索引从 0 开始，-1 表示最后一个元素，包括 end )的值 ，O(n)<ul><li>lrange list 0 5 = lrange list -6 -1 = lrange list 0 -1</li></ul></li><li><em>lindex key index</em>  # 获取列表指定索引的值 ，O(n)</li><li><em>llen key</em>  # 获取列表长度 ，O(1)</li><li><em>lset key index newValue</em>  # 设置列表指定索引的值 ，O(n)</li><li><em>blpop key timeout</em>  # lpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li><li><em>rlpop key timeout</em>  # rpop 阻塞版本，timeout  是阻塞超时时间，为0 表示永不超时 ，O(1)</li></ol><h2 id="set类型"><a class="markdownIt-Anchor" href="#set类型"></a> Set类型</h2><h3 id="set键值结构"><a class="markdownIt-Anchor" href="#set键值结构"></a> Set键值结构</h3><img src="/Redis数据结构和相应操作/Set数据结构.png" title="Set数据结构"><p>注: 无序（顺序不由插入顺序决定），不可重复，支持集合间的操作</p><h2 id="操作-4"><a class="markdownIt-Anchor" href="#操作-4"></a> 操作</h2><ol><li><em>sadd key value1 value2…</em>.  # 向集合 key 中添加元素，若已有重复元素，则添加失败 ，O(n)</li><li><em>srem key value1 value2…</em>. # 移除集合 key 中元素，O(n)</li><li><em>scard key</em>   # 计算集合元素个数，O(1)</li><li><em>sismember key value</em> # 判断集合 key 中 value 元素是否存在，O(n)</li><li><em>srandmember key count</em>  # 随机从集合 key 中挑选 count  个元素，O(n)</li><li><em>spop key</em>  # 随机从集合 key 中挑选 1 个元素，O(1)</li><li><em>smembers key</em>  # 获取集合 key 中所有元素，O(n)</li><li><em>sdiff key1 key2</em>  # 两个集合的差集，O(n)</li><li><em>sinter key1 key2</em>  # 两个集合的交集，O(n)</li><li><em>sunion key1 key2</em>  # 两个集合的并集，O(n)</li><li><em>sunionstore/sdiffstore/sinterstore destkey key1 key2</em>   # 并集/差集/交集结果存到 destkey  中，O(n)</li></ol><h2 id="sorted-set类型"><a class="markdownIt-Anchor" href="#sorted-set类型"></a> Sorted Set类型</h2><h3 id="sorted-set键值结构"><a class="markdownIt-Anchor" href="#sorted-set键值结构"></a> Sorted Set键值结构</h3><img src="/Redis数据结构和相应操作/SortedSet数据结构.png" title="SortedSet数据结构"><p>注: 有序，不可重复，支持集合间的操作</p><h2 id="操作-5"><a class="markdownIt-Anchor" href="#操作-5"></a> 操作</h2><ol><li><em>zadd key score value score2 value2…</em>.  # 向有序集合 key 中添加score value对，value不可重复元素，否则添加失败 ，O(logN)</li><li><em>zrem key  value  value2…</em>.  # 删除有序集合 key 中添加元素 ，O(1)</li><li><em>zscore key  value</em>   # 获取有序集合 key 中 value 对应的 score ，O(1)</li><li><em>zincrby key increScore value</em>   # 增加有序集合 key 中 value 对应的 score 值，O(1)</li><li><em>zcard key</em>   # 获取有序集合 key 中 value 个数，O(1)</li><li><em>zrank key value</em>   # 获取有序集合 key 中 value 的排名(从低到高)，O(1)</li><li><em>zrevrank key value</em>   # 获取有序集合 key 中 value 的排名(从高到低)，O(1)</li><li><em>zrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrange key start end [withscores]</em>   # 获取有序集合指定索引范围(索引从 0 开始，-1 表示最后一个元素)的值并打印 score   - 降序，O(logn + m)</li><li><em>zrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 升序，O(logn + m)</li><li><em>zrevrangebyscore key minScore maxScore [withscores]</em>   # 获取有序集合指定分数范围的值并打印 score   - 降序，O(logn + m)</li><li><em>zcount key minScore maxScore</em>    #  获取有序集合指定分数范围的值的个数 ，O(logn + m)</li><li><em>zremrangebyrank key start end</em> #  删除指定排名内的升序元素，O(logn + m)</li><li><em>zremrangebyscore key minScore maxScore</em> #  删除指定分数范围的升序元素，O(logn + m)</li></ol><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="http://redisdoc.com/" rel="external nofollow noopener noreferrer" target="_blank">http://redisdoc.com/</a><br>[2] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis通用操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis通用操作&quot;&gt;&lt;/a&gt; Redis通用操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Keys [pattern]&lt;/em&gt; # 遍历出指定模式的key，可使用 &lt;em
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis是什么?</title>
    <link href="http://www.huangbin.fun/Redis%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
    <id>http://www.huangbin.fun/Redis是什么.html</id>
    <published>2020-04-10T11:51:51.000Z</published>
    <updated>2020-04-14T02:34:53.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted set），哈希（Hash）。</p><h2 id="数据结构和内部编码"><a class="markdownIt-Anchor" href="#数据结构和内部编码"></a> 数据结构和内部编码</h2><img src="/Redis是什么/数据结构图.png" title="数据结构图"><p>Redis 源码中设置了一个redisObject数据结构，描述了此种关系。</p><img src="/Redis是什么/内部编码图.png" title="内部编码图"><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ol><li>速度快 - 基于内存，C语言编写，单线程 - 纯内存，非阻塞IO（实时性好，但是占用大量CPU资源），避免线程切换和竞态消耗。</li><li>持久化 - Rdis所有数据保持在内存中，可对数据进行持久化在磁盘中。</li><li>多种数据结构，在新的版本中，还提供了位图（Bitmaps），超小内存唯一值计数（HyperLogLog），地理信息定位（GEO）数据结构。但是其数据结构内部还是基于上述五种基本的数据结构实现的，Bitmaps，HyperLogLog都是String数据类型。</li><li>支持多种客户端语言 - Java, PHP, Python等。</li><li>功能丰富 - 发布订阅, 事务, Lua脚本, pipeline。</li><li>“简单” - 不依赖外部库，单线程模型。</li><li>主从复制</li><li>高可用 - Redis-Sentinel(V2.8)，分布式 - Redis-Cluster(V3.0)</li><li>多数据库 - 一个redis实例包括了15个数据库，可以选择连接哪个数据据进行操作。选择数据据命令为select 1。 同时可以选择move somekey 1把当前数据库的key移动到数据库1。</li><li>事务 - multi：开始事务，后面的命令都会被认为是事务的一部分操作；exec：提交事务；discard：事务回滚。</li><li>注意: Redis是单线程，一次执行一条命令，所以拒绝长（慢命令） - keys，flushall，flushdb，slow，lua script，mutil/exec，operate big value(collection)。对于fysnc file descriptor，close file descriptor会开启另外一个独立线程进行操作。</li></ol><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li>缓存系统</li><li>消息队列 - 秒杀，抢购等。<a href="https://www.zhihu.com/question/54152397" rel="external nofollow noopener noreferrer" target="_blank">什么是消息队列？</a></li><li>计数器 - 网站访问统计，微博转发评论，视频播放</li><li>排行榜</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>[1] <a href="https://coding.imooc.com/class/151.html" rel="external nofollow noopener noreferrer" target="_blank">https://coding.imooc.com/class/151.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;高性能键值对数据库，支持的键值数据类型：字符串（String），字符串列表（list），字符串集合（set），有序字符串集合（sorted se
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.huangbin.fun/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.huangbin.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt;最长公共前缀</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"/>
    <id>http://www.huangbin.fun/LeetCode-最长公共前缀.html</id>
    <published>2019-10-20T09:11:56.000Z</published>
    <updated>2019-10-20T09:17:44.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br></p><ul><li><p>示例 1:<br>输入: [“flower”,“flow”,“flight”]<br>输出: “fl”<br></p></li><li><p>示例 2:<br>输入: [“dog”,“racecar”,“car”]&lt;<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="垂直扫描法"><a class="markdownIt-Anchor" href="#垂直扫描法"></a> 垂直扫描法</h2><p><img src="https://pic.leetcode-cn.com/b647cab7c3d2bd157cecae10917e0b9b671756b92c9cfcefec1a2bdae299c11c-file_1555694071243" alt="水平扫描法"></p><ol><li>取出第一个字符串暂时作为最长公共前缀（prefixStr）；</li><li>依次遍历字符串数组中的其他字符串，分别与prefixStr比较；</li><li>若当前字符不包含prefixStr，则对prefixStr进行裁取（长度减一），再次与当前字符进行比较；</li><li>若当前字符包含prefixStr，则取出字符串数组的下一个字符串与prefixStr进行比较；</li></ol><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><ul><li>时间复杂度：O(S)，S是所有字符串中字符数量的总和，最坏情况时n个字符串全部相同，则indexOf要比较S次字符比较</li><li>空间复杂度：O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs.length == 0) return &quot;&quot;;</span><br><span class="line">        String prefixStr = strs[0];  </span><br><span class="line">        for(int i = 1; i &lt; strs.length; i++)&#123;</span><br><span class="line">            while(strs[i].indexOf(prefixStr) != 0)&#123;  </span><br><span class="line">                prefixStr = prefixStr.substring(0,prefixStr.length() - 1); </span><br><span class="line">                if(prefixStr.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefixStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平扫描法"><a class="markdownIt-Anchor" href="#水平扫描法"></a> 水平扫描法</h2><ol><li>取出字符串数组中的第一个字符串，遍历该字符串中的字符，依次与数组中的其他字符串的同列字符比较；</li><li>若出现不同的字符，则对第一个字符串进行相应位置截取，便得最长公共前缀；</li><li>若某字符串长度等于当前所比较字符位置（i = strs[j].length()），则也进行第2步的截取操作；</li></ol><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><ul><li>时间复杂度: O(S)，S 是所有字符串中字符数量的总和</li><li>空间复杂度: O(1)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for(int i = 0; i &lt; strs[0].length(); i++)&#123;</span><br><span class="line">            char a = strs[0].charAt(i);</span><br><span class="line">            for(int j = 1; j &lt; strs.length; j++)&#123;</span><br><span class="line">                if( i == strs[j].length() || a != strs[j].charAt(i))&#123;    // 先执行||, 然后执行后面, 且i == strs[j].length()表示存在字符串已经遍历完</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>&lt;LeetCode&gt; 无重复字符的最长子串长度</title>
    <link href="http://www.huangbin.fun/LeetCode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.html"/>
    <id>http://www.huangbin.fun/LeetCode-无重复字符的最长子串长度.html</id>
    <published>2019-10-12T06:52:59.000Z</published>
    <updated>2019-10-20T09:18:15.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br></p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><h2 id="滑动窗口算法"><a class="markdownIt-Anchor" href="#滑动窗口算法"></a> 滑动窗口算法</h2><p>滑动窗口算法用于对给定的大缓冲区或数组的特定窗口大小执行所需的操作(即在遍历大缓存区或数组时, 对其特定的窗口大小执行特定操作)。目的是将很少出现问题的嵌套for循环转换为单个for循环，从而降低时间复杂度。例如: 找出某数组中和最大的子数组， 规定子数组元素个数为3， 即窗口大小为3， 当然窗口大小也可以是动态的。具体过程如下：<br><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动过程"></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><p><strong>实现一</strong></p><ul><li>时间复杂度: O(2n)=O(n)，最糟糕的情况下，每个字符要被i，j分别访问一次</li><li>空间复杂度: O(min(m, n))，滑动窗口法需要 O(k)的空间，其中 k表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int record = 0,i = 0,j = 0;  // record记录最长子串长度</span><br><span class="line">        int length = s.length(); </span><br><span class="line">        Set strSet = new HashSet();  // 使用HashSet作为滑动窗口</span><br><span class="line">        while(i &lt; length &amp;&amp; j &lt; length)&#123;</span><br><span class="line">            if(!strSet.contains(s.charAt(j)))&#123;  // s.charAt(j)不在strSet中</span><br><span class="line">                strSet.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                record = Math.max(record, j - i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                strSet.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现二</strong><br><br>该实现是对滑动窗口的优化，即在窗口中存在与当前元素相同的字符，直接把窗口左端移动到相同字符的后一位，而不是一步一步的移动左端窗口。</p><ul><li>时间复杂度: O(n)，单单j会遍历n次</li><li>空间复杂度: O(min(m, n))</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int length = s.length(), record = 0;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0, j = 0; j &lt; length; j++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(j)))&#123;  // 包含了有相同字符</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)),i);  // 把i定位到存储在map中且与s.charAt(j)相同的字符的下一个索引位置</span><br><span class="line">            &#125;</span><br><span class="line">            record = Math.max(record,j - i + 1);  // + 1是因为前面已经排除了相同字符, 遂可把s.charAt(j)字符加入参与长度计算 </span><br><span class="line">            map.put(s.charAt(j), j + 1);  // 把s.charAt(j)索引+1是方便i的定位(定位到相同元素的后一位)</span><br><span class="line">        &#125;</span><br><span class="line">        return record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例 1:&lt;br&gt;
输入: “abc
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://www.huangbin.fun/tags/LeetCode/"/>
    
  </entry>
  
</feed>
