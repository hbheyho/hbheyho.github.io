<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="J.U.C 之阻塞队列"><meta name="keywords" content="J.U.C"><meta name="author" content="HB"><meta name="copyright" content="HB"><title>J.U.C 之阻塞队列 | HB's Blog</title><link rel="shortcut icon" href="/MyBlog.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用阻塞队列"><span class="toc-number">2.</span> <span class="toc-text"> 常用阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列方法"><span class="toc-number">3.</span> <span class="toc-text"> 阻塞队列方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞队列方法"><span class="toc-number">3.1.</span> <span class="toc-text"> 非阻塞队列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞队列方法-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 阻塞队列方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列源码分析"><span class="toc-number">4.</span> <span class="toc-text"> 阻塞队列源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要变量"><span class="toc-number">4.1.</span> <span class="toc-text"> 主要变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">4.2.</span> <span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法"><span class="toc-number">4.3.</span> <span class="toc-text"> put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enqueue方法"><span class="toc-number">4.4.</span> <span class="toc-text"> enqueue方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#take方法"><span class="toc-number">4.5.</span> <span class="toc-text"> take方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dequeue方法"><span class="toc-number">4.6.</span> <span class="toc-text"> dequeue方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用实例"><span class="toc-number">5.</span> <span class="toc-text"> 使用实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/07/30/eJEjKO.jpg"></div><div class="author-info__name text-center">HB</div><div class="author-info__description text-center">记录自己填坑之路（又称踩坑大全:D）和喜欢的一些东西~</div><div class="follow-button"><a href="https://github.com/hbheyho" rel="external nofollow noopener noreferrer" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HB's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">J.U.C 之阻塞队列</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Concurrency/">Concurrency</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>在编程中接触的队列更多的为非阻塞队列，例如PriorityQueue，LinkedList。这些队列不会对当前线程进行阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略（例如使用Object::wait，Object::notify来实现线程阻塞）。阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p>
<h2 id="常用阻塞队列"><a class="markdownIt-Anchor" href="#常用阻塞队列"></a> 常用阻塞队列</h2>
<ol>
<li>ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列；</li>
<li>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE；</li>
<li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列；</li>
<li>DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ol>
<h2 id="阻塞队列方法"><a class="markdownIt-Anchor" href="#阻塞队列方法"></a> 阻塞队列方法</h2>
<h3 id="非阻塞队列方法"><a class="markdownIt-Anchor" href="#非阻塞队列方法"></a> 非阻塞队列方法</h3>
<ol>
<li>add(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</li>
<li>remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</li>
<li>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</li>
<li>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</li>
<li>peek()：获取队首元素，若成功，则返回队首元素；否则返回null。</li>
</ol>
<p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。<br>
上述5个方法都没有采用同步策略。</p>
<h3 id="阻塞队列方法-2"><a class="markdownIt-Anchor" href="#阻塞队列方法-2"></a> 阻塞队列方法</h3>
<p>阻塞队列中也提供了add(E e)，remove()，offer(E e)，poll()，peek()方法，不同的是，阻塞队列对上述方法都采用了同步策略。</p>
<ol>
<li>put(E e)：put方法用来向队尾存入元素，如果队列满，则等待；</li>
<li>take()：take方法用来从队首取元素，如果队列为空，则等待；</li>
<li>offer(E e,long timeout, TimeUnit unit)：offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</li>
<li>poll(long timeout, TimeUnit unit)：poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素。</li>
</ol>
<h2 id="阻塞队列源码分析"><a class="markdownIt-Anchor" href="#阻塞队列源码分析"></a> 阻塞队列源码分析</h2>
<p>以ArrayBlockingQueue为例分析具体实现原理，基于JDK 8。</p>
<h3 id="主要变量"><a class="markdownIt-Anchor" href="#主要变量"></a> 主要变量</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现了BlockingQueue接口, 继承了AbstractQueue类</span><br><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    private static final long serialVersionUID = -817911632652898426L;</span><br><span class="line"></span><br><span class="line">    // 使用一个数组来存储队列中的元素</span><br><span class="line">    private final E[] items;</span><br><span class="line">    // 队列头指针, take, poll, remove方法使用</span><br><span class="line">    private int takeIndex;</span><br><span class="line">    // 队列尾指针, put, offer, add方法使用</span><br><span class="line">    private int putIndex;</span><br><span class="line">    // 队列中元素个数</span><br><span class="line">    private int count;</span><br><span class="line">     </span><br><span class="line">    // 可重入锁来控制所有的访问</span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    // 等待获取元素的条件变量</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    // 等待放置元素的条件变量</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// capacity参数指定容量</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量以及公平性</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">&#125;</span><br><span class="line">// capacity参数指定容量, 公平性以及初始化集合</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                                                  Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put方法"><a class="markdownIt-Anchor" href="#put方法"></a> put方法</h3>
<p>put方法用来向队尾存入元素，如果队列满，则等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    // 判断传入元素是否为空</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    // 获得可一个重入锁, 保证线程安全性</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">    // 若阻塞队列已满, 则将线程加入到同步队列中</span><br><span class="line">    while (count == items.length)</span><br><span class="line">        // 阻塞当前线程,将其加入到同步队列</span><br><span class="line">        notFull.await();</span><br><span class="line">        // 进行入队操作</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enqueue方法"><a class="markdownIt-Anchor" href="#enqueue方法"></a> enqueue方法</h3>
<p>enqueue方法完成具体的入队操作，并且唤醒等待获取元素的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    // 元素入队</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 入队之后队列已满</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    // 队列元素 + 1</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒等待获取元素的线程</span><br><span class="line">    // 从等待队列中移除, 移到AQS同步队列中, 等待获取锁</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="take方法"><a class="markdownIt-Anchor" href="#take方法"></a> take方法</h3>
<p>take方法用来从队首取元素，如果队列为空，则等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    // 获取可重入锁, 支持中断</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 若阻塞队列为空, 则将线程加入到同步队列中</span><br><span class="line">        // 等待获取资源</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        // 进行出队操作</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dequeue方法"><a class="markdownIt-Anchor" href="#dequeue方法"></a> dequeue方法</h3>
<p>dequeue方法完成具体的出队操作，并且唤醒等待入队元素的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 获取队列中元素</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    // 获取之后元素置为null</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 出队之后队列为空</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">    t   akeIndex = 0;</span><br><span class="line">    // 队列元素 - 1</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒等待放置元素的线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h2>
<p>使用Object::wait和Object::notify方法实现生产者-消费者模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">    // 缓存区</span><br><span class="line">    private LinkedList&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line">     </span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == buffer.size())&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();    </span><br><span class="line">            &#125;</span><br><span class="line">            buffer.add(string);</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        String string;</span><br><span class="line">        synchronized(buffer)&#123;</span><br><span class="line">            while (maxSize == 0)&#123;</span><br><span class="line">                // 释放锁, 并挂起当前线程</span><br><span class="line">                buffer.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            string = buffer.poll();</span><br><span class="line">            buffer.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用阻塞队列实现生产者-消费者模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProducerAndConsumer &#123;</span><br><span class="line">// 缓存区</span><br><span class="line">private ArrayBlockingQueue&lt;String&gt; buffer; </span><br><span class="line">    // 缓冲区大小</span><br><span class="line">    private int maxSize ;        </span><br><span class="line"></span><br><span class="line">    ProducerAndConsumer(int maxSize)&#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        buffer = new ArrayBlockingQueue&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(String string) throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        try&#123;</span><br><span class="line">            buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get() throws InterruptedException &#123;</span><br><span class="line">        // 阻塞队列已经提供了同步策略, 不需要再显示进行同步</span><br><span class="line">        String str = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            str = buffer.put(string);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>[1] <a href="https://www.cnblogs.com/dolphin0520/p/3932906.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/dolphin0520/p/3932906.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">HB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.huangbin.fun/J-U-C-之阻塞队列.html">http://www.huangbin.fun/J-U-C-之阻塞队列.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/J-U-C/">J.U.C</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/J-U-C之线程池-转.html"><i class="fa fa-chevron-left">  </i><span>[转] J.U.C之线程池</span></a></div><div class="next-post pull-right"><a href="/J-U-C之Callable-Future-FutureTask.html"><span>J.U.C之Callable, Future, FutureTask</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'OsrlEL0GyLWhwM5Xotg4xfqf-gzGzoHsz',
  appKey:'SoCJQuXAiFLxpAUwilquruNA',
  placeholder:'来呀~快来评论呀~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/07/30/eJVZqg.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HB</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hbheyho.github.io/" rel="external nofollow noopener noreferrer" target="_blank">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>